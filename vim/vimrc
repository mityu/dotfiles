" vim: shiftwidth=2
vim9script noclear

# Encoding
if !v:vim_did_enter
  set encoding=utf-8
  $MYVIMRC = resolve(expand('<sfile>'))
endif

scriptencoding utf-8

# Local utility functions
export def SIDPrefix(): string
  # Returns "<SNR>{script-ID}_"
  return expand('<SID>')
enddef

def SNR(): string
  return matchstr(SIDPrefix(), '<SNR>\zs\d\+\ze_$')
enddef

def Rc(fname: string): string
  return Filesystem.rcfile_prefix .. fname
enddef

export def JoinPath(...arg: list<any>): string
  return join(arg, Filesystem.slash)
enddef

export def HasInString(object: string, to_search: string): bool
  return stridx(object, to_search) != -1
enddef

def GetMsgString(msg: string): string
  return '[vimrc] ' .. msg
enddef

def EchomsgWithColor(msg: string, hl_group: string)
  execute 'echohl' hl_group
  echomsg GetMsgString(msg)
  echohl NONE
enddef

export def Echomsg(msg: string)
  EchomsgWithColor(msg, 'NONE')
enddef

export def EchomsgError(msg: string)
  EchomsgWithColor(msg, 'Error')
enddef

export def EchomsgWarning(msg: string)
  EchomsgWithColor(msg, 'WarningMsg')
enddef

export def Echo(msg: string)
  echo GetMsgString(msg)
enddef

export def EchoQuestion(question: string)
  echon GetMsgString(question) .. ' '
  echohl Question
  echon '[Y/N]'
  echohl NONE
  echon "\n"
enddef

export def Ask(question: string): bool
  EchoQuestion(question)
  return getcharstr() =~? 'y'
enddef

export def Mkdir(dir: string, ...opt: list<any>): bool
  if isdirectory(dir)
    return true
  endif
  return !!call('mkdir', [dir] + opt)
enddef

export def Input(prompt: string, ...opt: list<any>): string
  try
    return call('input', [prompt] + opt)
  catch /\C^Vim:Interrupt$/
    return ''
  endtry
  return ''
enddef

# Global utility functions
export def SetUndoFtplugin(config: string)
  var restorer = 'execute ' .. string(config)
  if exists('b:undo_ftplugin')
    b:undo_ftplugin = restorer .. '|' .. b:undo_ftplugin
  else
    setbufvar('%', 'undo_ftplugin', restorer)
  endif
enddef
command! -nargs=1 -complete=command SetUndoFtplugin
      \ call SetUndoFtplugin(<q-args>)

legacy def! Tapi_drop(bufnr: number, arglist: list<any>)
  var cwd = arglist[0]
  var filepath = arglist[1]
  if !isabsolutepath(filepath)
    filepath = fnamemodify(cwd, ':p') .. filepath
  endif
  var opencmd = 'drop'
  if bufwinnr(bufnr(filepath)) == -1
    opencmd = 'split'
  endif
  execute opencmd fnameescape(filepath)
enddef

legacy def! Tapi_getcwd(bufnr: number, arglist: list<any>)
  var cwd = call('getcwd', arglist)
  var channel = term_getjob(bufnr)->job_getchannel()
  ch_sendraw(channel, cwd .. "\n")
enddef

final IsWindows = has('win32')
final IsWinUnix = has('win32unix')
final IsLinux = has('linux')
final IsMac = has('mac')
final IsUnix = IsLinux || IsMac
final IsWSL = IsLinux && system('uname -r') =~? 'microsoft'

export var Filesystem: dict<string>
export var Stdpath: dict<string>
if IsWindows
  $DOT_VIM = expand('~\vimfiles')
  Filesystem = {
    slash: '\',
    path_separator: ';',
    rcfile_prefix: '_'
  }
  Stdpath = {
    cache: expand('~\.cache\vim')
  }
else
  $DOT_VIM = expand('~/.vim')
  Filesystem = {
    slash: '/',
    path_separator: ':',
    rcfile_prefix: '.'
  }
  Stdpath = {
    cache: expand('~/.cache/vim')
  }
endif

# Startup config
if !v:vim_did_enter
  if has('multi_lang') && has('menu')
    set langmenu=ja.utf-8
  endif

  # NOTE: This must be set before 'termguicolors' option is set, or display
  # will get chaos.
  if $TERM_PROGRAM ==# 'WezTerm'
    &t_Cs = "\e[4:3m"
    &t_Ce = "\e[4:0m"
  endif

  if &term =~# '\<\%(256color\|win32\)\>' && $TERM_PROGRAM !=# 'Apple_Terminal'
    set termguicolors  # Use true color if possible.
  endif

  if &term =~# '\<xterm\>'
    &t_EI = "\<ESC>[2 q"  # Use Block style cursor in Normal-mode.
    &t_SI = "\<ESC>[6 q"  # Use Bar style cursor in Insert-mode.
    &t_SR = "\<ESC>[4 q"  # Use underline style cursor in Replace-mode.
    set mouse=a
  endif

  if &term ==# 'win32'
    set mouse=a
    # FIXME: It seems that these values aren't reflected well when they're set
    # just here.
    autocmd VimEnter * ++once {
      &t_EI = "\<ESC>[2 q"  # Use Block style cursor in Normal-mode.
      &t_SI = "\<ESC>[6 q"  # Use Bar style cursor in Insert-mode.
      &t_SR = "\<ESC>[4 q"  # Use underline style cursor in Replace-mode.
    }
  endif

  # disable modifyOtherKeys
  &t_TI = ''
  &t_TE = ''

  # disable default plugins
  g:loaded_2html_plugin = 1
  g:loaded_getscriptPlugin = 1
  g:loaded_gzip = 1
  g:loaded_zipPlugin = 1
  g:loaded_tarPlugin = 1
  g:loaded_vimballPlugin = 1
  g:loaded_netrw = 1
  g:loaded_netrwPlugin = 1
  g:loaded_netrwSettings = 1
  g:did_install_default_menus = 1
  g:did_install_syntax_menus = 1
  g:skip_loading_mswin = 1
  g:loaded_logiPat = 1

  &runtimepath ..= ',' .. escape(JoinPath($DOT_VIM, 'runtime'), ' \')
  &packpath = Stdpath.cache .. ',' .. &packpath

  # Set environmental variables on gVim.
  {
    var envrc = JoinPath(expand('~'), Rc('envrc'))
    if has('gui_running') && filereadable(envrc)
      var lines = readfile(envrc)
            ->map((_, val): string => substitute(val, '\v%(\_^|\s)#.*$', '', 'g'))
            ->filter((_, val): bool => !empty(val))

      for line in lines
        var name: string
        var value: string
        [name, value] = line->split('=')
        execute '$' .. name .. ' = ' .. value->expand()->string()
      endfor
    endif
  }
endif
# Initialize autocmd
{
  var filename = (expand('<sfile>'))
  var pattern = '^\s*aug\%[roup]\s\+\zs\S\+'
  var augroups = readfile(filename)
        ->filter((_, line): bool => stridx(line, 'aug') != -1)
        ->filter((_, line): bool => line =~# pattern)
        ->map((_, line): string => matchstr(line, pattern))
        ->filter((_, augroup): bool => augroup !=? 'END')
        ->sort()
        ->uniq()
  for group in augroups
    execute 'augroup' group
    autocmd!
  endfor
  augroup END
}

# minpac
export const PacPath = JoinPath(Stdpath.cache, 'pack', 'minpac', 'opt')

def ListInstalledPlugins(): dict<bool>
  var d: dict<bool> = {}
  const F = (e: dict<any>): number => {
    if e.type ==# 'dir'
      d[e.name] = true
    endif
    return 0
  }
  PacPath->readdirex(F, {sort: 'none'})
  return d
enddef

class Plugin
  # Treat plugins as not installed when 'loadplugins' option is off.
  static _installedPlugins: dict<bool> =
        \ &loadplugins ? ListInstalledPlugins() : {}

  this.name: string
  this.path: string
  this.uri: string
  this.config: dict<any>
  this.isLazy: bool
  this.isLocal: bool
  this.isExists: bool
  this.OnLoad: func(): void

  def new(name: string, uri: string, config: dict<any>, isLazy: bool)
    this.name = name
    this.path = JoinPath(Pacpack.pacPath, name)
    this.uri = uri
    this.isLazy = isLazy
    this.config = config
    this.isLocal = this.uri =~# '^file://'
    this.isExists = _installedPlugins->has_key(name)
    this.OnLoad = null_function
    if this.isLocal
      this.uri = this.uri[strlen('file://') :]
    endif
  enddef

  def SetHookOnLoad(F: func(): void)
    if !this.isLazy
      EchomsgError('HookOnLoad is only valid for lazy plugins: {this.name}')
    endif
    this.OnLoad = F
  enddef

  def InvokeHookOnLoad()
    if this.OnLoad != null_function
      call(this.OnLoad, [])
    endif
  enddef

  def IsLoaded(): bool
    const idx = &runtimepath->stridx(this.path)
    const ridx = idx + this.path->strlen()
    if idx == -1 ||
        !(idx == 0 || &runtimepath->strpart(idx - 1, 1) ==# ',') ||
        !(ridx == &runtimepath->strlen() || &runtimepath->strpart(ridx, 1) ==# ',')
      return false
    endif
    return true
  enddef
endclass

export class Pacpack
  static pacPath: string = PacPath
  static pluginList: dict<Plugin> = {}
  static plugin: Plugin  # Valid after calling Tap()

  static def _add(uri: string, config: dict<any>, isLazy: bool)
    const name = uri->matchstr('/\zs[^/]\+$')
    const p = Plugin.new(name, uri, config, isLazy)
    if pluginList->has_key(name)
      echoerr 'Duplicate plugin name:' name
    endif
    pluginList[name] = p
  enddef

  static def Add(uri: string, config: dict<any> = {})
    _add(uri, config, false)
  enddef

  static def AddLazy(uri: string, config: dict<any> = {})
    _add(uri, config, true)
  enddef

  # Override already tapped plugin.  E.g. use development version
  static def Override(target: string, uri: string, config: dict<any> = {})
    pluginList->remove(target)
    Add(uri, config)
  enddef

  static def LoadNonLazyPlugins()
    for p in values(pluginList)
      if !p.isLazy && p.isExists
        execute 'packadd!' p.name
      endif
    endfor
    syntax on
    filetype plugin indent on
  enddef

  # Load a plugin.  If the plugins is already loaded, this function does nothing.
  static def Load(name: string)
    const p: Plugin = pluginList->get(name, null_object)
    if p == null_object
      echoerr 'Plugin not found:' name
    elseif !p.IsLoaded()
      execute 'packadd' name
      p.InvokeHookOnLoad()
    endif
  enddef

  static def Tap(name: string): bool
    plugin = pluginList->get(name, null_object)
    return plugin != null_object && plugin.isExists
  enddef

  static def IsLoaded(name: string): bool
    const p: Plugin = pluginList->get(name, null_object)
    return p != null_object && p.IsLoaded()
  enddef

  static def GetPlugin(name: string): Plugin
    return pluginList->get(name, null_object)
  enddef

  # minpac integrations.
  static def _initMinpac(): bool
    var MinpacInit = () => minpac#init({
      progress_open: "tab",
      status_open: "vertical",
      status_auto: true
    })
    silent! packadd minpac
    silent! MinpacInit()
    if !exists('*minpac#init()')
      # Download minpac...
      const minpacPath = JoinPath(pacPath, 'minpac')
      Mkdir(fnamemodify(minpacPath, ':h'), 'p')
      Echomsg('Downloading minpac...')
      system('git clone https://github.com/k-takata/minpac ' .. minpacPath)

      silent! packadd minpac
      silent! MinpacInit()
      if !exists('*minpac#init()')
        return false
      endif
    endif

    for p in values(pluginList)
      if p.isLocal
        continue
      endif

      var config = p.config->copy()
      config.type = 'opt'
      minpac#add(p.uri, config)
    endfor

    return true
  enddef

  static def Update()
    if _initMinpac()
      const info = minpac#getpluginfo('vimdoc-ja')
      if !empty(info)
        system(printf('git -C %s reset --hard', shellescape(info.dir)))
      endif
      minpac#update()
    endif
  enddef

  static def Clean()
    if _initMinpac()
      minpac#clean()
    endif
  enddef

  static def Status()
    if exists('*minpac#status')
      minpac#status()
    else
      EchomsgError('minpac isn''t loaded yet.')
    endif
  enddef
endclass

command! -bar PackUpdate Pacpack.Update()
command! -bar PackClean  Pacpack.Clean()
command! -bar PackStatus Pacpack.Status()

Pacpack.AddLazy('k-takata/minpac')
Pacpack.Add('itchyny/vim-cursorword')
Pacpack.Add('itchyny/vim-qfedit')
Pacpack.Add('kamichidu/vim-textobj-function-go')
Pacpack.Add('kana/vim-altr')
Pacpack.Add('kana/vim-operator-user')
Pacpack.Add('kana/vim-textobj-user')
Pacpack.Add('lambdalisue/gina.vim')
Pacpack.Add('lambdalisue/vim-findent')
Pacpack.Add('lambdalisue/vim-gista')
Pacpack.Add('matze/vim-tex-fold')
Pacpack.Add('mityu/vim-alith')
Pacpack.Add('mityu/vim-cmdhistory')
Pacpack.Add('mityu/vim-gram')
Pacpack.Add('mityu/vim-gram-peripherals')
Pacpack.Add('mityu/vim-vim9context')
Pacpack.Add('mityu/vim-wispath')
Pacpack.Add('osyo-manga/vim-jplus')
Pacpack.Add('previm/previm')
Pacpack.Add('seroqn/foldmaker.vim')
Pacpack.Add('skanehira/gh.vim')
Pacpack.Add('thinca/vim-ambicmd')
Pacpack.Add('thinca/vim-ft-help_fold')
Pacpack.Add('thinca/vim-partedit')
Pacpack.Add('thinca/vim-prettyprint')
Pacpack.Add('thinca/vim-qfreplace')
Pacpack.Add('thinca/vim-quickrun')
Pacpack.Add('thinca/vim-themis')
Pacpack.Add('tikhomirov/vim-glsl')
Pacpack.Add('tyru/capture.vim')
# Pacpack.Add('tyru/eskk.vim')
Pacpack.Add('tyru/open-browser.vim')
Pacpack.Add('vim-jp/autofmt')
Pacpack.Add('vim-jp/vimdoc-ja')
Pacpack.Add('vim-jp/vital.vim')
Pacpack.Add('vim-scripts/autodate.vim')
Pacpack.Add('whonore/Coqtail')

Pacpack.AddLazy('lambdalisue/suda.vim')
Pacpack.AddLazy('mattn/vim-lsp-settings')
Pacpack.AddLazy('prabirshrestha/asyncomplete-lsp.vim')
Pacpack.AddLazy('prabirshrestha/asyncomplete.vim')
Pacpack.AddLazy('prabirshrestha/vim-lsp')
Pacpack.AddLazy('tweekmonster/helpful.vim')
Pacpack.AddLazy('y0za/vim-reading-vimrc')

# Operator-user plugins
Pacpack.AddLazy('kana/vim-operator-replace')
Pacpack.AddLazy('machakann/vim-sandwich')
Pacpack.AddLazy('osyo-manga/vim-operator-jump_side')
Pacpack.AddLazy('osyo-manga/vim-operator-swap')
# Pacpack.AddLazy('tyru/caw.vim')
Pacpack.AddLazy('mityu/caw.vim', {branch: 'support-vim9script-tmp'})  # tmp
Pacpack.AddLazy('sgur/vim-operator-openbrowser')

# Textobj-user plugins
Pacpack.AddLazy('kana/vim-textobj-entire')
Pacpack.AddLazy('kana/vim-textobj-function')
Pacpack.AddLazy('kana/vim-textobj-indent')
Pacpack.AddLazy('kana/vim-textobj-line')
Pacpack.AddLazy('mityu/vim-textobj-commentblock')
Pacpack.AddLazy('thinca/vim-textobj-between')

# Options {{{
if !exists('g:colors_name')  # Don't override colorscheme
  colorscheme domusaurea
endif
try
  language en_US.UTF-8
catch /^Vim\%((\a\+)\)\=:E197:/
  language C
catch
  EchomsgError(v:throwpoint)
  EchomsgError(v:exception)
  language C
endtry
set relativenumber number
set wrap
set smartindent autoindent
set cinoptions=:0,g0,N-s,E-s
set backspace=eol,start,indent
set pumheight=10
set completeopt=menuone,noselect
set noequalalways
set scrolloff=1 splitkeep=screen
set colorcolumn=78
set tabstop=4
set shiftwidth=4
set expandtab
set smarttab
set softtabstop=4
set hlsearch
set display=lastline
set listchars=tab:\|-
set autoread
set incsearch ignorecase
set showmatch matchtime=1
set cursorline cursorlineopt=number
set laststatus=2
set showtabline=2
set cmdheight=2 cmdwinheight=10
set wildmenu
set wildoptions=pum,fuzzy
set wildignore& wildignore+=*.DS_STORE
set history=500
set keywordprg=:help
set shortmess& shortmess+=Ic
set helplang=ja
set hidden
set diffopt=internal,algorithm:histogram
set fileformat=unix
#set breakindent
#set virtualedit& virtualedit+=block
set virtualedit=block
set complete=.,i,d,w,b,u
set noimdisable
set lazyredraw
# set previewpopup=highlight:Normal
set termwinkey=<C-w>
set noesckeys
set nowrapscan
set timeoutlen=3000 ttimeoutlen=100
set isfname-==
set spelllang& spelllang+=cjk
# }}}

Mkdir(Stdpath.cache, 'p')

{
  final undodir = JoinPath(Stdpath.cache, 'undo')
  if Mkdir(undodir, 'p')
    set undofile
    &undodir = undodir
  else
    set noundofile
  endif

  final swapdir = JoinPath(Stdpath.cache, 'swap')
  if Mkdir(swapdir, 'p')
    set swapfile
    &directory = JoinPath(fnamemodify(swapdir, ':p'), '')
  else
    set noswapfile
  endif

  final backupdir = JoinPath(Stdpath.cache, 'backup')
  if Mkdir(backupdir, 'p')
    set backup writebackup
    &backupdir = backupdir
  else
    set nobackup nowritebackup
  endif
}

# IM control
if !has('gui_running')
  if IsWSL || IsWindows || IsWinUnix
    const exepath = JoinPath(Stdpath.cache, 'disableim.exe')
    if !executable(exepath)  # Build disableim.exe
      var csc = 'C:\Windows\Microsoft.Net\Framework64\v4.0.30319\csc.exe'
      var srcpath = JoinPath(fnamemodify($MYVIMRC, ':h'), 'misc', 'disableim.cs')
      var outpath = $'{shellescape(exepath)}'  # Check with Unix path, compile with Windows path.
      var cmdopts = ['/optimize+', '/debug-', '/nologo', '/target:winexe']
      if IsWSL
        csc = $'$(wslpath -u {shellescape(csc)})'
        srcpath = $'$(wslpath -w {shellescape(srcpath)})'
        cmdopts->add('/utf8output')
      elseif IsWinUnix
        csc = string(csc)
        srcpath = $'$(cygpath -w {shellescape(srcpath)})'
        outpath = $'$(cygpath -w {shellescape(exepath)})'
      else
        srcpath = shellescape(srcpath)
      endif
      var cmd = join([csc] + cmdopts + [$'/out:{outpath}', srcpath])
      if IsWinUnix
        # Do not let MSYS2 to convert option argument (e.g. /nologo) into
        # Windows style path (e.g. C:\msys64\nologo)
        cmd = $'MSYS_NO_PATHCONV=1 MSYS2_ARG_CONV_EXCL="*" {cmd}'
      endif
      Echomsg('Building disableim.exe...')
      Echomsg(cmd)
      var output = system(cmd)
      if v:shell_error != 0
        EchomsgError('Compilation failed')
        EchomsgError(output)
      elseif IsWSL
        output = system($'chmod u+x {shellescape(exepath)}')
        if v:shell_error != 0
          EchomsgError('chmod failed')
          EchomsgError(output)
        endif
      endif
    endif
    if executable(exepath)
      augroup vimrc-auto-disableim
        execute $'autocmd InsertLeave * system({string(shellescape(exepath))})'
      augroup END
    endif
  endif
endif
if IsLinux && executable('fcitx5-remote') == 1
  augroup vimrc-auto-disableim
    autocmd InsertLeave * system('fcitx5-remote -c')
  augroup END
endif


if has('kaoriya')
  set fileencodings=guess,utf-8
  set ambiwidth=auto
else
  set fileencodings=utf-8,euc-jp,cp932,sjis
  set ambiwidth=single
endif
if IsUnix
  set path& path+=/usr/local/include
endif
if executable('rg')
  &grepprg = 'rg --vimgrep'
  &grepformat = '%f:%l:%c:%m'
elseif executable('ag')
  &grepprg = 'ag --vimgrep'
  &grepformat = '%f:%l:%c:%m'
endif
augroup vimrc_filetype
  autocmd BufRead .envrc set filetype=sh
augroup END
augroup vimrc_mru
  autocmd BufRead,BufWritePost * call vimrc#mru#onReadFile()
augroup END
augroup vimrc_checktime
  autocmd CursorHold * if getcmdwintype() ==# '' | checktime | endif
augroup END
if executable('chmod')
  # This hack is from github.com/thinca/config/dotfiles/dot.vim/vimrc. Thanks!
  augroup vimrc_autoexecutable
    autocmd BufWritePost * AddPermissionX()
  augroup END

  def AddPermissionX()
    var file = expand('%:p')
    if stridx(getline(1), '#!') == 0 && !executable(file)
      silent! call system('chmod a+x ' .. shellescape(file))
    endif
  enddef
endif
# From: https://zenn.dev/vim_jp/articles/f02adb4f325e51   Thanks!
augroup vimrc_validate_filename
  autocmd BufWritePre * ValidateFilename(expand('<afile>:t'))
augroup END
def ValidateFilename(filename: string)
  const invalid_chars = '!&()[]{}<>^*=+:;''",`~?|'
  for char in invalid_chars
    if stridx(filename, char) >= 0
      throw 'Filename has invalid char: ' .. filename
    endif
  endfor

  const valid_pattern = '\.\?[[:alnum:]]\+$'
  if filename !~? valid_pattern
    throw 'Filename is invalid format: ' .. filename
  endif
enddef
augroup vimrc_quickfix_window
  autocmd QuickfixCmdPost [^l]* cwindow
  autocmd QuickfixCmdPost l* lwindow
augroup END

augroup vimrc_window
  autocmd VimResized * wincmd =
augroup END

# Mapping {{{
nnoremap : q:A
vnoremap : q:A
nnoremap <Space>: q:k
vnoremap <Space>: q:k
nnoremap / q/A
vnoremap / q/A
nnoremap <Space>/ q/k
vnoremap <Space>/ q/k
nnoremap ? q?A
vnoremap ? q?A
nnoremap <Space>? q?k
vnoremap <Space>? q?k
nnoremap <Space>; :
vnoremap <Space>; :
nmap ' :
vmap ' :

noremap - <C-x>
noremap + <C-a>
noremap ( [(
noremap ) ])
noremap j gj
noremap k gk
noremap gj j
noremap gk k

noremap <C-@> <ESC>
noremap! <C-@> <ESC>

nnoremap <expr> i getline('.') ==# '' && &l:modifiable ? "\"_S" : 'i'
nnoremap <expr> I getline('.') ==# '' && &l:modifiable ? "\"_S" : 'I'
nnoremap <expr> a getline('.') ==# '' && &l:modifiable ? "\"_S" : 'a'
nnoremap <expr> A getline('.') ==# '' && &l:modifiable ? "\"_S" : 'A'
nnoremap <CR> o<ESC>
nnoremap Y y$
nnoremap <C-h> <Cmd>nohlsearch<CR>
nnoremap <C-w>s <Cmd>belowright wincmd s<CR>
nnoremap <C-w><C-s> <Cmd>belowright wincmd s<CR>
nnoremap <C-w>v <Cmd>belowright wincmd v<CR>
nnoremap <C-w><C-v> <Cmd>belowright wincmd v<CR>
nnoremap <C-w>c <Cmd>belowright copen<CR>
nnoremap <C-w>t <Cmd>tabnew<CR>
nnoremap <C-w><C-t> <Cmd>tabnew<CR>
nnoremap <Space>th <Cmd>vertical terminal ++close<CR>
nnoremap <Space>tj <Cmd>belowright terminal ++close<CR>
nnoremap <Space>tk <Cmd>terminal ++close<CR>
nnoremap <Space>tl <Cmd>belowright vertical terminal ++close<CR>
nnoremap <Space>tt <Cmd>tab terminal ++close<CR>
nnoremap <Space>w <Cmd>update<CR>
nnoremap <Space>q <C-w>q
nnoremap ZZ <Nop>
nnoremap ZQ <Nop>
nnoremap Q <Nop>
nnoremap <C-k> 7gk
nnoremap <C-j> 7gj
# Avoid textobj-function calls appearing on command history
nnoremap <silent> . .
nnoremap * *N
nnoremap <expr> n 'Nn'[v:searchforward]
nnoremap <expr> N 'nN'[v:searchforward]

nnoremap m <Nop>
vnoremap m <Nop>

inoremap <C-m> <C-g>u<C-m>
inoremap <C-u> <C-g>u<C-u>
inoremap <C-j> <C-g>u<C-j>
inoremap <C-l> <C-x>
inoremap <C-l><C-n> <C-x><C-n><C-n>
inoremap <C-l><C-p> <C-x><C-p><C-p>
inoremap <silent> <C-j> <C-r>=vimrc#pinsnip#Expand()<CR>
# TODO: Check 'paste' value?
inoremap <C-r>* <Cmd>set paste<CR><C-r>*<Cmd>set nopaste<CR>
inoremap <C-r>+ <Cmd>set paste<CR><C-r>+<Cmd>set nopaste<CR>

vnoremap g+ g<C-a>
vnoremap g- g<C-x>
vnoremap <C-k> 7gk
vnoremap <C-j> 7gj
vnoremap * <ESC>*Ngvne<Cmd>nohlsearch<CR>
vnoremap g* <ESC>g*Ngvne<Cmd>nohlsearch<CR>
vnoremap n n<Cmd>nohlsearch<CR>
vnoremap N N<Cmd>nohlsearch<CR>

cnoremap <C-l> <C-f>
cnoremap <C-f> <Right>
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>
cnoremap <C-b> <Left>
cnoremap <C-a> <C-b>
cnoremap <C-[> <C-c>
cnoremap <C-o> <Cmd>call cmdhistory#Select()<CR>

nnoremap <C-w>, <Cmd>call <SID>ToggleQuickfix()<CR>
def ToggleQuickfix()
  const wincount = winnr('$')
  try
    cclose
    if wincount == winnr('$')
      cwindow
      if wincount == winnr('$')
        EchomsgError('No quickfix window')
      endif
    endif
  catch
    echo v:exception
  endtry
enddef

nnoremap <C-w>. <Cmd>call <SID>ToggleLocationlist()<CR>
def ToggleLocationlist()
  var wincount = winnr('$')
  try
    lclose
    if wincount == winnr('$')
      lwindow
    endif
  catch /^Vim(\S\{-})\:E776\:/
    echohl ErrorMsg
    echomsg matchstr(v:exception, '^Vim(\S\{-})\:\zs.*$')
    echohl NONE
  catch
    echoerr v:exception
  endtry
enddef
# }}}
tnoremap <C-w>: <C-w>:<C-f>A
tnoremap <C-w><Space>: <C-w>:<C-f>k
tnoremap <C-w>; <C-w>:
tnoremap <C-w><ESC> <C-w>N
tnoremap <C-w>p <C-w>""
tnoremap <C-w><C-r> <C-w>"
tnoremap <C-@> <ESC>
for c in 'tnsvq'
  execute $'tnoremap <C-w>{c} <C-w>.{c}'
endfor

if IsMac && has('gui_running')
  noremap <D-[> <ESC>
  noremap! <D-[> <ESC>
endif

# Loop
def LoopDefine(config: dict<any>)
  var prefix = printf('<Plug>(<SID>-loop-%s)', config.id)
  var enter_with = config.enter_with
  var mode = get(config, 'mode', 'n')
  var plug_map: dict<string>
  for key in ['prefix', 'main', 'do']
    plug_map[key] = printf('%s(%s)', prefix, key)
  endfor

  execute printf('%snoremap %s <Nop>', mode, plug_map.prefix)
  execute printf('%snoremap %s<ESC> <Nop>', mode, plug_map.prefix)
  for mapping in config.map
    var lhs: string
    var rhs: string
    var commands: list<list<string>>
    [lhs, rhs] =
        mapping->map((_, val): string => substitute(val, '|', '<bar>', 'g'))
    commands->add([mode .. 'noremap', enter_with .. lhs, plug_map.main .. lhs])
            ->add([mode .. 'noremap', plug_map.main .. lhs, rhs .. plug_map.prefix])
            ->add([mode .. 'noremap', plug_map.prefix .. lhs, plug_map.main .. lhs])
    execute commands->mapnew('join(v:val)')->join("\n")
  endfor

  if mode ==# 'n'
    var t_config = deepcopy(config)
    t_config.mode = 't'
    if t_config.enter_with[: strlen(&termwinkey)] !=# &termwinkey &&
        t_config.enter_with[0] !=# printf('"\%s"', &termwinkey)->eval()
      t_config.enter_with = &termwinkey .. config.enter_with
    endif
    t_config.map->map('LoopDefineGenerateTmap(v:val)')
    LoopDefine(t_config)
  endif
enddef

def LoopDefineGenerateTmap(value: list<string>): list<string>
  var rhs = value[1]
        ->substitute('\c<SID>', SIDPrefix(), 'g')
        ->substitute('\zs<\ze.\{-}>', '\\<lt>', 'g')
  rhs = '<Cmd>execute "normal! ' .. rhs .. '"<CR>'
  return [value[0], rhs]
enddef

def SimpleLoopDefine(config: dict<any>)
  var new_config = deepcopy(config)
  new_config.map = config.follow_key->split('\zs')
        ->mapnew((_, val): list<string> => [val, config.enter_with .. val])
  LoopDefine(new_config)
enddef

augroup vimrc_mapping
  autocmd User vimrc_initialize ++once DefineLoopMappings()
augroup END

def DefineLoopMappings()
  SimpleLoopDefine({
    id: 'Window',
    enter_with: '<C-w>',
    follow_key: '<>-+',
  })
  LoopDefine({
    id: 'Tab',
    enter_with: 'g',
    map: [
      ['h', 'gT'],
      ['l', 'gt'],
      ['T', '<Cmd>call <SID>MapTabmove(-1)<CR>'],
      ['t', '<Cmd>call <SID>MapTabmove(1)<CR>'],
    ]
  })
enddef

def MapTabmove(delta: number)
  var tab_count = tabpagenr('$')
  if tab_count == 1
    return
  endif
  const current = tabpagenr() - 1
  var move_to = current + delta
  if move_to < 0
    while move_to < 0
      move_to += tab_count
    endwhile
  endif
  if move_to >= tab_count
    move_to = move_to % tab_count
  endif
  const movement = move_to - current
  var movecmd = 'tabmove '
  if movement < 0
    movecmd ..= string(movement)
  else
    movecmd ..= '+' .. string(movement)
  endif
  execute movecmd
enddef

# f F t T ; , declarations {{{
map <expr> f vimrc#charjump#Jump(v:true, v:false)
map <expr> F vimrc#charjump#Jump(v:false, v:false)
map <expr> t vimrc#charjump#Jump(v:true, v:true)
map <expr> T vimrc#charjump#Jump(v:false, v:true)
noremap ; <Cmd>call vimrc#charjump#Repeat(v:false)<CR>
noremap , <Cmd>call vimrc#charjump#Repeat(v:true)<CR>
# }}}

def CmdwinEnter()
  # Type <CR> to execute current line in command-line window.
  # This mapping is overwritten when ambicmd.vim is installed.
  nnoremap <buffer> <CR> <CR>

  # Return back to the current window from command-line window with
  # inputting <C-c> once.
  nnoremap <buffer> <C-c> <Cmd>quit<CR>
  nnoremap <buffer> q <Cmd>quit<CR>
  inoremap <buffer> <C-c> <ESC><Cmd>quit<CR>

  inoremap <buffer> <C-l><C-n> <C-x><C-n>
  inoremap <buffer> <C-l><C-p> <C-x><C-n>

  # Make executing a previous command easier.
  if Pacpack.Tap('vim-cmdhistory')
    nnoremap <buffer> / <Cmd>call cmdhistory#Select()<CR>
  endif
  vimrc#incsearch#Setup()

  const cmdwin_type = expand('<afile>')
  if cmdwin_type ==# ':'
    inoremap <expr> <buffer> <C-p> <SID>CmdwinCompletion(0)
    inoremap <expr> <buffer> <C-n> <SID>CmdwinCompletion(1)
    b:completeopt_save = &completeopt
    setlocal completeopt=menu,preview
    if line('$') >= &cmdwinheight
      execute printf(':silent! :1,$-%d delete _', &cmdwinheight)
      normal! G
      &undolevels = &undolevels  # Separate undo sequence
    endif
    if exists('g:asyncomplete_loaded') && g:asyncomplete_loaded
      asyncomplete#disable_for_buffer()
    endif
  endif
enddef
def CmdwinLeave()
  if exists('b:completeopt_save')
    &completeopt = b:completeopt_save
  endif
enddef
def CmdwinCompletion(select_next: bool): string
  if pumvisible()
    return select_next ? "\<C-n>" : "\<C-p>"
  else
      return "\<C-x>\<C-v>" .. (select_next ? "" : "\<C-p>\<C-p>")
  endif
enddef

augroup vimrc_mapping
  autocmd CmdWinEnter * call CmdwinEnter()
  autocmd CmdWinLeave * call CmdwinLeave()
augroup END

if IsMac
  g:mapleader = '_'
endif

# Mapping for commands
{
  var map: list<list<string>>
  add(map, ['nnoremap', 'ev', 'edit $MYVIMRC'])
  add(map, ['nnoremap', 'sv', 'source $MYVIMRC'])
  add(map, ['nnoremap', 'j', 'call <SID>GofForMapping()'])
  add(map, ['nnoremap', 'f', 'call vimrc#filore#start()'])
  execute map->mapnew((_, val: list<string>): string => $'{val[0]} <Space>{val[1]} <Cmd>{val[2]}<CR>')->join("\n")
}

# Abbreviates
inoreabbrev todo: TODO:
inoreabbrev fixme: FIXME:
inoreabbrev xxx: XXX:
inoreabbrev note: NOTE:

# Commands
# Declarations
command! -bar CdCurrent cd %:p:h
command! -bar LcdCurrent lcd %:p:h
command! -bar TcdCurrent tcd %:p:h
command! -bar FileName echo expand('%:p')
command! -nargs=1 -complete=file Rename file <args>|call delete(expand('#'))
command! -nargs=? CopyToClipboard call setreg('+', getreg(<q-args>, 1))
command! -bar -nargs=? ClipBuffer call vimrc#Clipbuffer(<q-args>)
command! ClearMessage messages clear
command! -bang -nargs=+ -complete=command Filter call Filter(<bang>0, <f-args>)
command! -bar Draft setlocal buftype=nofile noswapfile noundofile
command! -bar -nargs=+ -complete=command Vimrc <args> $MYVIMRC
command! -bar -nargs=* -complete=file ListTasks call vimrc#ListTasks(<q-args>)
command! DeleteUndoFiles call vimrc#DeleteUndofiles()
command! -nargs=? -complete=dir Gof call Gof(<q-args>)
command! -bar SwapBackslashAndBar call SwapBackslashAndBar()
command! -bar -nargs=? -complete=dir GitInitRepo call vimrc#GitInitRepo(<q-args>)
command! -bar LocalPackUpdate call vimrc#UpdateLocalPackages()
command! -nargs=+ -complete=shellcmd Man delcommand Man|runtime ftplugin/man.vim|Man <args>
command! -nargs=? -complete=filetype TMP enew|Draft|execute (<q-args> ==# '' ? '' : 'setfiletype <args>')
{
  var cmd: string
  if IsMac && executable('open')
    cmd = 'open'
  elseif (IsWindows || IsWSL || IsWinUnix) && executable('explorer')
    cmd = 'explorer'
  endif
  if cmd !=# ''
    execute 'command! -bar -nargs=+ -complete=dir Open ' ..
      $'call system("{cmd} " .. shellescape(<q-args>))'
  endif
}

# Thanks to cohama
command! EditAsUtf8 edit ++enc=utf-8 %
command! EditAsCp932 edit ++enc=cp932 %
command! EditAsUnix edit ++ff=unix %
command! EditAsDos edit ++ff=dos %
command! WriteAsUtf8 set fenc=utf-8|w

# Plugin Shortcuts
command! -bar -nargs=* MruEditHistoryStart call vimrc#mru#edit_history_start(<q-args>)
command! -bar MruDeleteUnexistHistory call vimrc#mru#delete_unexist_file_history()
command! -bar -nargs=? -complete=dir Filore call vimrc#filore#start(<q-args>)
command! -bar -bang -nargs=? -complete=dir Ls call vimrc#shcmd#ls(<bang>0, <f-args>)
command! -bar -bang -nargs=+ -complete=dir Mkdir call vimrc#shcmd#mkdir(<bang>0, <f-args>)
command! -bar -nargs=+ -complete=dir Touch call vimrc#shcmd#touch(<f-args>)
command! -bar -nargs=+ -complete=dir CpFile call vimrc#shcmd#cpfile(<f-args>)
command! -bar -bang -nargs=+ -complete=file Rm call vimrc#shcmd#rm(<bang>0, <f-args>)

def Filter(bang: bool, pat: string, ...cmd: list<string>)
  const output = execute(join(cmd, ' '))
                ->split("\n")
                ->filter((_: number, val: string): bool => val =~? pat)
                ->join("\n")
  if bang
    echomsg output
  else
    echo output
  endif
enddef

def FindGitroot(arg_target: string = bufname('%')): string
  const target: string = resolve(arg_target)
  const git_dir: string = finddir('.git', target .. ';')
  if git_dir ==# ''
    EchomsgWarning('Not a git repository: ' .. target)
    return ''
  endif
  return fnamemodify(git_dir, ':p:h:h')
enddef

def Gof(path: string)
  if !executable('gof')
    echo '"gof" command not found.'
    return
  endif
  var gofcmd = 'gof -f -tf "Tapi_gof"'
  if !empty(path)
    gofcmd ..= ' -d ' .. path
  endif
  var minwidth = min([&columns, 100])
  var minheight = min([&lines, 40])
  popup_create(term_start(gofcmd, {hidden: 1, term_finish: 'close'}),
        \ {minwidth: minwidth, minheight: minheight})
enddef

def GofForMapping()
  var git_root = FindGitroot()
  Gof(git_root ==# '' ? getcwd(winnr()) : git_root)
enddef

legacy def! Tapi_gof(bufnum: number, file_info: dict<string>)  # Be global
  var winid = win_getid(winnr('#'))
  var buftype = getwinvar(winid, '&buftype')
  var open_cmd = 'edit'
  if !(buftype ==# 'nofile' || buftype ==# '')
    open_cmd = 'split'
  endif
  win_execute(winid, open_cmd .. ' ' .. fnameescape(file_info.fullpath))
enddef

def SwapBackslashAndBar()
  if maparg('\', 'i') ==# "\<Nop>"
    inoremap \ _
    inoremap _ \
  else
    iunmap \
    iunmap _
  endif
enddef

# Installed plugins
if Pacpack.Tap('vim-cursorword')
  g:cursorword_highlight = 0
  augroup vimrc_cursorword
    autocmd ColorScheme * highlight CursorWord gui=underline cterm=underline term=underline guibg=NONE ctermbg=NONE
  augroup END
  doautocmd vimrc_cursorword ColorScheme
endif
if Pacpack.Tap('vim-altr')
  command! -bar AlterForward call altr#forward()
  command! -bar AlterBack call altr#back()
endif
if Pacpack.Tap('gina.vim')
  g:gina#action#mark_sign_text = '*'
  g:gina#core#console#enable_message_history = 1

  def GinaConfig()
    def Gina_nnoremap(scheme: string, lhs: string, rhs: string)
      gina#custom#mapping#nmap(scheme, lhs, rhs, {noremap: 1, silent: 1})

      # Set mapping manually for the first time.
      # TODO: More smart solution
      if HasInString(&filetype, scheme)
        execute 'nnoremap <buffer> <silent>' lhs rhs
      endif
    enddef

    Gina_nnoremap('status', '<C-]>', '<Cmd>Gina commit<CR>')
    Gina_nnoremap('commit', '<C-]>', '<Cmd>Gina status<CR>')
    Gina_nnoremap('status', '<Space>g', '<Cmd>Gina commit<CR>')
    Gina_nnoremap('commit', '<Space>g', '<Cmd>Gina status<CR>')
    Gina_nnoremap('status', '<C-l>', '<Cmd>Gina status<CR>')
    Gina_nnoremap('log', '<C-l>', '<Cmd>Gina log<CR>')
    Gina_nnoremap('branch', 'N',
            '<Cmd>call gina#action#call("branch:new")<CR>')
    Gina_nnoremap('/\v%(status|branch|log)', 'q', '<Cmd>close<CR>')

    # Jump between unadded files with n/p ..
    var rhs_base = printf(
            '<Cmd>call %sGinaStatusSelectAnother(v:count1, %%s)<CR>',
            SIDPrefix())
    Gina_nnoremap('status', 'n', printf(rhs_base, 'v:false'))
    Gina_nnoremap('status', 'N', printf(rhs_base, 'v:true'))
    # NOTE: Using v:true and v:false as variables above doesn't work because
    # it seems to be changed into 'false' and 'true' (without v: namespace).

    Gina_nnoremap('status', 'dd',
           printf('<Cmd>call %sGinaDiff()<CR>', SIDPrefix()))

    gina#custom#action#alias('branch', 'merge', 'commit:merge:no-ff')
    gina#custom#action#alias('branch', 'merge-ff', 'commit:merge:ff')

    gina#custom#command#option('\v%(^<%(cd|lcd|qrep)>)@<!$', '--opener=edit')
  enddef

  def GinaStatusSelectAnother(repeat_count: number, search_previous: bool)
    var flags = 'w'
    flags ..= search_previous ? 'b' : ''
    for i in range(1, repeat_count)
      search('\e[31.\+\e[m', flags)
    endfor
  enddef

  def GinaDiff()
    var filename = matchstr(getline('.'), '\e[31m\zs.\+\ze\e[m')
    filename = matchstr(filename, '\%(\_^modified\:\s\+\)\?\zs.\+')
    if filename ==# ''
      return
    endif
    const gitroot = fnamemodify(gina#core#get().repository, ':h')
    const cmd = $'git -C {gitroot} --no-pager diff --no-color {filename}'
    const bufnr = term_start(cmd, {
            term_name: '[gina diff] ' .. filename,
            norestore: 1,
            })
    if bufnr != 0
      setlocal nocursorline nocursorcolumn filetype=diff
      nnoremap <buffer> <nowait> q <C-w>q
      cursor(1, 0)
    endif
  enddef

  augroup vimrc_gina
    autocmd Filetype gina-* ++once GinaConfig()
  augroup END
  nnoremap <Space>g <Cmd>Gina status<CR>
endif
if Pacpack.Tap('vim-findent')
  augroup vimrc_findent
    autocmd FileType * if &l:modifiable | execute 'Findent' | endif
  augroup END
endif
if Pacpack.Tap('vim-alith')
  augroup vimrc_alith
    autocmd ColorScheme * highlight AlithMatchHead gui=reverse cterm=reverse term=reverse
  augroup END
  highlight AlithMatchHead gui=reverse cterm=reverse term=reverse
endif
if Pacpack.Tap('vim-cmdhistory')
  augroup vimrc-cmdhistory
    autocmd User cmdhistory-initialize SetupCmdhistory()
  augroup END
  def SetupCmdhistory()
    cmdhistory#SetDefaultMappings()
    cmdhistory#MapAction('<ESC>', ['no-operation'])
    cmdhistory#MapAction('<C-@>', ['no-operation'])
  enddef
endif
if Pacpack.Tap('vim-brownie')
  g:brownie_template_dirs =
        [JoinPath(expand('$DOT_VIM'), 'runtime', 'extension', 'brownie')]
  g:brownie_extra_imports = {
    cpp: ['c'],
    vimspec: ['vim'],
  }

  def BrownieFiletype(): string
    return getbufvar(brownie#get_current_bufnr(), '&filetype')
  enddef
  def VimrcTemplateComplete(arg: string, line: string, pos: number): list<string>
    return filter(brownie#list(BrownieFiletype(), 'template'),
                (_, val) => stridx(val, arg) == 0)
  enddef

  command! -nargs=1 -complete=customlist,VimrcTemplateComplete Template
        \ call brownie#extract(BrownieFiletype(), 'template', <q-args>)
endif
if Pacpack.Tap('vim-gram')
  augroup vimrc_gram_init
    autocmd User gram-initialize ++once InitGram()
  augroup END

  def InitGram()
    gram#custom#map_action('normal', 'i', 'switch-to-insert')
    gram#custom#map_action('normal', 'q', 'quit')
    gram#custom#map_action('normal', 'k', 'select-prev-item')
    gram#custom#map_action('normal', 'j', 'select-next-item')
    gram#custom#map_action('normal', '<CR>', 'do-default-item-action')
    gram#custom#map_action('normal', 'p', 'request-preview')
    gram#custom#map_keys('normal', '<NL>', '<CR>')

    gram#custom#map_action('insert', '<ESC>', 'switch-to-normal')
    gram#custom#map_action('insert', '<C-@>', 'switch-to-normal')
    gram#custom#map_action('insert', '<CR>', 'switch-to-normal')
    gram#custom#map_action('insert', '<C-h>', 'delete-character')
    gram#custom#map_action('insert', '<BS>', 'delete-character')
    gram#custom#map_action('insert', '<Del>', 'delete-character')
    gram#custom#map_action('insert', '<C-u>', 'clear-line')
    gram#custom#map_action('insert', '<C-f>', 'move-forward')
    gram#custom#map_action('insert', '<C-b>', 'move-backward')
    gram#custom#map_action('insert', '<C-j>', 'select-next-item')
    gram#custom#map_action('insert', '<C-k>', 'select-prev-item')
    gram#custom#map_action('insert', '<C-n>', 'select-next-item')
    gram#custom#map_action('insert', '<C-p>', 'select-prev-item')
    gram#custom#map_keys('insert', '<C-y>', '<CR><CR>')

    gram#option#set_global('UI', 'popup')
    gram#option#set_global('UI_options', {enable_preview: 1, prompt_text: '>> '})
    gram#option#set_global('matcher', 'regexp')
    gram#option#set_global('preview', 'manual')
    # gram#option#set_global('preview_delay', 1000)
    gram#option#set_for_source('mru', 'kinds', ['file'])
    gram#option#set_for_source('file_rec', 'kinds', ['file'])
    gram#option#set_for_source('gitfiles', 'kinds', ['file'])
    gram#option#set_for_source('buffers', 'kinds', ['buffer'])
    gram#option#set_for_source('terminals', 'kinds', ['buffer'])

    vimrc#mru#register_source()  # TODO: workaround.
  enddef

  if IsWindows
    nnoremap <Space>k <Cmd>call gram#core#setup(#{sources: [#{name: 'mru', default_action: 'file:edit'}]})<CR>
  else
    nnoremap <Space>k <Cmd>call gram#core#setup(#{sources: [#{name: 'mru', default_action: 'file:edit'}, #{name: 'gitfiles', default_action: 'file:edit'}]})<CR>
  endif

  if Pacpack.Tap('vim-gram-sources')
    nnoremap <Space>b <Cmd>call gram#sources#buffers#launch()<CR>
    command! -nargs=? -complete=dir Files call gram#sources#file_rec#launch(<q-args>)
  endif

  if Pacpack.Tap('vim-gram-peripherals')
    nnoremap <Space>j <Cmd>call gram#core#setup(#{sources: [#{name: 'file_rec', default_action: 'file:edit'}]})<CR>
    nnoremap <Space>b <Cmd>call gram#core#setup(#{sources: [#{name: 'buffers', default_action: 'buffer:edit'}]})<CR>
    nnoremap <Space>tb <Cmd>call gram#core#setup(#{sources: [#{name: 'terminals', default_action: 'buffer:edit'}]})<CR>
  endif
endif
if Pacpack.Tap('vim-wispath')
  imap <C-l><C-f> <Plug>(wispath-complete)
endif
if Pacpack.Tap('vim-jplus')
  map J <Plug>(jplus)
endif
if Pacpack.Tap('previm')
  g:previm_show_header = 0
  g:previm_enable_realtime = 1
  if IsWSL
    g:previm_open_cmd = '/mnt/c/Program Files/Google/Chrome/Application/chrome.exe'
  endif
endif
if Pacpack.Tap('vim-ambicmd')
  def AmbicmdExpand(key: string): string
    var expander = ambicmd#expand(key)
    return (expander ==# key ? '' : "\<C-g>u") .. expander
  enddef
  augroup vimrc_ambicmd
    autocmd CmdWinEnter : call SetupAmbicmdForCmdwin()
  augroup END
  cnoremap <expr> <Space> ambicmd#expand("\<Space>")
  cnoremap <expr> <CR> ambicmd#expand("\<CR>")
  cnoremap <expr> <bar> ambicmd#expand("\<bar>")

  def SetupAmbicmdForCmdwin()
    inoremap <buffer> <expr> <Space> <SID>AmbicmdExpand("\<Space>")
    inoremap <buffer> <expr> <bar> <SID>AmbicmdExpand("\<bar>")
    inoremap <buffer> <expr> <CR> <SID>AmbicmdExpand("\<CR>")
    inoremap <buffer> <expr> <C-j> <SID>AmbicmdExpand('')
  enddef

  g:ambicmd#show_completion_menu = 1

  def AmbicmdBuildRule(cmd: string): list<string>
    var rule = []
    rule += ['\c^' .. cmd .. '$']
    rule += ['\c^' .. cmd]

    for len in range(1, strlen(cmd))
      var prefix = strpart(cmd, 0, len)->toupper()->substitute('.\zs', '.\\{-}', 'g')
      var suffix = cmd[len :]
      var matcher = '\C^' .. prefix .. suffix
      rule += [matcher .. '$', matcher]
    endfor

    rule += ['\c' .. cmd]
    rule += ['.\\{-}' .. substitute(cmd, '.\zs', '.\\{-}', 'g')]
    return rule
  enddef
  g:ambicmd#build_rule = AmbicmdBuildRule
endif
if Pacpack.Tap('vim-quickrun')
  g:quickrun_config = {}
  g:quickrun_config['_'] = {
    ['outputter']: 'multi',
    ['outputter/multi/targets']: ['buffer', 'error'],
    ['outputter/error/success']: 'buffer',
    ['outputter/error/error']: 'quickfix',
    ['outputter/buffer/close_on_empty']: 1,
    runner: 'job',
  }

  g:quickrun_config.cpp = {
    cmdopt: '-std=c++20'
  }
  g:quickrun_config['cpp/sfml'] = {
    type: 'cpp',
    cmdopt: '-std=c++20 -lsfml-audio -lsfml-graphics -lsfml-network -lsfml-system -lsfml-window',
  }
  g:quickrun_config.go = {
    command: 'go',
    cmdopt: '-mod=mod',
    exec: '%c run %s:p:t %a',
    tempfile: '%{tempname()}.go',
    ['hook/cd/directory']: '%S:p:h',
    ['hook/output_encode/encoding']: 'utf-8',
  }
  g:quickrun_config['go/full'] = {
    command: 'go',
    cmdopt: '-mod=mod',
    exec: ['%c mod init quickrun%s:p:t:r', '%c mod tidy', '%c run %s:p:t %a'],
    tempfile: '%{tempname()}.go',
    ['hook/cd/directory']: '%S:p:h',
    ['hook/sweep/files']: ['%S:p:h/go.mod', '%S:p:h/go.sum'],
    ['hook/output_encode/encoding']: 'utf-8',
  }
  g:quickrun_config.objc = {
    command: 'cc',
    execute: ['%c %s -o %s:p:r -framework Foundation', '%s:p:r %a', 'rm -f %s:p:r'],
    tempfile: '%{tempname()}.m',
  }
  g:quickrun_config.applescript = {
    command: 'osascript',
    execute: '%c %s:p',
    tempfile: '%{tempname()}.applescript',
  }
  g:quickrun_config.python = {
    command: 'python3',
    ['hook/eval/template']: 'print(%s)'
  }

  if executable('deno')
    # If deno doesn't exist, use quickrun's default config. It has configs for
    # other typescript runners.
    # To use deno without type checking, do :Quickrun typescript/deno.
    g:quickrun_config.typescript = {
      type: 'typescript/deno-check'
    }

    g:quickrun_config['typescript/deno-check'] = {
      command: 'deno',
      cmdopt: '--check --allow-all --unstable',
      tempfile: '%{tempname()}.ts',
      exec: ['%c run %o %s'],
    }
  endif

  g:quickrun_config.tex = {
    type: 'tex/platex'
  }

  {
    var opencmd: string
    if IsWindows
      opencmd = 'explorer'
    elseif IsMac
      opencmd = 'open'
    else
      opencmd = 'xdg-open'
    endif
    var openpdfcmd = printf('%s %%s:p:r.pdf', opencmd)

    var sweepfiles: list<string> =
      ['.aux', '.log', '.dvi', '.out', '.pdf']
      ->map((_: number, v: string): string => '%S:p:r' .. v)

    g:quickrun_config['tex/platex'] = {
      command: 'platex',
      exec: ['%c %a %s', 'dvipdfmx %s:p:r.dvi', openpdfcmd],
      tempfile: '%{tempname()}.tex',
      ['hook/sweep/files']: sweepfiles,
      ['hook/cd/directory']: '%S:p:h',
    }
  }

  if IsWSL
    g:quickrun_config.dosbatch = {
      command: 'cmd.exe',
      exec: '%c /Q /c \$(wslpath -w %s) %a'
    }
  endif

  nnoremap <expr> <C-c> quickrun#session#exists() ?
        \ '<Cmd>call quickrun#session#sweep()<CR>' :
        \ '<C-c>'
  nmap <Space>r <Plug>(quickrun)
  vmap <Space>r <Plug>(quickrun)

  augroup vimrc_quickrun
    autocmd SourcePost */autoload/quickrun.vim ++once
    \ call quickrun#module#register({
    \   kind: 'hook',
    \   name: 'vimrc_autoclose_quickfix',
    \   on_success: (_, _) => execute('cclose')
    \ }, true)
    autocmd FileType quickrun nnoremap <buffer> q <C-w>q
    autocmd CmdwinEnter *
    \ noremap <buffer> <Plug>(quickrun) <Cmd>echo ':QuickRun is disabled in cmdwin.'<CR>
    autocmd FileType quickrun {
      matchadd('Conceal', '\e[\d\+m', 10, -1, {conceal: ''})
      setlocal conceallevel=3 concealcursor=nvic
    }
  augroup END
endif
if Pacpack.Tap('capture.vim')
  augroup vimrc_filetype
    autocmd Filetype capture nnoremap <buffer> q <C-w>q
  augroup END
endif
if Pacpack.Tap('open-browser.vim') && !v:vim_did_enter
  augroup vimrc_openbrowser
    autocmd SourcePost */plugin/openbrowser.vim
          \ command! -nargs=* OpenBrowser call OpenBrowser(<q-args>)
  augroup END

  # :OpenBrowser         => Read URL from the default register
  # :OpenBrowser @*      => Read URL from the specified register
  # :OpenBrowser {URL}   => Just use {URL}
  def OpenBrowser(cmdarg: string)
    var uri = trim(cmdarg)
    var reg = ''
    if uri ==# ''
      reg = v:register
    elseif uri[0] ==# '@' && strlen(uri) == 2
      reg = uri[1]
    endif
    if reg !=# ''
      uri = getreg(reg)
      if uri ==# ''
        EchomsgError(printf('Register @%s is empty.', reg))
        return
      endif
    endif
    openbrowser#open(uri)
  enddef
endif
if Pacpack.Tap('autofmt')
  set formatexpr=autofmt#japanese#formatexpr()
endif
if Pacpack.Tap('asyncomplete.vim')
  def AsyncompletePreprocessor(context: dict<any>, matches_dict: dict<any>)
    var base = tolower(context.base)
    var completions: list<dict<any>>
    var subcompletions: list<dict<any>>
    var fuzzycompletions: list<dict<any>>

    if trim(context.base) !=# ''
      for matches in values(matches_dict)
        for candidate in matches.items
          var idx = stridx(tolower(candidate.word), base)
          if idx == -1
            continue
          elseif idx == 0
            add(completions, candidate)
          else
            add(subcompletions, candidate)
          endif
        endfor
      endfor
    endif
    completions += subcompletions

    if !empty(completions)
      asyncomplete#preprocess_complete(context, completions)
      return
    endif

    # Workaround; matchfuzzy() always returns list<string>
    var items: list<any> =
          matches_dict->values()->mapnew((_, val): list<any> => val.items)->flattennew()

    if trim(context.base) !=# ''
      items = matchfuzzy(items, context.base, {key: 'word'})
    endif
    asyncomplete#preprocess_complete(context, items)
  enddef

  g:asyncomplete_auto_popup = 1
  g:asyncomplete_preprocessor = [AsyncompletePreprocessor]
  g:asyncomplete_auto_completeopt = 0
endif
if Pacpack.Tap('vim-lsp')
  # Lazy-loading
  augroup vimrc_lsp_lazyload
    autocmd BufReadPre * LoadLspPlugins()
    autocmd BufNewFile * {
      LoadLspPlugins()
      doautocmd lsp BufNewFile
    }
    if !v:vim_did_enter
      autocmd VimEnter * {
        # Do not load lsp plugins on git commit
        if argc() != 0 && argv()[0] !~# '\<COMMIT_EDITMSG\>$'
          LoadLspPlugins()
          doautocmd lsp BufReadPost
        endif
      }
    endif
  augroup END

  def LoadLspPlugins()
    # Load completion plugin first.
    if Pacpack.Tap('asyncomplete.vim')
      # asyncomplete-lsp.vim must be loaded before asyncomplete.vim
      if Pacpack.Tap('asyncomplete-lsp.vim')
        Pacpack.Load('asyncomplete-lsp.vim')
      endif
      packadd asyncomplete.vim
    endif

    # vim-lsp-settings must be loaded before vim-lsp
    if Pacpack.Tap('vim-lsp-settings')
      packadd vim-lsp-settings
    endif
    packadd vim-lsp

    # Plugin initializations
    inoremap <expr> <C-n>
          \ pumvisible() ? "\<C-n>" : asyncomplete#close_popup() .. "\<C-n>"
    inoremap <expr> <C-p>
          \ pumvisible() ? "\<C-p>" : asyncomplete#close_popup() .. "\<C-p>"
    inoremap <expr> <C-e> pumvisible() ? asyncomplete#cancel_popup() : "\<C-e>"
    lsp#enable()

    autocmd! vimrc_lsp_lazyload
    command! -bar LoadLspPlugins {
      echohl WarningMsg
      echo 'Lsp plugins are already loaded'
      echohl NONE
    }
  enddef
  command! -bar LoadLspPlugins LoadLspPlugins()|echo 'Loaded lsp plugins'


  g:lsp_use_native_client = 1
  g:lsp_insert_text_enabled = 0
  g:lsp_completion_documentation_delay = 0
  g:lsp_diagnostics_enabled = 1
  g:lsp_diagnostics_signs_enabled = 1
  g:lsp_diagnostics_signs_error = {text: '>>'}
  g:lsp_diagnostics_signs_warning = {text: '--'}
  g:lsp_diagnostics_signs_information = {text: '--'}
  g:lsp_diagnostics_signs_hint = {text: '!?'}
  g:lsp_diagnostics_delay_hint = 0
  g:lsp_diagnostics_float_cursor = 1
  g:lsp_diagnostics_float_delay = 0
  g:lsp_diagnostics_highlights_delay = 0
  g:lsp_diagnostics_virtual_text_delay = 0
  g:lsp_diagnostics_virtual_text_padding_left = 0
  g:lsp_diagnostics_virtual_text_align = 'right'
  g:lsp_diagnostics_virtual_text_wrap = 'truncate'
  g:lsp_document_code_action_signs_delay = 0
  g:lsp_inlay_hints_enabled = 0
  g:lsp_inlay_hints_delay = 0
  g:lsp_signature_help_delay = 0
  g:lsp_fold_enabled = 0
  g:lsp_settings_filetype_typescript = ['deno']

  def LspDefineBufferAutocmds()
    LspClearBufferAutocmds()

    if &filetype ==# 'go'
      augroup vimrc_lsp_buffer_go
        autocmd BufWritePre <buffer> silent LspDocumentFormatSync
        autocmd BufWritePre <buffer> silent LspCodeActionSync source.organizeImports
        autocmd Filetype <buffer> ++once LspClearBufferAutocmds()
      augroup END
    endif

    augroup vimrc_lsp_buffer
      autocmd BufWritePost <buffer> lclose | silent LspDocumentDiagnostics
    augroup END
  enddef

  def LspClearBufferAutocmds()
    augroup vimrc_lsp_buffer
      autocmd! * <buffer>
    augroup END

    if &filetype ==# 'go'
      augroup vimrc_lsp_buffer_go
        autocmd! * <buffer>
      augroup END
    endif
  enddef

  def LspEnableForBuffer()
    setlocal omnifunc=lsp#complete
    nnoremap <buffer> <silent> gd <Plug>(lsp-declaration)zv
    nnoremap <buffer> <Space>i <Plug>(lsp-hover-float)
    nnoremap <buffer> <Up> <Plug>(lsp-previous-error)zv
    nnoremap <buffer> <Down> <Plug>(lsp-next-error)zv

    LspDefineBufferAutocmds()
  enddef

  def LspDisableForBuffer()
    setlocal omnifunc=
    nunmap <buffer> gd
    nunmap <buffer> <Space>i
    nunmap <buffer> <Up>
    nunmap <buffer> <Down>

    LspClearBufferAutocmds()
  enddef

  augroup vimrc_lsp
    autocmd User lsp_buffer_enabled call LspEnableForBuffer()
    autocmd User lsp_buffer_disabled call LspDisableForBuffer()
  augroup END
endif
if Pacpack.Tap('vim-lsp-settings')
  def LspUpdateAllServers()
    if !exists('g:loaded_lsp_settings')
      packadd vim-lsp-settings
    endif
    const ToDict = (l: list<string>): dict<string> => {
      var d: dict<string>
      for e in l
        d[e] = ''
      endfor
      return d
    }
    var installedServers = lsp_settings#installed_servers()
      ->map('v:val.name')
      ->ToDict()
    if installedServers->empty()
      Echomsg('No servers are installed.')
      return
    endif
    tabnew
    for [ft, servers] in lsp_settings#settings()->items()
      for server in servers
        if has_key(installedServers, server.command)
          installedServers[server.command] = ft
        endif
      endfor
    endfor
    for [server, ft] in installedServers->items()
      lsp_settings#install_server(ft, server)
    endfor
    Echomsg('Finished updating.')
  enddef

  command! -bar LspUpdateAllServers LspUpdateAllServers()
endif
# Textobj/Operator-user plugins
# @param
# - plugin_name: the name of plugin
# - info: mapping-information. The keys are:
#   - rhs (string)
#   - lhs (string)
#   - modes (string)
def MapOperator(plugin_name: string, info_arg: dict<string>)
  var info = extend(info_arg, {modes: 'nxo'}, 'keep')
  MapTextModifierPlugin(plugin_name, info)
enddef

def MapTextobj(plugin_name: string, info_arg: dict<string>)
  var info = extend(info_arg, {modes: 'xo'}, 'keep')
  MapTextModifierPlugin(plugin_name, info)
enddef

def MapTextModifierPlugin(
      plugin_name: string, info: dict<string>)
  # When the plugin is already loaded, do not use loader mapping. This load
  # guard is mainly for vimrc-reloading
  if Pacpack.IsLoaded(plugin_name)
    return
  endif

  for key in ['rhs', 'lhs', 'modes']
    if !has_key(info, key)
      EchomsgError('MapTextModifierPlugin: This key is missing: ' .. key)
      return
    endif
  endfor

  var loadermap = printf('<SID>LoadTextModifierPlugin("%s", %s)',
            plugin_name, string(info)->substitute('<', '<lt>', 'g'))
  for mode in info.modes
    execute mode .. 'map <expr>' info.lhs loadermap
  endfor
enddef

def LoadTextModifierPlugin(plugin: string, info: dict<string>): string
  Pacpack.Load(plugin)

  # "\<Plug>" -> '<Plug>'
  var rhs = info.rhs->substitute("\\C\<Plug>", '<Plug>', 'g')
  for mode in info.modes
    execute mode .. 'map' info.lhs rhs
  endfor

  # '<Plug>' -> "\<Plug>"
  return info.rhs->substitute('\c<Plug>', "\<Plug>", 'g')
enddef

if Pacpack.Tap('vim-operator-replace')
  MapOperator('vim-operator-replace', {lhs: 'ms', rhs: '<Plug>(operator-replace)'})
endif
if Pacpack.Tap('vim-sandwich')
  g:textobj_sandwich_no_default_key_mappings = 1
  g:operator_sandwich_no_default_key_mappings = 1
  def SandwichConfig()
    operator#sandwich#set('all', 'all', 'highlight', 0)
  enddef
  Pacpack.plugin.SetHookOnLoad(SandwichConfig)
  MapOperator('vim-sandwich',
      {lhs: 'ma', rhs: '<Plug>(operator-sandwich-add)'})
  MapOperator('vim-sandwich',
      {lhs: 'md', rhs: '<Plug>(operator-sandwich-delete)'})
  MapOperator('vim-sandwich',
      {lhs: 'mr', rhs: '<Plug>(operator-sandwich-replace)'})
endif
if Pacpack.Tap('caw.vim')
  inoremap <Plug>(vimrc:caw:prefix) <C-g>u<ESC>
  inoremap <silent> <Plug>(vimrc:caw:comment:here)
        \ <C-r>=b:caw_oneline_comment<CR>

  def CawLoadFtplugin()
    execute $'runtime! OPT after/ftplugin/{&filetype}/caw.vim'
  enddef

  Pacpack.plugin.SetHookOnLoad(CawLoadFtplugin)

  def CawMap(): string
    var kind = ''
    if col('.') == 1
      kind = 'zeropos'
    elseif col('.') == col('$')
      kind = 'dollarpos'
    elseif getline('.') =~# '^\s\+$'
      kind = 'hatpos'
    else
      return "\<Plug>(vimrc:caw:comment:here)"
    endif
    return "\<Plug>(vimrc:caw:prefix)\<Plug>(caw:" .. kind .. ":comment)"
  enddef
  imap <expr> <Plug>(vimrc:caw:map) <SID>CawMap()

  MapOperator('caw.vim',
    {lhs: 'mc', rhs: '<Plug>(caw:hatpos:toggle:operator)'})
  MapOperator('caw.vim',
    {lhs: 'm/', rhs: '<Plug>(caw:hatpos:toggle:operator)'})
  MapTextModifierPlugin('caw.vim',
    {lhs: '<C-l><C-j>', rhs: '<Plug>(vimrc:caw:map)', modes: 'i'})
  g:caw_no_default_keymappings = 1
  g:caw_dollarpos_sp_left = '  '
  g:caw_dollarpos_sp_right = ' '
  g:caw_hatpos_sp = ' '
  g:caw_zeropos_sp = ' '
endif
if Pacpack.Tap('vim-operator-swap')
  MapOperator('vim-operator-swap', {lhs: 'my', rhs: '<Plug>(operator-swap-marking)'})
  MapOperator('vim-operator-swap', {lhs: 'mp', rhs: '<Plug>(operator-swap)'})
endif
if Pacpack.Tap('vim-operator-jump_side')
  MapOperator('vim-operator-jump_side', {lhs: '<C-p>', rhs: '<Plug>(operator-jump-head)'})
  MapOperator('vim-operator-jump_side', {lhs: '<C-n>', rhs: '<Plug>(operator-jump-tail)'})
endif
if Pacpack.Tap('vim-textobj-entire')
  MapTextobj('vim-textobj-entire', {lhs: 'aa', rhs: '<Plug>(textobj-entire-a)'})
  MapTextobj('vim-textobj-entire', {lhs: 'ia', rhs: '<Plug>(textobj-entire-i)'})
  g:textobj_entire_no_default_key_mappings = 1
endif
if Pacpack.Tap('vim-textobj-function')
  augroup vim_textobj_function
    autocmd Filetype c,java,vim ++once {
      packadd vim-textobj-function
      execute 'runtime ftplugin/vim-textobj-function/' .. expand('<amatch>') .. '/textobj-function.vim'
    }
  augroup END
  def CleanTextobjFunctionAutocmd()
    augroup vim_textobj_function
      autocmd!
    augroup END
  enddef
  Pacpack.plugin.SetHookOnLoad(CleanTextobjFunctionAutocmd)

  MapTextobj('vim-textobj-function',
    {lhs: 'af', rhs: '<Plug>(textobj-function-a)'})
  MapTextobj('vim-textobj-function',
    {lhs: 'if', rhs: '<Plug>(textobj-function-i)'})
  g:textobj_function_no_default_key_mappings = 1
endif
if Pacpack.Tap('vim-textobj-indent')
  MapTextobj('vim-textobj-indent', {lhs: 'ai', rhs: '<Plug>(textobj-indent-a)'})
  MapTextobj('vim-textobj-indent', {lhs: 'aI', rhs: '<Plug>(textobj-indent-same-a)'})
  MapTextobj('vim-textobj-indent', {lhs: 'ii', rhs: '<Plug>(textobj-indent-i)'})
  MapTextobj('vim-textobj-indent', {lhs: 'iI', rhs: '<Plug>(textobj-indent-same-i)'})
  g:textobj_indent_no_default_key_mappings = 1
endif
if Pacpack.Tap('vim-textobj-line')
  MapTextobj('vim-textobj-line', {lhs: 'al', rhs: '<Plug>(textobj-line-a)'})
  MapTextobj('vim-textobj-line', {lhs: 'il', rhs: '<Plug>(textobj-line-i)'})
  g:textobj_line_no_default_key_mappings = 1
endif
if Pacpack.Tap('vim-textobj-commentblock')
  MapTextobj('vim-textobj-commentblock',
        {lhs: 'ac', rhs: '<Plug>(textobj-commentblock-a)'})
  MapTextobj('vim-textobj-commentblock',
        {lhs: 'ic', rhs: '<Plug>(textobj-commentblock-i)'})
  g:textobj_commentblock_no_default_key_mapings = 1

  def TextobjCommentblockPickerCaw()
    if exists('g:loaded_caw')
      textobj#commentblock#pick#caw()
    else
      textobj#commentblock#pick#commentblock()
    endif
  enddef

  def OnLoadingTextobjCommentblock()
    augroup vimrc_textobj_commentblock
      autocmd!
      autocmd Filetype * TextobjCommentblockPickerCaw()
    augroup END
    TextobjCommentblockPickerCaw()
  enddef

  Pacpack.plugin.SetHookOnLoad(OnLoadingTextobjCommentblock)
endif
if Pacpack.Tap('vim-textobj-between')
  MapTextobj('vim-textobj-between', {lhs: 'ad', rhs: '<Plug>(textobj-between-a)'})
  MapTextobj('vim-textobj-between', {lhs: 'id', rhs: '<Plug>(textobj-between-i)'})
  g:textobj_between_no_default_key_mappings = 1

  omap i/ id/
  omap a/ ad/
  vmap i/ id/
  vmap a/ ad/
endif

# ReadingVimrc
command! -bar ReadingVimrc call ReadingVimrc()
augroup vimrc-readingvimrc
  autocmd BufReadCmd readingvimrc://* OnOpenReadingVimrcBuffer()
augroup END
def ReadingVimrc()
  try
    packadd vim-reading-vimrc

    # Use :execute here because :ReadingVimrcNext command doesn't defined yet
    # when compiling this function and E476 error is given
    execute 'ReadingVimrcNext'

    command! ReadingVimrc ReadingVimrcNext
  catch
    EchomsgError(v:throwpoint .. v:exception)
  endtry
enddef

def OnOpenReadingVimrcBuffer()
  const bufname = expand('<amatch>')->matchstr('readingvimrc://\zs.*')
  if bufname ==# 'next'
    if winnr('$') == 1
      return
    endif

    var curwinnr = winnr()
    for winnr in range(1, winnr('$'))
      if winnr == curwinnr
        continue
      elseif line('$') > 1 || winbufnr(winnr)->getbufline(1)[0] !=# ''
        wincmd T
        return
      endif
    endfor

    only
  else
    vmap y <Plug>(reading_vimrc-update_clipboard)
    if winnr('$') > 1
      wincmd T
    endif
  endif
enddef

# Additional plugins
final SessionDir = JoinPath(Stdpath.cache, 'sessions')
{
  Mkdir(SessionDir, 'p')
  command! MkSession call vimrc#session#make()
  command! -nargs=+ -complete=custom,vimrc#session#complete DelSession
       \ call vimrc#session#delete(1, <f-args>)
  command! -nargs=1 -complete=custom,vimrc#session#complete RestoreSession
       \ call vimrc#session#restore(<q-args>)
}

# Showmode
def ShowmodeInit()
  const colors = {
    normal: [['22', '148'], ['#005f00', '#afdf00']],
    insert: [['23', '117'], ['#005f5f', '#87dfff']],
    visual: [['88', '208'], ['#870000', '#ff8700']],
    replace: [['231', '160'], ['#ffffff', '#df0000']],
  }
  for [mode, color] in items(colors)
    execute printf(
      'highlight VimrcShowMode%s ctermfg=%s ctermbg=%s guifg=%s guibg=%s',
      mode, color[0][0], color[0][1], color[1][0], color[1][1])
  endfor
enddef
def ShowmodeMode(): string
  ShowmodeHighlight()
  var map = {
    n: 'NORMAL',
    i: 'INSERT',
    R: 'REPLACE',
    v: 'VISUAL',
    V: 'V-LINE',
    ["\<C-v>"]: 'V-BLOCK',
    c: 'COMMAND',
    ce: 'EX-COM',
    s: 'SELECT',
    S: 'S-LINE',
    ["\<C-s>"]: 'S-BLOCK',
    t: 'T-INSERT',
    no: 'OPERATOR',
    niI: 'N-INSERT',
    niR: 'N-REPLACE',
    niV: 'N-V-REPLACE',
  }
  return get(map, mode(), 'UNKNOWN')
enddef
def ShowmodeHighlight()
  var type = get({
     i: 'insert',
     t: 'insert',
     R: 'replace',
     v: 'visual',
     V: 'visual',
     ["\<C-v>"]: 'visual',
   }, mode(), 'normal')
  execute 'highlight link VimrcShowMode VimrcShowMode' .. type
enddef
def ShowmodeLabel(): string
  if win_getid() == g:statusline_winid &&
        getwinvar(g:statusline_winid, '&modifiable')
    return '%#VimrcShowMode# %{<SID>ShowmodeMode()} %#Statusline#'
  endif
  return ''
enddef
augroup vimrc_showmode
  autocmd ColorScheme * ShowmodeInit()
  autocmd User vimrc_initialize ++once ShowmodeInit()
augroup END

# statusline
if Pacpack.Tap('gina.vim')
  augroup vimrc_gina
    autocmd CursorHold * ++once call gina#component#repo#branch()
    autocmd SourcePost */autoload/gina.vim ++once {
      autocmd! vimrc_gina CursorHold
      call gina#component#repo#branch()
      redrawstatus!
    }
  augroup END
  def StatuslineGitBranch(): string
    if exists('*gina#component#repo#branch')
      var branch = gina#component#repo#branch()
      if branch ==# ''
        return 'no-git'
      else
        var ahead: any = gina#component#traffic#ahead()
        var behind: any = gina#component#traffic#behind()
        var staged = !!gina#component#status#staged()->str2nr()
        var unstaged = !!gina#component#status#unstaged()->str2nr()

        var icon_modified = (staged || unstaged) ? '*' : ''
        var icon_ahead =
              ahead->type() == v:t_number && !!ahead ? '↑' : ''
        var icon_behind =
              behind->type() == v:t_number && !!behind ? '↓' : ''
        return branch .. icon_modified .. icon_ahead .. icon_behind
      endif
    else
      return 'loading...'
    endif
  enddef
else
  def StatuslineGitBranch(): string
    return 'no-gina'
  enddef
endif
def StatuslineGenerator(): string
  var statusline =
    '%m' ..
    ShowmodeLabel() ..
    '[%{&ft ==# "" ? "No ft" : &ft}]' ..
    '[#%{bufnr("%")}]' ..
    '[%{<SID>StatuslineGitBranch()}]' ..
    '%{<SID>FilenameLabel(bufnr("%"))}' ..
    '%<%=' ..
    '[%{&fileformat}]' ..
    '[%{&fileencoding == "" ? &encoding : &fileencoding}]' ..
    '[%{pathshorten(getcwd(winnr()))}]'
  return substitute(statusline, '\c<SID>', SIDPrefix(), 'g')
enddef
def FilenameLabel(bufnr: number): string
  var buftype = getbufvar(bufnr, '&buftype')
  var bufname = bufname(bufnr)
  if buftype ==# 'help'
    return fnamemodify(bufname, ':t')
  elseif buftype ==# 'quickfix'
    return '[quickfix]'
  elseif getbufvar(bufnr, '&previewwindow')
    return '[preview]'
  elseif buftype ==# 'terminal'
    return 'terminal:' .. bufname
  elseif buftype ==# 'prompt'
    return '[prompt]'
  else
    return (buftype ==# 'nofile' ? ' *NoFile* ' : '') ..
      (bufname ==# '' ? '[NoName]' : pathshorten(fnamemodify(bufname, ':.')))
  endif
enddef
&statusline = printf('%%!%sStatuslineGenerator()', SIDPrefix())

# tabline
&tabline = printf('%%!%sTabline()', SIDPrefix())
def GenerateTabinfo(tabnr: number): string
  var tablist = tabpagebuflist(tabnr)
  var info = ''
  info ..= len(filter(copy(tablist), 'getbufvar(v:val, "&mod")')) > 0 ? '[+]' : ''
  info ..= '[' .. tabpagewinnr(tabnr, '$') .. ']'
  return info
enddef
def Tabline(): string
  var tabline = '%#TabLine#|'
  var t = tabpagenr()

  for n in range(1, tabpagenr('$'))
    tabline ..= '%' .. n .. 'T'
    var info = ' ' .. GenerateTabinfo(n) .. ' '
    if t == n
      tabline ..= '%#TabLineSel# %999Xx%X' .. info .. '%#TabLine#'
    else
      tabline ..= info
    endif
    tabline ..= '%T|'
  endfor
  tabline ..= '%>%=[%{pathshorten(getcwd())}]'

  return substitute(tabline, '\c<SID>', SIDPrefix(), 'g')
enddef

# :terminal
augroup vimrc_terminal
  autocmd TerminalWinOpen * setlocal nonumber norelativenumber
augroup END

# EmphasisIndent
highlight link VimrcEmphasisIndent CursorLine
augroup vimrc_emphasize_indent
  autocmd WinEnter * EmphasizeIndent()
  autocmd OptionSet expandtab,smarttab,tabstop,shiftwidth EmphasizeIndent()
  autocmd User vimrc_initialize ++once EmphasizeIndent()
augroup END
def EmphasizeIndent()
  if exists('w:disable_emphasis_indent') && <bool>w:disable_emphasis_indent
    return
  endif
  if exists('w:emphasis_indent_id')
    matchdelete(w:emphasis_indent_id)
    unlet w:emphasis_indent_id
  endif

  var pat = '\v%%(^%%(%s)*)@<=%s'
  if &l:expandtab
    pat = printf(pat, repeat('\s', shiftwidth()), '\s')
  else
    pat = printf(pat, '\t\t', '\t')
  endif
  w:emphasis_indent_id = matchadd('VimrcEmphasisIndent', pat)
enddef
def EmphasisIndentEnable()
  w:disable_emphasis_indent = 0
  EmphasizeIndent()
enddef
def EmphasisIndentDisable()
  w:disable_emphasis_indent = 1
  if exists('w:emphasis_indent_id')
    matchdelete(w:emphasis_indent_id)
    unlet w:emphasis_indent_id
  endif
enddef
command! EmphasisIndentDisable call EmphasisIndentDisable()
command! EmphasisIndentEnable call EmphasisIndentEnable()

# WarningSpace
highlight link WarningSpace Error
augroup vimrc_warningspace
  # Call WarningSpace() function on TerminalWinOpen event to disable warning
  # space emphasis; it seems WinEnter event triggered on the previous window
  # when opening terminal window.
  autocmd WinEnter,TerminalWinOpen * WarningSpace()
  autocmd OptionSet * WarningSpace()  # TODO: specify option?
  autocmd User vimrc_initialize ++once WarningSpace()
augroup END
def WarningSpace()
  # Clean up.
  if exists('w:twobyte_space_id')
    matchdelete(w:twobyte_space_id)
    unlet w:twobyte_space_id
  endif
  if exists('w:end_of_line_space_id')
    matchdelete(w:end_of_line_space_id)
    unlet w:end_of_line_space_id
  endif

  if &l:buftype !=# '' || !&l:modifiable
    return
  endif

  # Zenkaku space
  # NOTE: '\%d12288' means one zenkaku space. HINT: nr2char(12288)
  w:twobyte_space_id = matchadd('WarningSpace', '\%d12288')

  # White spaces in the end of line
  w:end_of_line_space_id = matchadd('WarningSpace', '\s\+$')
enddef
command! ReplaceTwobyteSpace keeppatterns :%s/\%d12288/ /g
command! DeleteLineEndSpace keeppatterns :%s/\s\+$//g

# mru
g:mru_history_file = JoinPath(Stdpath.cache, 'mru', 'history')
{
  var dir = JoinPath(Stdpath.cache, 'mru')
  Mkdir(dir, 'p')
}
g:mru_ignore_pattern = [
      \ '\.git\>',
      \ '^\V\%(' .. escape(expand('~'), '\') .. '\)\@!'
      \ ]

# filore
def FiloreMapping()
  var mapping: list<any> = [
   ['q', 'exit'],
   ['o', 'toggle-directory-folding'],
   ['l', 'enter-directory'],
   ['h', 'leave-directory'],
   ['.', 'toggle-show-hidden-files'],
   ['k', 'loop-cursor-up'],
   ['j', 'loop-cursor-down'],
   ['<CR>', 'open-file'],
   ['/', 'filter-files'],
   ['<C-h>', 'start-history'],
  ]->mapnew((_: number, val: list<string>): string =>
       ('nmap <buffer> ' .. val[0] .. ' <Plug>(filore-' .. val[1] .. ')'))
  execute join(mapping, "\n")
enddef
augroup vimrc_additional_plugins
  autocmd FileType filore call FiloreMapping()
augroup END

# git
def GitDiffGetcmd(arg_target: string): string
  const target: string = resolve(arg_target)
  const gitroot: string = FindGitroot(target)
  if gitroot ==# ''
    return ''
  endif
  return $'git -C {gitroot} --no-pager diff --no-color {target}'
enddef

def GitDiff(arg_target: string)
  var target: string
  if arg_target ==# ''
    target = bufname('%')
  else
    target = arg_target
  endif
  target = resolve(target)
  if getftype(target) ==# ''
    EchomsgError('File or directory does not exists: ' .. target)
    return
  endif
  const cmd = GitDiffGetcmd(target)
  if cmd ==# ''
    return
  endif
  var bufnr = term_start(cmd, {
          term_name: '[git diff] ' .. fnamemodify(target, ':~:.'),
          norestore: 1,
        })
  if bufnr != 0
    setlocal nocursorline nocursorcolumn filetype=diff
    nnoremap <buffer> <nowait> q <Cmd>quit<CR>
    cursor(1, 0)
  endif
  return
enddef
command! -nargs=? -complete=file GitDiff call GitDiff(<q-args>)

# gyoza
augroup vimrc_gyoza
  autocmd InsertEnter * ++once vimrc#gyoza#Enable()
augroup END

# splash
command! Splash call vimrc#splash#Show()
if !v:vim_did_enter && !(IsMac && has('gui_running'))
  augroup vimrc_splash
    autocmd VimEnter * ++once ++nested call vimrc#splash#Intro()
    autocmd StdinReadPre * ++once autocmd! vimrc_splash VimEnter
  augroup END
endif

# gvimrc
if has('gui_running')
  if !v:vim_did_enter
    if IsWSL
      # Avoid too large window.
      set lines=35
      set columns=100
    elseif IsLinux && executable('i3')
      # It seems that too large window on i3 does not work properly.
      set lines=50
      set columns=200
    else
      set lines=999
      set columns=9999
    endif

    if IsWindows
      winpos 0 0
      cd $USERPROFILE
      if &shell =~? 'cmd\.exe' && executable('C:/msys64/usr/bin/bash.exe')
        # Set MSYS2 MinGW64 related environmental variables.
        if executable('C:/msys64/msys2_shell.cmd')
          eval systemlist('C:/msys64/msys2_shell.cmd -mingw64 -defterm -no-start -c env')
            ->filter((_: number, v: string): bool => v =~# '\v^%(MSYS|MINGW)')
            ->map((_: number, v: string): string => substitute(
              v,
              '\v(^[^=]*)\=(.*)$',
              (m: list<string>): string => $'${m[1]} = {m[2]->expand()->string()}',
              ''))
            ->execute()
        endif
        # Then change shell.
        &shell = 'C:/msys64/usr/bin/bash.exe'
        &shellcmdflag = '-c'
      endif
    endif
  endif
  set guioptions& guioptions-=e guioptions-=T guioptions-=m
  set guioptions-=R guioptions-=r guioptions-=L guioptions-=l
  set mouse=a
  set nomousefocus
  set mousehide

  if has('win32')
    set guifont=Cica:h12,MS_Gothic:h10:cSHIFTJIS
    set linespace=1
  elseif has('mac')
    set guifont=Cica:h14,Osaka-Mono:h14
  elseif has('xfontset')
    # for unix (use xfontset)
    set guifont=a14,r14,k14
  elseif has('linux')
    set guifont=Cica\ 14,DejaVu\ Sans\ Mono\ 14
  endif

  if has('multi_byte_ime') || has('xim')
    set iminsert=0 imsearch=0
    augroup vimrc_iminsert
      autocmd InsertLeave * set iminsert=0
    augroup END
  endif
endif

# lvimrc
{
  var lvimrc = JoinPath('~', Rc('lvimrc'))
  execute 'command! -bar -nargs=* LVimrc ' ..
          'execute <q-args> ?? "edit"' string(lvimrc)
  if filereadable(expand(lvimrc))
    execute 'source' lvimrc
  endif
}

# Load plugins
if !v:vim_did_enter
  Pacpack.LoadNonLazyPlugins()
endif

# Initialize when loading this file.
augroup vimrc_initialize_dummy
  # Not to provide an error. For more information, see `:h E217`
  autocmd User vimrc_initialize ++once # Do nothing.
augroup END

if v:vim_did_enter
  doautocmd User vimrc_initialize
else
  # TODO: Maybe this is not enough for Windows or MacVim (They may takes a
  # while from VimEnter autocommand to first screen update)
  # autocmd VimEnter * ++once timer_start(
  #     \5, (timer) => execute('doautocmd User vimrc_initialize'))
  var statusLineSave = &statusline
  def VimrcInitialize(): string
    &statusline = statusLineSave
    timer_start(5, (timer) => execute('doautocmd User vimrc_initialize'))
    return ''
  enddef
  &statusline = '%!' .. SIDPrefix() .. 'VimrcInitialize()'
endif
