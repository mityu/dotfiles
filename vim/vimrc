" vim: shiftwidth=2
vim9script noclear

# Encoding
if !v:vim_did_enter
  set encoding=utf-8
  $MYVIMRC = resolve(expand('<sfile>'))
  if has('win32')
    $MYVIMRC = expand('<sfile>')
  endif
  if $NVIM !=# '' && !($VIM ==# '' && $VIMRUNTIME ==# '') # In Neovim's terminal now.
    const installPrefix = exepath(v:progpath)->fnamemodify(':h:h')
    const sep = installPrefix->fnamemodify(':p')[-1]
    const vimdir = [installPrefix, 'share', 'vim']->join(sep)
    const vimruntime =
      [vimdir, printf('vim%d%d', v:version / 100, v:version % 100)]->join(sep)
    if isdirectory(vimdir) && isdirectory(vimruntime)
      def ReplacePath(paths: string): string
        const reps = [[$VIMRUNTIME, vimruntime], [$VIM, vimdir]]
          ->mapnew((_: number, v: list<string>): list<any> => [strlen(v[0])] + v)
        return paths
          ->split(',')
          ->map((_: number, v: string): string => {
            for [len, src, dst] in reps
              if v->strpart(0, len) ==# src
                return dst .. v->strpart(len)
              endif
            endfor
            return v
          })
          ->join(',')
      enddef
      &runtimepath = ReplacePath(&runtimepath)
      &packpath = ReplacePath(&packpath)
      $VIM = vimdir
      $VIMRUNTIME = vimruntime
    endif
  endif
endif

scriptencoding utf-8

final IsWindows = has('win32')
final IsWinUnix = has('win32unix')
final IsLinux = has('linux')
final IsMac = has('mac')
final IsUnix = IsLinux || IsMac
final IsWSL = IsLinux && getftype('/proc/sys/fs/binfmt_misc/WSLInterop') !=# ''

export class Fs
  static const slash = IsWindows ? '\\' : '/'
  static const pathSeparator = IsWindows ? ':' : ';'
  static const rcfilePrefix = IsWindows ? '_' : '.'

  static def Rc(fname: string): string
    return rcfilePrefix .. fname
  enddef

  static def JoinPath(...elems: list<any>): string
    return join(elems, slash)
  enddef
endclass

export class Stdpath
  static const cache = (IsWindows ? '~\.cache\vim' : '~/.cache/vim')->expand()
  static const dotvim = (IsWindows ? '~\vimfiles' : '~/.vim')->expand()
  static const dotfiles = $MYVIMRC->fnamemodify(':h:h')
endclass

$DOT_VIM = Stdpath.dotvim

export def SIDPrefix(): string
  # Returns "<SNR>{script-ID}_"
  return expand('<SID>')
enddef

def SNR(): string
  return matchstr(SIDPrefix(), '<SNR>\zs\d\+\ze_$')
enddef

def GetMsgString(msg: string): string
  return '[vimrc] ' .. msg
enddef

def EchomsgWithColor(msg: string, hl_group: string)
  execute 'echohl' hl_group
  echomsg GetMsgString(msg)
  echohl NONE
enddef

export def Echomsg(msg: string)
  EchomsgWithColor(msg, 'NONE')
enddef

export def EchomsgError(msg: string)
  EchomsgWithColor(msg, 'Error')
enddef

export def EchomsgWarning(msg: string)
  EchomsgWithColor(msg, 'WarningMsg')
enddef

export def Echo(msg: string)
  echo GetMsgString(msg)
enddef

export def EchoQuestion(question: string)
  echon GetMsgString(question) .. ' '
  echohl Question
  echon '[Y/N]'
  echohl NONE
  echon "\n"
enddef

export def Ask(question: string): bool
  EchoQuestion(question)
  return getcharstr() =~? 'y'
enddef

export def Mkdir(dir: string, ...opt: list<any>): bool
  if isdirectory(dir)
    return true
  endif
  return !!call('mkdir', [dir] + opt)
enddef

export def Input(prompt: string, ...opt: list<any>): string
  try
    return call('input', [prompt] + opt)
  catch /\C^Vim:Interrupt$/
    return ''
  endtry
  return ''
enddef

export def ReplaceTermcodes(key: string): string
  return key->substitute(
    '<[^<>]\+>', (m: list<string>): string => eval($'"\{m[0]}"'), 'g')
enddef

# Global utility functions
export def SetUndoFtplugin(config: string)
  const restorer = 'execute ' .. string(config)
  if exists('b:undo_ftplugin')
    b:undo_ftplugin = restorer .. '|' .. b:undo_ftplugin
  else
    setbufvar('%', 'undo_ftplugin', restorer)
  endif
enddef
command! -nargs=1 -complete=command SetUndoFtplugin
      \ call SetUndoFtplugin(<q-args>)

def g:Tapi_drop(bufnr: number, arglist: list<any>)
  const cwd = arglist[0]
  var filepath = arglist[1]
  if !isabsolutepath(filepath)
    filepath = fnamemodify(cwd, ':p') .. filepath
  endif
  var opencmd = 'drop'
  if bufwinnr(bufnr(filepath)) == -1
    opencmd = 'split'
  endif
  execute opencmd fnameescape(filepath)
enddef

def g:Tapi_getcwd(bufnr: number, arglist: list<any>)
  const cwd = call('getcwd', arglist)
  const channel = term_getjob(bufnr)->job_getchannel()
  ch_sendraw(channel, cwd .. "\n")
enddef

# Startup config
if !v:vim_did_enter
  if has('multi_lang') && has('menu')
    set langmenu=ja.utf-8
  endif

  # NOTE: This must be set before 'termguicolors' option is set, or display
  # will get chaos.
  if $TERM_PROGRAM ==# 'WezTerm'
    &t_Cs = "\e[4:3m"
    &t_Ce = "\e[4:0m"
  endif

  if $COLORTERM ==# 'truecolor' || IsWindows
    set termguicolors  # Use true color if possible.
  endif

  if &term =~# '\<xterm\>'
    &t_EI = "\<ESC>[2 q"  # Use Block style cursor in Normal-mode.
    &t_SI = "\<ESC>[6 q"  # Use Bar style cursor in Insert-mode.
    &t_SR = "\<ESC>[4 q"  # Use underline style cursor in Replace-mode.
    set mouse=a
  endif

  if &term ==# 'win32'
    set mouse=a
    # FIXME: It seems that these values aren't reflected well when they're set
    # just here.
    autocmd VimEnter * ++once {
      &t_EI = "\<ESC>[2 q"  # Use Block style cursor in Normal-mode.
      &t_SI = "\<ESC>[6 q"  # Use Bar style cursor in Insert-mode.
      &t_SR = "\<ESC>[4 q"  # Use underline style cursor in Replace-mode.
    }
  endif

  # disable modifyOtherKeys
  &t_TI = ''
  &t_TE = ''

  # disable default plugins
  g:loaded_2html_plugin = 1
  g:loaded_getscriptPlugin = 1
  g:loaded_gzip = 1
  g:loaded_zipPlugin = 1
  g:loaded_tarPlugin = 1
  g:loaded_vimballPlugin = 1
  g:loaded_netrw = 1
  g:loaded_netrwPlugin = 1
  g:loaded_netrwSettings = 1
  g:did_install_default_menus = 1
  g:did_install_syntax_menus = 1
  g:skip_loading_mswin = 1
  g:loaded_logiPat = 1

  &runtimepath = &runtimepath->split(',')->filter('isdirectory(v:val)')->join(',')
  &packpath = &packpath->split(',')->filter('isdirectory(v:val)')->join(',')
  &runtimepath ..= ',' .. escape(Fs.JoinPath($DOT_VIM, 'runtime'), ' \')
  &packpath = Stdpath.cache .. ',' .. &packpath

  # Set environmental variables on gVim.
  {
    const envrc = Fs.JoinPath(expand('~'), Fs.Rc('envrc'))
    if has('gui_running') && filereadable(envrc)
      const lines = readfile(envrc)
            ->map((_: number, val: string): string => substitute(val, '\v%(\_^|\s)#.*$', '', 'g'))
            ->filter((_: number, val: string): bool => !empty(val))

      for line in lines
        const [name, value] = line->split('=')
        execute '$' .. name .. ' = ' .. value->expand()->string()
      endfor
    endif
  }

  {  # Create directories for undo/swap/backup files.
    Mkdir(Stdpath.cache, 'p')

    final undodir = Fs.JoinPath(Stdpath.cache, 'undo')
    if Mkdir(undodir, 'p')
      set undofile
      &undodir = undodir
    else
      set noundofile
    endif

    final swapdir = Fs.JoinPath(Stdpath.cache, 'swap')
    if Mkdir(swapdir, 'p')
      set swapfile
      &directory = Fs.JoinPath(fnamemodify(swapdir, ':p'), '')
    else
      set noswapfile
    endif

    final backupdir = Fs.JoinPath(Stdpath.cache, 'backup')
    if Mkdir(backupdir, 'p')
      set backup writebackup
      &backupdir = backupdir
    else
      set nobackup nowritebackup
    endif
  }
endif

{ # Initialize augroups
  const filename = expand('<sfile>')
  const pattern = '^\s*aug\%[roup]\s\+\zs\S\+'
  const augroups = readfile(filename)
        ->filter((_: number, line: string): bool => stridx(line, 'aug') != -1)
        ->map((_: number, line: string): string => matchstr(line, pattern))
        ->filter((_: number, augroup: string): bool => augroup !=# '' && augroup !=? 'END')
        ->sort()
        ->uniq()
  for group in augroups
    execute 'augroup' group
    autocmd!
  endfor
  augroup END
}

# minpac
export const PacPath = Fs.JoinPath(Stdpath.cache, 'pack', 'minpac', 'opt')

export def ListInstalledPlugins(): dict<bool>
  var d: dict<bool> = {}
  const F = (e: dict<any>): number => {
    if e.type ==# 'dir'
      d[e.name] = true
    endif
    return 0
  }
  if isdirectory(PacPath)
    PacPath->readdirex(F, {sort: 'none'})
  endif
  return d
enddef

class Plugin
  # Treat plugins as not installed when 'loadplugins' option is off.
  static var _installedPlugins: dict<bool> =
        \ &loadplugins ? ListInstalledPlugins() : {}
  static var _fileSchemaLen = strlen('file://')

  var name: string
  var path: string
  var uri: string
  var config: dict<any>
  var isLazy: bool
  var isLocal: bool
  var isExists: bool
  var hooksOnLoad: list<func(): void>

  def new(name: string, uri: string, config: dict<any>, isLazy: bool)
    this.name = name
    this.uri = uri
    this.isLazy = isLazy
    this.config = config
    this.hooksOnLoad = []
    this.isLocal = this.uri[: _fileSchemaLen - 1] ==# 'file://'
    if this.isLocal
      this.path = this.uri[_fileSchemaLen :]->expand()
      this.isExists = this.path->isdirectory()
    else
      this.path = Fs.JoinPath(PacPath, name)
      this.isExists = _installedPlugins->has_key(name)
    endif
  enddef

  def IsLoaded(): bool
    const idx = &runtimepath->stridx(this.path)
    const ridx = idx + this.path->strlen()
    if idx == -1 ||
        !(idx == 0 || &runtimepath->strpart(idx - 1, 1) ==# ',') ||
        !(ridx == &runtimepath->strlen() || &runtimepath->strpart(ridx, 1) ==# ',')
      return false
    endif
    return true
  enddef
endclass

export class Pacpack
  static var pacPath: string = PacPath
  static var pluginList: dict<Plugin> = {}  # List of enabled plugins.
  static var minpacPluginList: list<Plugin> = []  # List of plugins that are not local.
  static var overriddenPluginList: dict<string> = {}

  static def _add(uri: string, config: dict<any>, isLazy: bool)
    const name = uri->matchstr('/\zs[^/]\+$')
    const p = Plugin.new(name, uri, config, isLazy)
    if pluginList->has_key(name)
      echoerr 'Duplicate plugin name:' name
    endif
    pluginList[name] = p
    if !p.isLocal
      minpacPluginList->add(p)
    endif
  enddef

  static def Add(uri: string, config: dict<any> = {})
    _add(uri, config, false)
  enddef

  static def AddLazy(uri: string, config: dict<any> = {})
    _add(uri, config, true)
  enddef

  # Override already tapped plugin.  E.g. use development version
  static def Override(target: string, uri: string, config: dict<any> = {})
    pluginList->remove(target)
    Add(uri, config)
    overriddenPluginList[target] = uri->matchstr('/\zs[^/]\+$')
  enddef

  static def LoadNonLazyPlugins()
    const appendPath = pluginList
      ->values()
      ->filter((_: number, p: Plugin): bool => !p.isLazy && p.isExists)
      ->mapnew((_: number, p: Plugin): string => p.path)
      ->join(',')
    execute 'set runtimepath+=' .. appendPath

    # Enable ftplugin and syntax highlighting.  Note that this order DOES MATTER.
    filetype plugin indent on
    syntax enable
  enddef

  # Load a plugin.  If the plugin is already loaded, this function does nothing.
  static def Load(name: string)
    const p = GetPlugin(name)
    if p == null_object
      echoerr 'Plugin not found:' name
    elseif !p.IsLoaded()
      execute 'packadd' name
    endif
  enddef

  static def Tap(name: string): bool
    const p = GetPlugin(name)
    return p != null_object && p.isExists
  enddef

  static def IsLoaded(name: string): bool
    const p = GetPlugin(name)
    return p != null_object && p.IsLoaded()
  enddef

  static def GetPlugin(nameGiven: string): Plugin
    const name = overriddenPluginList->get(nameGiven, nameGiven)
    return pluginList->get(name, null_object)
  enddef

  # minpac integrations.
  static def InitMinpac(): bool
    const MinpacInit = () => minpac#init({
      progress_open: "tab",
      status_open: "vertical",
      status_auto: true
    })
    silent! packadd minpac
    silent! MinpacInit()
    if !exists('*minpac#init()')
      # Download minpac...
      const minpacPath = Fs.JoinPath(pacPath, 'minpac')
      Mkdir(fnamemodify(minpacPath, ':h'), 'p')
      Echomsg('Downloading minpac...')
      system('git clone https://github.com/k-takata/minpac ' .. minpacPath)

      silent! packadd minpac
      silent! MinpacInit()
      if !exists('*minpac#init()')
        return false
      endif
    endif

    for p in minpacPluginList
      var config = p.config->copy()
      config.type = 'opt'
      minpac#add(p.uri, config)
    endfor

    return true
  enddef

  static def Update()
    if InitMinpac()
      const info = minpac#getpluginfo('vimdoc-ja')
      if !empty(info)
        system(printf('git -C %s reset --hard', shellescape(info.dir)))
      endif
      minpac#update()
    endif
  enddef

  static def Clean()
    if InitMinpac()
      minpac#clean()
    endif
  enddef

  static def Status()
    if exists('*minpac#status')
      minpac#status()
    else
      EchomsgError('minpac isn''t loaded yet.')
    endif
  enddef
endclass

command! -bar PackInit   Pacpack.InitMinpac()
command! -bar PackUpdate Pacpack.Update()
command! -bar PackClean  Pacpack.Clean()
command! -bar PackStatus Pacpack.Status()

Pacpack.AddLazy('https://github.com/k-takata/minpac')
Pacpack.Add('https://github.com/itchyny/vim-cursorword')
Pacpack.Add('https://github.com/itchyny/vim-qfedit')
Pacpack.Add('https://github.com/k-ogata-1/vim-vimscript-gd')
Pacpack.Add('https://github.com/kamichidu/vim-textobj-function-go')
Pacpack.Add('https://github.com/kana/vim-altr')
Pacpack.Add('https://github.com/kana/vim-operator-user')
Pacpack.Add('https://github.com/kana/vim-textobj-user')
Pacpack.Add('https://github.com/kawarimidoll/autoplay.vim')
Pacpack.Add('https://github.com/kyoh86/vim-ripgrep')
Pacpack.Add('https://github.com/lambdalisue/vim-fern')
Pacpack.Add('https://github.com/lambdalisue/vim-fern-renderer-nerdfont')
Pacpack.Add('https://github.com/lambdalisue/vim-nerdfont')
Pacpack.Add('https://github.com/lambdalisue/vim-findent')
Pacpack.Add('https://github.com/lambdalisue/vim-gista')
Pacpack.Add('https://github.com/lambdalisue/vital-Whisky')
Pacpack.Add('https://github.com/mattn/vim-notification')
Pacpack.Add('https://github.com/matze/vim-tex-fold')
Pacpack.Add('https://github.com/mityu/vim-alith')
Pacpack.Add('https://github.com/mityu/vim-backpair')
Pacpack.Add('https://github.com/mityu/vim-charjump')
Pacpack.Add('https://github.com/mityu/vim-cmdhistory')
Pacpack.Add('https://github.com/mityu/vim-cobachi')
Pacpack.Add('https://github.com/mityu/vim-gyoza')
Pacpack.Add('https://github.com/mityu/vim-quickrun-hook-auto_run_in_vim9')
Pacpack.Add('https://github.com/mityu/vim-winc')
Pacpack.Add('https://github.com/mityu/vim-wispath')
Pacpack.Add('https://github.com/mityu/vital-keymapper')
Pacpack.Add('https://github.com/mityu/vital-vim9context')
Pacpack.Add('https://github.com/osyo-manga/vim-jplus')
Pacpack.Add('https://github.com/previm/previm')
Pacpack.Add('https://github.com/seroqn/foldmaker.vim')
Pacpack.Add('https://github.com/thinca/vim-ambicmd')
Pacpack.Add('https://github.com/thinca/vim-ft-help_fold')
Pacpack.Add('https://github.com/thinca/vim-partedit')
Pacpack.Add('https://github.com/thinca/vim-prettyprint')
Pacpack.Add('https://github.com/thinca/vim-qfreplace')
Pacpack.Add('https://github.com/thinca/vim-quickrun')
Pacpack.Add('https://github.com/thinca/vim-themis')
Pacpack.Add('https://github.com/tikhomirov/vim-glsl')
Pacpack.Add('https://github.com/tyru/capture.vim')
Pacpack.Add('https://github.com/tyru/open-browser.vim')
# Pacpack.Add('https://github.com/utubo/vim-vim9skk')
Pacpack.Add('https://github.com/vim-jp/autofmt')
Pacpack.Add('https://github.com/vim-jp/vimdoc-ja')
Pacpack.Add('https://github.com/vim-jp/vital.vim')
Pacpack.Add('https://github.com/vim-scripts/autodate.vim')
Pacpack.Add('https://github.com/whonore/Coqtail')

Pacpack.AddLazy('https://github.com/4513ECHO/nvim-keycastr')
Pacpack.AddLazy('https://github.com/lambdalisue/vim-suda')
# Pacpack.AddLazy('https://github.com/prabirshrestha/vim-lsp')
# Pacpack.AddLazy('https://github.com/mattn/vim-lsp-settings')
Pacpack.Add('https://github.com/kuuote/lspoints')
Pacpack.AddLazy('https://github.com/tweekmonster/helpful.vim')
Pacpack.AddLazy('https://github.com/y0za/vim-reading-vimrc')

# Operator-user plugins
Pacpack.AddLazy('https://github.com/kana/vim-operator-replace')
Pacpack.AddLazy('https://github.com/machakann/vim-sandwich')
Pacpack.AddLazy('https://github.com/osyo-manga/vim-operator-jump_side')
Pacpack.AddLazy('https://github.com/osyo-manga/vim-operator-swap')
# Pacpack.AddLazy('https://github.com/tyru/caw.vim')
Pacpack.AddLazy('https://github.com/mityu/caw.vim', {branch: 'support-vim9script-tmp'})  # tmp
Pacpack.AddLazy('https://github.com/sgur/vim-operator-openbrowser')

# Textobj-user plugins
Pacpack.AddLazy('https://github.com/kana/vim-textobj-entire')
Pacpack.AddLazy('https://github.com/kana/vim-textobj-function')
Pacpack.AddLazy('https://github.com/kana/vim-textobj-indent')
Pacpack.AddLazy('https://github.com/kana/vim-textobj-line')
Pacpack.AddLazy('https://github.com/mityu/vim-textobj-commentblock')
Pacpack.AddLazy('https://github.com/thinca/vim-textobj-between')

# Denops plugins
Pacpack.Add('https://github.com/vim-denops/denops.vim')
Pacpack.Add('https://github.com/vim-denops/denops-shared-server.vim')
# Pacpack.AddLazy('https://github.com/4513ECHO/parade.vim')
Pacpack.Add('https://github.com/vim-skk/skkeleton')
Pacpack.Add('https://github.com/skk-dev/dict')
Pacpack.Add('https://github.com/lambdalisue/vim-gin')
Pacpack.Add('https://github.com/lambdalisue/vim-fall')

# Ddu plugins
Pacpack.Add('https://github.com/lambdalisue/vim-mr')
Pacpack.Add('https://github.com/Shougo/ddu.vim')
Pacpack.Add('https://github.com/Shougo/ddu-ui-ff')
Pacpack.Add('https://github.com/Shougo/ddu-kind-file')
Pacpack.Add('https://github.com/Shougo/ddu-source-action')
Pacpack.Add('https://github.com/Shougo/ddu-source-file')
Pacpack.Add('https://github.com/Shougo/ddu-source-file_rec')
Pacpack.Add('https://github.com/Shougo/ddu-source-line')
Pacpack.Add('https://github.com/kuuote/ddu-source-mr')
Pacpack.Add('https://github.com/matsui54/ddu-source-file_external')
Pacpack.Add('https://github.com/matsui54/ddu-source-help')
Pacpack.Add('https://github.com/matsui54/ddu-source-man')
Pacpack.Add('https://github.com/mityu/ddu-filter-matcher_multi_regex')
Pacpack.Add('https://github.com/mityu/ddu-ui-ff_vim_popup')
Pacpack.Add('https://github.com/shun/ddu-source-buffer')
Pacpack.Add('https://github.com/shun/ddu-source-rg')
Pacpack.Add('https://github.com/tennashi/ddu-source-git')
Pacpack.Add('https://github.com/uga-rosa/ddu-source-lsp')

# Ddc plugins
Pacpack.Add('https://github.com/Shougo/ddc.vim')
Pacpack.Add('https://github.com/Shougo/ddc-ui-native')
Pacpack.Add('https://github.com/Shougo/ddc-source-lsp')
Pacpack.Add('https://github.com/Shougo/ddc-source-vim')
Pacpack.Add('https://github.com/Shougo/ddc-source-around')
Pacpack.Add('https://github.com/tani/ddc-fuzzy')

# Options {{{
if !exists('g:colors_name')  # Don't override colorscheme
  colorscheme domusaurea
endif
try
  language en_US.UTF-8
catch /^Vim\%((\a\+)\)\=:E197:/
  language C
catch
  EchomsgError(v:throwpoint)
  EchomsgError(v:exception)
  language C
endtry

if v:vim_did_enter
  command! -nargs=+ -bar Set setglobal <args>
else
  command! -nargs=+ -bar Set set <args>
endif
Set relativenumber number
Set wrap
# Set breakindent
Set noequalalways
Set scrolloff=1
Set colorcolumn=78
Set smartindent autoindent
Set cinoptions=:0,g0,N-s,E-s
Set tabstop=4 shiftwidth=4 softtabstop=4
Set expandtab smarttab
Set backspace=eol,start,indent
Set hlsearch
Set display=lastline
Set incsearch ignorecase
Set showmatch matchtime=1
Set cursorline cursorlineopt=number
Set showcmd
Set laststatus=2 showtabline=2
Set history=500 cmdheight=2 cmdwinheight=10
Set wildignore& wildmenu wildoptions=pum,fuzzy wildignore+=*.DS_STORE
Set helplang=ja keywordprg=:help
Set shortmess& shortmess+=Ic
Set hidden
Set autoread
Set diffopt=internal,algorithm:histogram
Set virtualedit=block
Set complete=.,i,d,w,b,u completeopt=menuone,noselect pumheight=10
Set noimdisable
Set lazyredraw
Set termwinkey=<C-w>
Set nowrapscan
Set noesckeys timeoutlen=3000 ttimeoutlen=100
Set isfname-==
Set spelllang& spelllang+=cjk
setglobal fileformat=unix
# Set fillchars& fillchars+=vert:\\u02502  # TODO: Set this once?
&listchars = 'tab:|-'
g:vim_indent = get(g:, 'vim_indent', {})
g:vim_indent.line_continuation = 'shiftwidth()'
# }}}


# IM control
if !has('gui_running')
  if IsWSL || IsWindows || IsWinUnix
    const exepath = Fs.JoinPath(Stdpath.cache, 'disableim.exe')
    if !executable(exepath)  # Build disableim.exe
      var csc = 'C:\Windows\Microsoft.Net\Framework64\v4.0.30319\csc.exe'
      var srcpath = Fs.JoinPath(Stdpath.dotvim, 'misc', 'disableim.cs')
      var outpath = $'{shellescape(exepath)}'  # Check with Unix path, compile with Windows path.
      var cmdopts = ['/optimize+', '/debug-', '/nologo', '/target:winexe']
      if IsWSL
        csc = $'$(wslpath -u {shellescape(csc)})'
        srcpath = $'$(wslpath -w {shellescape(srcpath)})'
        cmdopts->add('/utf8output')
      elseif IsWinUnix
        csc = string(csc)
        srcpath = $'$(cygpath -w {shellescape(srcpath)})'
        outpath = $'$(cygpath -w {shellescape(exepath)})'
      else
        srcpath = shellescape(srcpath)
      endif
      var cmd = join([csc] + cmdopts + [$'/out:{outpath}', srcpath])
      if IsWinUnix
        # Do not let MSYS2 to convert option argument (e.g. /nologo) into
        # Windows style path (e.g. C:\msys64\nologo)
        cmd = $'MSYS_NO_PATHCONV=1 MSYS2_ARG_CONV_EXCL="*" {cmd}'
      endif
      Echomsg('Building disableim.exe...')
      Echomsg(cmd)
      var output = system(cmd)
      if v:shell_error != 0
        EchomsgError('Compilation failed')
        EchomsgError(output)
      elseif IsWSL
        output = system($'chmod u+x {shellescape(exepath)}')
        if v:shell_error != 0
          EchomsgError('chmod failed')
          EchomsgError(output)
        endif
      endif
    endif
    if executable(exepath)
      augroup vimrc-auto-disableim
        execute $'autocmd InsertLeave * system({string(shellescape(exepath))})'
      augroup END
    endif
  endif
endif
if (IsLinux && !IsWSL) && executable('fcitx5-remote') == 1
  augroup vimrc-auto-disableim
    autocmd InsertLeave * system('fcitx5-remote -c')
  augroup END
endif


if has('kaoriya')
  set fileencodings=guess,utf-8
  set ambiwidth=auto
else
  set fileencodings=utf-8,euc-jp,cp932,sjis
  set ambiwidth=single
endif
if IsUnix
  set path& path+=/usr/local/include,/opt/homebrew/include
endif
if executable('rg')
  &grepprg = 'rg --vimgrep'
  &grepformat = '%f:%l:%c:%m'
elseif executable('ag')
  &grepprg = 'ag --vimgrep'
  &grepformat = '%f:%l:%c:%m'
endif

augroup vimrc
  autocmd BufRead .envrc set filetype=sh
  autocmd CursorHold * if getcmdwintype() ==# '' | checktime | endif
  autocmd VimResized * wincmd =
augroup END

if executable('chmod')
  # This hack is from github.com/thinca/config/dotfiles/dot.vim/vimrc. Thanks!
  augroup vimrc_autoexecutable
    autocmd BufWritePost * AddPermissionX()
  augroup END

  def AddPermissionX()
    const file = expand('%:p')
    if stridx(getline(1), '#!') == 0 && !executable(file)
      silent! call system('chmod a+x ' .. shellescape(file))
    endif
  enddef
endif

# From: https://zenn.dev/vim_jp/articles/f02adb4f325e51   Thanks!
augroup vimrc-validate-filename
  autocmd BufWritePre * ValidateFilename(expand('<afile>:t'))
augroup END

def ValidateFilename(filename: string)
  const invalid_chars = '!&()[]{}<>^*=+:;''",`~?|'
  for char in invalid_chars
    if stridx(filename, char) >= 0
      throw $'Filename has invalid char: {filename}'
    endif
  endfor

  const valid_pattern = '\.\?[[:alnum:]]\+$'
  if filename !~? valid_pattern
    throw $'Filename is invalid format: {filename}'
  endif
enddef

augroup vimrc-quickfix-window
  autocmd QuickfixCmdPost [^l]* cwindow
  autocmd QuickfixCmdPost l* lwindow
augroup END

augroup vimrc
  autocmd BufRead */vimdoc-ja-working/doc/*.jax
        \ b:autofmt_allow_over_tw = 1
        \ | setlocal formatoptions+=mM
        \ | autocmd Filetype <buffer> ++once HelpEdit
augroup END

# Mapping {{{
nnoremap : q:A
vnoremap : q:A
nnoremap <Space>: q:k
vnoremap <Space>: q:k
nnoremap / q/A
vnoremap / q/A
nnoremap <Space>/ q/k
vnoremap <Space>/ q/k
nnoremap ? q?A
vnoremap ? q?A
nnoremap <Space>? q?k
vnoremap <Space>? q?k
nnoremap <Space>; :
vnoremap <Space>; :
nmap ' :
vmap ' :

noremap - <C-x>
noremap + <C-a>
noremap ( [(
noremap ) ])
noremap j gj
noremap k gk
noremap gj j
noremap gk k

noremap <C-@> <ESC>
noremap! <C-@> <ESC>

nnoremap <expr> i getline('.') ==# '' && &l:modifiable ? "\"_S" : 'i'
nnoremap <expr> I getline('.') ==# '' && &l:modifiable ? "\"_S" : 'I'
nnoremap <expr> a getline('.') ==# '' && &l:modifiable ? "\"_S" : 'a'
nnoremap <expr> A getline('.') ==# '' && &l:modifiable ? "\"_S" : 'A'
nnoremap <CR> o<ESC>
nnoremap Y y$
nnoremap <C-h> <Cmd>nohlsearch<CR>
nnoremap <C-w>s <Cmd>belowright wincmd s<CR>
nnoremap <C-w><C-s> <Cmd>belowright wincmd s<CR>
nnoremap <C-w>v <Cmd>belowright wincmd v<CR>
nnoremap <C-w><C-v> <Cmd>belowright wincmd v<CR>
nnoremap <C-w>c <Cmd>belowright copen<CR>
nnoremap <C-w>t <Cmd>tabnew<CR>
nnoremap <C-w><C-t> <Cmd>tabnew<CR>
nnoremap <C-w>. <Cmd>copen<CR>
nnoremap <C-w>, <Cmd>lopen<CR>
nnoremap <Space>th <Cmd>vertical terminal ++close<CR>
nnoremap <Space>tj <Cmd>belowright terminal ++close<CR>
nnoremap <Space>tk <Cmd>terminal ++close<CR>
nnoremap <Space>tl <Cmd>belowright vertical terminal ++close<CR>
nnoremap <Space>tt <Cmd>tab terminal ++close<CR>
nnoremap <Space>w <Cmd>update<CR>
nnoremap <Space>q <C-w>q
nnoremap ZZ <Nop>
nnoremap ZQ <Nop>
nnoremap Q <Nop>
nnoremap <C-k> 7gk
nnoremap <C-j> 7gj
# Avoid textobj-function calls appearing on command history
nnoremap <silent> . .
nnoremap * *N
nnoremap <expr> n 'Nn'[v:searchforward]
nnoremap <expr> N 'nN'[v:searchforward]
nnoremap <Space>ev <Cmd>edit $MYVIMRC<CR>
nnoremap <Space>sv <Cmd>source $MYVIMRC<CR>
nnoremap <Space>j <Cmd>call <SID>GofForMapping()<CR>
nnoremap <Space>f <Cmd>call vimrc#filore#start()<CR>

nnoremap m <Nop>
vnoremap m <Nop>

nnoremap % <Cmd>packadd matchit<CR><Plug>(MatchitNormalForward)
xnoremap % <Cmd>packadd matchit<CR><Plug>(MatchitVisualForward)

inoremap <C-m> <C-g>u<C-m>
inoremap <C-u> <C-g>u<C-u>
inoremap <C-j> <C-g>u<C-j>
inoremap <C-l> <C-x>
inoremap <C-l><C-n> <C-x><C-n><C-n>
inoremap <C-l><C-p> <C-x><C-p><C-p>
inoremap <silent> <C-j> <C-r>=vimrc#pinsnip#Expand()<CR>
# TODO: Check 'paste' value?
inoremap <C-r>* <Cmd>set paste<CR><C-r>*<Cmd>set nopaste<CR>
inoremap <C-r>+ <Cmd>set paste<CR><C-r>+<Cmd>set nopaste<CR>

vnoremap g+ g<C-a>
vnoremap g- g<C-x>
vnoremap <C-k> 7gk
vnoremap <C-j> 7gj
vnoremap * <ESC>*Ngvne<Cmd>nohlsearch<CR>
vnoremap g* <ESC>g*Ngvne<Cmd>nohlsearch<CR>
vnoremap n n<Cmd>nohlsearch<CR>
vnoremap N N<Cmd>nohlsearch<CR>

cnoremap <C-l> <C-f>
cnoremap <C-f> <Right>
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>
cnoremap <C-b> <Left>
cnoremap <C-a> <C-b>
cnoremap <C-[> <C-c>
cnoremap <C-o> <Cmd>call cmdhistory#Select()<CR>

onoremap a" 2i"
onoremap a' 2i'
xnoremap a" 2i"
xnoremap a' 2i'

tnoremap <C-w>: <C-w>:<C-f>A
tnoremap <C-w><Space>: <C-w>:<C-f>k
tnoremap <C-w>; <C-w>:
tnoremap <C-w><ESC> <C-w>N
tnoremap <C-w>p <C-w>""
tnoremap <C-w><C-r> <C-w>"
tnoremap <C-w><C-t> <Cmd>tabnew<CR>
tnoremap <C-w><C-w> <C-w>.
tnoremap <C-@> <ESC>
for c in 'tnsvq'
  execute $'tnoremap <C-w>{c} <C-w>.{c}'
endfor

if IsMac && has('gui_running')
  noremap <D-[> <ESC>
  noremap! <D-[> <ESC>
endif
# }}}

augroup vimrc
  autocmd User vimrc_initialize ++once DefineLoopMappings()
augroup END

def DefineLoopMappings()
  const sid = SIDPrefix()
  vimrc#loopmap#SimpleLoopDefine({
    id: 'Window',
    enter_with: '<C-w>',
    follow_key: '<>-+',
  })
  vimrc#loopmap#LoopDefine({
    id: 'Tab',
    enter_with: 'g',
    body: [
      ['h', 'gT'],
      ['l', 'gt'],
      ['T', $'<Cmd>call {sid}MapTabmove(-1)<CR>'],
      ['t', $'<Cmd>call {sid}MapTabmove(1)<CR>'],
    ]
  })
enddef

def MapTabmove(delta: number)
  const tab_count = tabpagenr('$')
  if tab_count == 1
    return
  endif
  const current = tabpagenr() - 1
  var move_to = current + delta
  if move_to < 0
    while move_to < 0
      move_to += tab_count
    endwhile
  endif
  if move_to >= tab_count
    move_to = move_to % tab_count
  endif
  const movement = move_to - current
  var movecmd = 'tabmove '
  if movement < 0
    movecmd ..= string(movement)
  else
    movecmd ..= '+' .. string(movement)
  endif
  execute movecmd
enddef

def CmdwinEnter()
  # Type <CR> to execute current line in command-line window.
  # This mapping is overwritten when ambicmd.vim is installed.
  nnoremap <buffer> <CR> <CR>

  # Return back to the current window from command-line window with
  # inputting <C-c> once.
  nnoremap <buffer> <C-c> <Cmd>quit<CR>
  nnoremap <buffer> q <Cmd>quit<CR>
  inoremap <buffer> <C-c> <ESC><Cmd>quit<CR>

  nnoremap <buffer> : :
  xnoremap <buffer> : :
  inoremap <buffer> <C-l><C-n> <C-x><C-n>
  inoremap <buffer> <C-l><C-p> <C-x><C-n>

  # Make executing a previous command easier.
  if Pacpack.Tap('vim-cmdhistory')
    nnoremap <buffer> / <Cmd>call cmdhistory#Select()<CR>
  endif

  if Pacpack.Tap('vim-winc')
    winc#Setup()
  endif

  # Disable auto completions in cmdwin.
  if exists('g:asyncomplete_loaded') && g:asyncomplete_loaded
    asyncomplete#disable_for_buffer()
  endif
  if Pacpack.Tap('ddc.vim')
    ddc#custom#patch_buffer('specialBufferCompletion', false)
  endif

  const cmdwin_type = expand('<afile>')
  if cmdwin_type ==# ':'
    inoremap <expr> <buffer> <C-p> <SID>CmdwinCompletion(0)
    inoremap <expr> <buffer> <C-n> <SID>CmdwinCompletion(1)
    setlocal completeopt=menu,preview
    if line('$') >= &cmdwinheight
      execute $':silent! :1,$-{&cmdwinheight} delete _'
      normal! G
      &undolevels = &undolevels  # Separate undo sequence
    endif
  endif
enddef

def CmdwinCompletion(select_next: bool): string
  if pumvisible()
    return select_next ? "\<C-n>" : "\<C-p>"
  else
    return "\<C-x>\<C-v>" .. (select_next ? "" : "\<C-p>\<C-p>")
  endif
enddef

augroup vimrc-cmdwin
  autocmd CmdWinEnter * call CmdwinEnter()
augroup END

if IsMac
  g:mapleader = '_'
endif

# Abbreviates
inoreabbrev todo: TODO:
inoreabbrev fixme: FIXME:
inoreabbrev xxx: XXX:
inoreabbrev note: NOTE:

# Completion
augroup vimrc-ins-completion
  autocmd CompleteDonePre * {
    if !empty(v:completed_item) && complete_info()->get('mode', '') ==# 'whole_line'
      &g:undolevels = &g:undolevels
      setline('.', getline('.')->strpart(0, col('.') - 1))
    endif
  }
augroup END

# Commands
# Declarations
command! -bar CdCurrent cd %:p:h
command! -bar LcdCurrent lcd %:p:h
command! -bar TcdCurrent tcd %:p:h
command! -bar CdRoot call vimrc#CdProjectRoot('cd')
command! -bar LcdRoot call vimrc#CdProjectRoot('lcd')
command! -bar TcdRoot call vimrc#CdProjectRoot('tcd')
command! -bar FileName echo expand('%:p')
command! -nargs=1 -complete=file Rename file <args>|call delete(expand('#'))|setlocal modified
command! -nargs=? CopyToClipboard call setreg('+', getreg(<q-args>, 1))
command! -bar -nargs=? ClipBuffer call vimrc#Clipbuffer(<q-args>)
command! ClearMessage messages clear
command! -bang -nargs=+ -complete=command Filter call Filter(<bang>0, <f-args>)
command! -bar Draft setlocal buftype=nofile noswapfile noundofile
command! -bar -nargs=+ -complete=command Vimrc <args> $MYVIMRC
command! -bar -nargs=* -complete=file ListTasks call vimrc#ListTasks(<q-args>)
command! DeleteUndoFiles call vimrc#DeleteUndofiles()
command! -nargs=? -complete=dir Gof call Gof(<q-args>)
command! -bar -nargs=? -complete=dir GitInitRepo call vimrc#GitInitRepo(<q-args>)
command! -bar LocalPackUpdate call vimrc#UpdateLocalPackages()
command! -nargs=+ -complete=shellcmd Man delcommand Man|runtime ftplugin/man.vim|Man <args>
command! -nargs=? -complete=filetype TMP enew|Draft|execute (<q-args> ==# '' ? '' : 'setfiletype <args>')
command! -bar -nargs=+ -complete=dir SysOpen vimrc#DefineOpenCommand()|SysOpen <args>
command! -bar Hlgroup vimrc#ShowHighlightGroup()
command! -bar HighlightGroup Hlgroup
command! -bar RTP echo &runtimepath->split(',')->join("\n")
command! -bar -nargs=? -complete=dir Filore call vimrc#filore#start(<q-args>)

def Filter(bang: bool, pat: string, ...cmd: list<string>)
  const output = execute(join(cmd, ' '))
                ->split("\n")
                ->filter((_: number, val: string): bool => val =~? pat)
                ->join("\n")
  if bang
    echomsg output
  else
    echo output
  endif
enddef

def FindGitroot(arg_target: string = bufname('%')->fnamemodify(':p')): string
  const target: string = resolve(arg_target)
  const git_dir: string = finddir('.git', target .. ';')
  if git_dir ==# ''
    return ''
  endif
  return fnamemodify(git_dir, ':p:h:h')
enddef

def Gof(path: string)
  if !executable('gof')
    Echo('"gof" command not found.')
    return
  endif
  var gofcmd = 'gof -f -tf "Tapi_gof"'
  if !empty(path)
    gofcmd ..= ' -d ' .. path
  endif
  const minwidth = min([&columns, 100])
  const minheight = min([&lines, 40])
  popup_create(term_start(gofcmd, {hidden: 1, term_finish: 'close'}),
        \ {minwidth: minwidth, minheight: minheight})
enddef

def GofForMapping()
  Gof(FindGitroot() ?? getcwd(winnr()))
enddef

def g:Tapi_gof(bufnum: number, file_info: dict<string>)  # Be global
  const winid = win_getid(winnr('#'))
  const buftype = getwinvar(winid, '&buftype')
  var open_cmd = 'edit'
  if !(buftype ==# 'nofile' || buftype ==# '')
    open_cmd = 'split'
  endif
  win_execute(winid, open_cmd .. ' ' .. fnameescape(file_info.fullpath))
enddef

# Installed plugins
if Pacpack.Tap('vim-cursorword')
  g:cursorword_highlight = 0
  augroup vimrc_cursorword
    autocmd ColorScheme * highlight CursorWord gui=underline cterm=underline term=underline guibg=NONE ctermbg=NONE
  augroup END
  doautocmd vimrc_cursorword ColorScheme
endif

if Pacpack.Tap('vim-altr')
  command! -bar AlterForward call altr#forward()
  command! -bar AlterBack call altr#back()
endif

if Pacpack.Tap('vim-ripgrep')
  def RipGrep(argsGiven: string)
    var cwd = FindGitroot() ?? getcwd(winnr())
    cwd = Input('Grep here? ', cwd, 'dir')->expand()
    if !cwd->isdirectory()
      EchomsgError($'Directory not exist: {cwd}')
      return
    endif
    var args = argsGiven
    if args ==# ''
      args = Input('Search pattern: ')
    endif
    ripgrep#call($'rg --json -w -i {args}', cwd, fnamemodify(cwd, ':.') .. Fs.slash)
  enddef

  command! -nargs=? -complete=file RipGrep RipGrep(<q-args>)
endif

if Pacpack.Tap('vim-fern')
  g:fern#disable_default_mappings = 1
  g:fern#default_exclude = '.DS_Store'
  g:fern#renderer = 'nerdfont'
  g:fern#renderer#nerdfont#padding = '  '


  def FernOnOpen()
    nnoremap <buffer> <expr> o fern#smart#leaf(
          \ '<Nop>',
          \ '<Plug>(fern-action-expand:stay)',
          \ '<Plug>(fern-action-collapse)'
          \ )
    nnoremap <buffer> h <Plug>(fern-action-leave)
    nnoremap <buffer> l <Plug>(fern-action-enter)
    nnoremap <buffer> <CR> <Plug>(fern-action-open:edit-or-error)
    nnoremap <buffer> x <Plug>(fern-action-hidden:toggle)
    nnoremap <buffer> m <Plug>(fern-action-mark:toggle)
    nnoremap <buffer> <Tab> <Plug>(fern-action-choice)
    nnoremap <buffer> <C-l> <Plug>(fern-action-reload:all)
    nnoremap <buffer> <expr> <silent> <C-g> fern#smart#scheme('<C-g>',
          \ {'file': '<Cmd>call fern#helper#call("<SID>FernShowRootPath")<CR>'})
    nnoremap <buffer> q <Cmd>call <SID>FernClose()<CR>
  enddef

  def FernOnHighlight()
    if g:fern#renderer ==# 'nerdfont'
      if g:colors_name !=# 'domusaurea'
        highlight! link FernLeafSymbol Directory
        highlight! link FernBranchSymbol Directory
        highlight! link FernBranchText Directory
      endif
    else
      highlight! link FernLeafSymbol Title
      highlight! link FernBranchSymbol Title
      highlight! link FernBranchText Directory
    endif
    highlight! link FernRootText Normal
  enddef

  def FernSetAltbufOnOpen()
    if !exists('w:vimrc_fern_altbuf')
      var altbuf = bufnr('#')
      if altbuf == bufnr('%')
        altbuf = -1
      endif
      w:vimrc_fern_altbuf = altbuf
    endif
  enddef

  def FernSetAltbufOnClone()
    if !exists('w:vimrc_fern_altbuf')
      const altbuf = win_getid(winnr('#'))->getwinvar('vimrc_fern_altbuf', null)
      if altbuf != null
        w:vimrc_fern_altbuf = altbuf
      endif
    endif
  enddef

  def FernUnsetAltbufOnLeave()
    # BufWinLeave is also happens when entering another directory.  Postpone
    # unletting w:vimrc_fern_altbuf by the next BufEnter autocmd.
    autocmd vimrc-fern BufEnter * ++once {
      if exists('w:vimrc_fern_altbuf') && bufname() !~# '^fern://'
        unlet w:vimrc_fern_altbuf
      endif
    }
  enddef

  def FernClose()
    if exists('w:vimrc_fern_altbuf') &&
        buflisted(w:vimrc_fern_altbuf)
      execute 'buffer' w:vimrc_fern_altbuf
    else
      enew
    endif
  enddef

  def FernShowRootPath(helper: dict<any>)
    call helper.sync.echo('[fern] ' .. helper.fern.root._path)
  enddef

  def FernGetLaunchPath(): string
    if expand('%') !=# '' && &buftype ==# '' && &buflisted
      return expand('%:h')
    endif
    return getcwd(winnr())
  enddef

  augroup vimrc-fern
    # User configuration.
    autocmd FileType fern FernOnOpen()
    autocmd User FernHighlight FernOnHighlight()

    # Manage alternative buffer number.
    # NOTE: It seems WinNew autocmd for fern:// buffer is fired before
    # FileType autocmd for fern.
    autocmd WinNew fern://* FernSetAltbufOnClone()
    autocmd FileType fern FernSetAltbufOnOpen()
    autocmd BufWinLeave fern//* FernUnsetAltbufOnLeave()
  augroup END

  nnoremap <Space>f <Cmd>Fern `=<SID>FernGetLaunchPath()`<CR>
endif

if Pacpack.Tap('vim-findent')
  augroup vimrc_findent
    autocmd FileType * MayDoFindent()
  augroup END

  def MayDoFindent()
    const rejectBuftypes = ['quickfix', 'help', 'terminal', 'prompt', 'popup']
    if !&l:modifiable || &l:filetype ==# 'help' || index(rejectBuftypes, &l:buftype) != -1
      return
    endif

    execute 'Findent'
  enddef
endif

if Pacpack.Tap('vim-alith')
  augroup vimrc_alith
    autocmd ColorScheme * highlight AlithMatchHead gui=reverse cterm=reverse term=reverse
  augroup END
  highlight AlithMatchHead gui=reverse cterm=reverse term=reverse
endif

if Pacpack.Tap('vim-backpair')
  def BackpairCursorForward(): string
    var m = "\<Cmd>call backpair#clear_state()\<CR>"
    if col('.') < col('$')
      m ..= "\<C-g>U\<Right>"
    endif
    return m
  enddef

  def BackpairCursorBackward(): string
    var m = "\<Cmd>call backpair#clear_state()\<CR>"
    if col('.') > 1
      m ..= "\<C-g>U\<Left>"
    endif
    return m
  enddef

  inoremap <expr> <C-f> BackpairCursorForward()
  inoremap <expr> <C-b> BackpairCursorBackward()

  def BackpairConfig()
    backpair#add_pair('(', ')')
    backpair#add_pair('[', ']', {skip_if_ongoing: ['[[]']})
    backpair#add_pair('<', '>')
    backpair#add_pair('{', '}')
    backpair#add_pair('"', '"')
    backpair#add_pair("'", "'")
    backpair#add_pair('\(', '\)')
    backpair#add_pair('\%(', '\)')
    backpair#add_pair('[[', ']]')
    backpair#add_pair('({', '})')
    backpair#add_pair('{', '})', {skip_if_ongoing: ['({})']})
    backpair#add_pair('`', '`', {condition: (): bool => trim(getline('.')) !=# '``'})
    backpair#add_pair('(', ');')
    backpair#add_pair('[', '];')
    backpair#add_pair('{', '};')
    backpair#add_pair('"', '";')
    backpair#add_pair("'", "';")
    backpair#add_pair('({', '});')
    backpair#add_pair('{', '});', {skip_if_ongoing: ['({});']})
  enddef

  augroup vimrc-plugin-backpair
    autocmd InsertEnter * ++once backpair#enable()
    autocmd User backpair-initialize BackpairConfig()
  augroup END
endif

if Pacpack.Tap('vim-charjump')
  noremap f <Plug>(charjump-inclusive-forward)
  noremap F <Plug>(charjump-inclusive-backward)
  noremap t <Plug>(charjump-exclusive-forward)
  noremap T <Plug>(charjump-exclusive-backward)
  noremap ; <Plug>(charjump-repeat-obverse)
  noremap , <Plug>(charjump-repeat-reverse)
endif

if Pacpack.Tap('vim-cmdhistory')
  augroup vimrc-cmdhistory
    autocmd User cmdhistory-initialize SetupCmdhistory()
  augroup END
  def SetupCmdhistory()
    cmdhistory#SetDefaultMappings()
    cmdhistory#MapAction('<ESC>', ['no-operation'])
    cmdhistory#MapAction('<C-@>', ['no-operation'])
  enddef
endif

if Pacpack.Tap('vim-cobachi')
  g:cobachi_default_opts = {
    filter: (text: string, items: list<string>): list<any> => cobachi#filter#Regex(text, items),
    action: (item: string) => execute($'edit {fnameescape(item)}')
  }

  def CobachiConfig()
    nnoremap <buffer> i <Cmd>call cobachi#DoAction('start-filtering')<CR>
    nnoremap <buffer> <CR> <Cmd>call cobachi#DoAction('accept')<CR>
    nnoremap <buffer> q <Cmd>call cobachi#DoAction('quit')<CR>
  enddef

  augroup vimrc
    autocmd Filetype cobachi CobachiConfig()
  augroup END


  def CobachiMru()
    if !Pacpack.Tap('vim-mr')
      EchomsgError('mr.vim is not installed.')
      return
    endif
    const Fn = (): list<string> =>
      mr#mru#list()->map((idx: number, v: string): string => v->fnamemodify(':~'))
    cobachi#Filter({source: Fn})
  enddef

  command! CobachiMru CobachiMru()
endif

if Pacpack.Tap('vim-gyoza')
  g:gyoza_disable_auto_setup = 1

  def GyozaLoadRules(filetype: string)
    gyoza#config#load_rules_for_filetype(filetype)
    gyoza#builtin_rules#load_all_rules_for_filetype(filetype)
  enddef

  def GyozaExtendRules(dst: string, src: string)
    var stack = gyoza#config#get_rules_for_filetype(dst)
    GyozaLoadRules(src)
    stack.extend_rules(gyoza#config#get_rules_for_filetype(src))
  enddef

  augroup vimrc-gyoza
    autocmd!
    autocmd InsertEnter * ++once gyoza#enable()
    autocmd InsertEnter * ++once GyozaLoadRules('_')
    autocmd FileType * GyozaLoadRules(expand('<amatch>'))
    autocmd FileType vimspec ++once GyozaExtendRules('vimspec', 'vim')
    autocmd FileType cpp ++once GyozaExtendRules('cpp', 'c')
    autocmd FileType bash,zsh ++once GyozaExtendRules(expand('<amatch>'), 'sh')
  augroup END
endif

if Pacpack.Tap('vim-wispath')
  inoremap <C-l><C-f> <Plug>(wispath-complete)
endif

if Pacpack.Tap('vim-jplus')
  noremap J <Plug>(jplus)
endif

if Pacpack.Tap('previm')
  g:previm_show_header = 0
  g:previm_enable_realtime = 1
  if IsWSL
    g:previm_open_cmd = '/mnt/c/Program Files/Google/Chrome/Application/chrome.exe'
  endif
endif

if Pacpack.Tap('vim-ambicmd')
  def AmbicmdExpand(key: string): string
    const expander = ambicmd#expand(key)
    return (expander ==# key ? '' : "\<C-g>u") .. expander
  enddef
  augroup vimrc_ambicmd
    autocmd CmdWinEnter : call SetupAmbicmdForCmdwin()
  augroup END
  cnoremap <expr> <Space> ambicmd#expand("\<Space>")
  cnoremap <expr> <CR> ambicmd#expand("\<CR>")
  cnoremap <expr> <bar> ambicmd#expand("\<bar>")

  def SetupAmbicmdForCmdwin()
    inoremap <buffer> <expr> <Space> <SID>AmbicmdExpand("\<Space>")
    inoremap <buffer> <expr> <bar> <SID>AmbicmdExpand("\<bar>")
    inoremap <buffer> <expr> <CR> <SID>AmbicmdExpand("\<CR>")
    inoremap <buffer> <expr> <C-j> <SID>AmbicmdExpand('')
  enddef

  g:ambicmd#show_completion_menu = 1

  def AmbicmdBuildRule(cmd: string): list<string>
    var rule = []
    rule += ['\c^' .. cmd .. '$']
    rule += ['\c^' .. cmd]

    for len in range(1, strlen(cmd))
      const prefix = strpart(cmd, 0, len)->toupper()->substitute('.\zs', '.\\{-}', 'g')
      const suffix = cmd[len :]
      const matcher = '\C^' .. prefix .. suffix
      rule += [matcher .. '$', matcher]
    endfor

    rule += ['\c' .. cmd]
    rule += ['.\\{-}' .. substitute(cmd, '.\zs', '.\\{-}', 'g')]
    return rule
  enddef
  g:ambicmd#build_rule = AmbicmdBuildRule
endif

if Pacpack.Tap('vim-quickrun')
  g:quickrun_config = {}
  g:quickrun_config['_'] = {
    ['outputter']: 'multi',
    ['outputter/multi/targets']: ['buffer', 'error'],
    ['outputter/error/success']: 'buffer',
    ['outputter/error/error']: 'quickfix',
    ['outputter/buffer/close_on_empty']: 1,
    runner: 'job',
  }

  g:quickrun_config.cpp = {
    cmdopt: '-std=c++20'
  }
  g:quickrun_config.go = {
    command: 'go',
    cmdopt: '-mod=mod',
    exec: '%c run %s:p:t %a',
    tempfile: '%{tempname()}.go',
    ['hook/cd/directory']: '%S:p:h',
    ['hook/output_encode/encoding']: 'utf-8',
  }
  g:quickrun_config['go/full'] = {
    command: 'go',
    cmdopt: '-mod=mod',
    exec: ['%c mod init quickrun%s:p:t:r', '%c mod tidy', '%c run %s:p:t %a'],
    tempfile: '%{tempname()}.go',
    ['hook/cd/directory']: '%S:p:h',
    ['hook/sweep/files']: ['%S:p:h/go.mod', '%S:p:h/go.sum'],
    ['hook/output_encode/encoding']: 'utf-8',
  }
  g:quickrun_config.objc = {
    command: 'cc',
    execute: ['%c %s -o %s:p:r -framework Foundation', '%s:p:r %a', 'rm -f %s:p:r'],
    tempfile: '%{tempname()}.m',
  }
  g:quickrun_config.applescript = {
    command: 'osascript',
    execute: '%c %s:p',
    tempfile: '%{tempname()}.applescript',
  }
  g:quickrun_config.python = {
    command: 'python3',
    ['hook/eval/template']: 'print(%s)',
  }
  if Pacpack.Tap('vim-quickrun-hook-auto_run_in_vim9')
    g:quickrun_config.vim = {
      ['hook/auto_run_in_vim9/enable']: 1,
    }
  endif

  if executable('deno')
    # If deno doesn't exist, use quickrun's default config. It has configs for
    # other typescript runners.
    # To use deno without type checking, do :Quickrun typescript/deno.
    g:quickrun_config.typescript = {
      type: 'typescript/deno-check'
    }

    g:quickrun_config['typescript/deno-check'] = {
      command: 'deno',
      cmdopt: '--check --allow-all',
      tempfile: '%{tempname()}.ts',
      exec: ['%c run %o %s'],
    }
  endif

  g:quickrun_config.tex = {
    type: 'tex/platex'
  }

  {
    var opencmd: string
    if IsWindows
      opencmd = 'explorer'
    elseif IsMac
      opencmd = 'open'
    else
      opencmd = 'xdg-open'
    endif
    const openpdfcmd = printf('%s %%s:p:r.pdf', opencmd)

    const sweepfiles: list<string> =
      ['.aux', '.log', '.dvi', '.out', '.pdf']
      ->map((_: number, v: string): string => '%S:p:r' .. v)

    g:quickrun_config['tex/platex'] = {
      command: 'platex',
      exec: ['%c %a %s', 'dvipdfmx %s:p:r.dvi', openpdfcmd],
      tempfile: '%{tempname()}.tex',
      ['hook/sweep/files']: sweepfiles,
      ['hook/cd/directory']: '%S:p:h',
    }
  }

  if IsWSL
    g:quickrun_config.dosbatch = {
      command: 'cmd.exe',
      exec: '%c /Q /c \$(wslpath -w %s) %a'
    }
  endif

  nnoremap <expr> <C-c> quickrun#session#exists() ?
        \ '<Cmd>call quickrun#session#sweep()<CR>' :
        \ '<C-c>'
  nnoremap <Space>r <Plug>(quickrun)
  vnoremap <Space>r <Plug>(quickrun)

  def QuickrunSetupHook()
    quickrun#module#register({
      kind: 'hook',
      name: 'vimrc_autoclose_quickfix',
      on_success: (_, _) => execute('cclose')
    }, true)
  enddef

  augroup vimrc_quickrun
    autocmd SourcePost */autoload/quickrun.vim ++once QuickrunSetupHook()
    autocmd FileType quickrun nnoremap <buffer> q <C-w>q
    autocmd CmdwinEnter *
    \ noremap <buffer> <Plug>(quickrun) <Cmd>echo ':QuickRun is disabled in cmdwin.'<CR>
    autocmd FileType quickrun {
      matchadd('Conceal', '\e[\d\+m', 10, -1, {conceal: ''})
      setlocal conceallevel=3 concealcursor=nvic
    }
  augroup END
endif

if Pacpack.Tap('capture.vim')
  augroup vimrc
    autocmd Filetype capture nnoremap <buffer> q <C-w>q
  augroup END
endif

if Pacpack.Tap('open-browser.vim') && !v:vim_did_enter
  augroup vimrc_openbrowser
    autocmd SourcePost */plugin/openbrowser.vim
          \ command! -nargs=* OpenBrowser call OpenBrowser(<q-args>)
  augroup END

  # :OpenBrowser         => Read URL from the default register
  # :OpenBrowser @*      => Read URL from the specified register
  # :OpenBrowser {URL}   => Just use {URL}
  def OpenBrowser(cmdarg: string)
    var uri = trim(cmdarg)
    var reg = ''
    if uri ==# ''
      reg = v:register
    elseif uri[0] ==# '@' && strlen(uri) == 2
      reg = uri[1]
    endif
    if reg !=# ''
      uri = getreg(reg)
      if uri ==# ''
        EchomsgError(printf('Register @%s is empty.', reg))
        return
      endif
    endif
    openbrowser#open(uri)
  enddef
endif

if Pacpack.Tap('autofmt')
  Set formatexpr=autofmt#japanese#formatexpr()
endif

if Pacpack.Tap('lspoints')
  var LspointsAttachRequests: list<dict<any>> = []

  def LspointsExecCmd(...cmd: list<any>)
    denops#notify('lspoints', 'executeCommand', cmd)
  enddef

  def LspointsExecCmdSync(...cmd: list<any>)
    denops#request('lspoints', 'executeCommand', cmd)
  enddef

  def LspointsGetAttachParams(): dict<any>
    return {
      bufnr: bufnr('%'),
      bufname: expand('%:p'),
      filetype: &l:filetype,
      pwd: getcwd(0),
    }
  enddef

  def LspointsAttachLater(ctx: dict<any>)
    LspointsAttachRequests->add(ctx)
  enddef

  def LspointsAttachPostponed()
    var requests = []
    var fired = {}

    for r in LspointsAttachRequests->reverse()
      if fired->has_key(r.bufnr) || !bufexists(r.bufnr)
        continue
      endif
      fired[r.bufnr] = true
      requests->add(r)
    endfor

    for r in requests->reverse()
      LspointsAttach(r)
    endfor
  enddef

  def LspointsAttach(ctx: dict<any>)
    LspointsExecCmd('config', 'attachLsp', ctx)
  enddef

  def LspointsOnAttach()
    const [server, bufnrStr] =
      expand('<amatch>')->matchlist('^LspointsAttach:\(.*\):\(\d*\)$')[1 : 2]
    const bufnr = str2nr(bufnrStr)

    if Pacpack.Tap('vim-notification')
      notification#show($"{pathshorten(bufname(bufnr))}\nServer attached: {server}")
    else
      echo 'Server attached:' server
    endif

    if bufnr == bufnr()
      LspointsConfigForBuffer(server)
    else
      augroup vimrc-lspoints
        execute $'autocmd! BufEnter <buffer={bufnr}>'
        execute $'autocmd BufEnter <buffer={bufnr}> LspointsConfigForBuffer("{server}")'
      augroup END
    endif
  enddef

  def LspointsOnDetach()
    const server = expand('<amatch>')->matchstr('^LspointsDetach:\zs.*$')
    if Pacpack.Tap('vim-notification')
      notification#show($'Server detached: {server}')
    else
      echo 'Server detached:' server
    endif
  enddef

  def LspointsConfigForBuffer(server: string)
    nnoremap <buffer> <C-g> <Cmd>call <SID>LspointsExecCmd('hover', 'float')<CR><C-g>
    nnoremap <buffer> <Space>i <Cmd>call <SID>LspointsExecCmd('signatureHelp', 'float')<CR>
    autocmd vimrc-lspoints CursorHold <buffer>
      \ LspointsExecCmd('diagnostics', 'show', {
      \   silent: true,
      \   previewer: "popup",
      \ })

    if server =~# '\v^%(denols|gopls|rust-analyzer)$'
      autocmd vimrc-lspoints BufWritePre <buffer> LspFmt
    elseif server ==# 'clangd'
      if findfile('.clang-format', $'{expand('%:p')};') !=# ''
        autocmd vimrc-lspoints BufWritePre <buffer> LspFmt
      endif
    endif
  enddef

  g:lspoints#extensions = ['diagnostics', 'format', 'hover', 'signature_help', 'config']

  command! -bar LspFmt LspointsExecCmdSync('format', 'execute', bufnr())|redraw
  command! -bar LspAttach LspointsExecCmd('config', 'attachLsp', LspointsGetAttachParams())
  command! -bar LspointsRestart lspoints#reload()
  command! -bar -nargs=? LspShowDiag LspointsExecCmd('diagnostics', 'show', {previewer: <q-args> ?? "popup"})

  def LspointsSetupAttachAutocmds()
    augroup vimrc-lspoints
      autocmd!
      autocmd User DenopsReady lspoints#denops#register()
      autocmd User LspointsAttach:* LspointsOnAttach()
      autocmd User LspointsDetach:* LspointsOnDetach()
      autocmd User DenopsPluginUnloadPre:lspoints LspointsSetupAttachAutocmds()

      if !v:vim_did_enter || !denops#plugin#is_loaded('lspoints')
        autocmd FileType * LspointsAttachLater(LspointsGetAttachParams())
        autocmd User DenopsPluginPost:lspoints {
          LspointsAttachPostponed()
          autocmd! vimrc-lspoints FileType
          autocmd vimrc-lspoints FileType * LspointsAttach(LspointsGetAttachParams())
        }
      else
        autocmd FileType * LspointsAttach(LspointsGetAttachParams())
      endif
    augroup END
  enddef

  LspointsSetupAttachAutocmds()
endif

if Pacpack.Tap('lsp')
  augroup vimrc
    autocmd ColorScheme * LspHighlight()
    if !v:vim_did_enter
      autocmd User vimrc_initialize ++once LspHighlight()
    endif
    autocmd User LspSetup ++once LspSetup()
    autocmd User LspAttached LspAttached()
  augroup END

  command! -bar LspStatus LspServer show status

  def LspGetDiagCounts(bufnr: number = bufnr()): dict<number>
    var counts = [0, 0, 0, 0]
    const diags = lsp#diag#GetDiagsForBuf(bufnr)

    for diag in diags
      const severity = diag.severity > 4 ? 3 : diag.severity - 1
      ++counts[severity]
    endfor

    return {
      error: counts[0],
      warning: counts[1],
      info: counts[2],
      hint: counts[3],
    }
  enddef

  def LspSetup()
    g:LspOptionsSet({
      autoPopulateDiags: true,
      completionMatcher: 'fuzzy',
      diagVirtualTextAlign: 'after',
      diagVirtualTextWrap: 'truncate',
      showDiagWithVirtualText: true,
    })
  enddef

  def LspAttached()
    setlocal omnifunc=g:LspOmniFunc
    setlocal tagfunc=lsp#lsp#TagFunc

    nnoremap <buffer> <Space>i <Cmd>LspDiag current<CR>
    nnoremap <buffer> <Up> <Cmd>LspDiag prev<CR>
    nnoremap <buffer> <Down> <Cmd>LspDiag next<CR>
    nnoremap <buffer> <C-g> <Cmd>LspHover<CR><C-g>
    if &l:filetype !~# '\<vim\%(spec\)\?\>'
      nnoremap <buffer> gd <Cmd>LspGotoDeclaration<CR>
      setlocal keywordprg=:LspHover
      SetUndoFtplugin nunmap <buffer> gd
      SetUndoFtplugin setlocal keywordprg<
    endif

    augroup vimrc-lsp-buffer
      autocmd!
      autocmd BufWritePre <buffer> LspFormat
      autocmd BufWritePre <buffer> LspNotifyDiagnosticCount()
    augroup END

    SetUndoFtplugin setlocal omnifunc< tagfunc<
    SetUndoFtplugin nunmap <buffer> <Space>i
    SetUndoFtplugin nunmap <buffer> <Up>
    SetUndoFtplugin nunmap <buffer> <Down>
    SetUndoFtplugin nunmap <buffer> <C-g>
    SetUndoFtplugin autocmd! vimrc-lsp-buffer
  enddef

  def LspHighlight()
    highlight link LspDiagVirtualTextError Error
    highlight link LspDiagVirtualTextWarning WarningMsg
    highlight link LspDiagVirtualTextHint Normal
    highlight link LspDiagVirtualTextInfo Normal
    highlight link LspSigActiveParameter String
  enddef

  def LspNotifyDiagnosticCount()
    if !Pacpack.Tap('vim-notification')
      return
    endif

    const counts = LspGetDiagCounts()
    if (counts.error + counts.warning) == 0
      return
    endif

    notification#show({
      text: $"LSP\nError: {counts.error}  Warning: {counts.warning}",
      clicked: function('execute', ['lopen']),
      wait: 10000,
    })
  enddef
endif

if Pacpack.Tap('asyncomplete.vim')
  def AsyncompletePreprocessor(context: dict<any>, matches_dict: dict<any>)
    var base = tolower(context.base)
    var completions: list<dict<any>>
    var subcompletions: list<dict<any>>
    var fuzzycompletions: list<dict<any>>

    if trim(context.base) !=# ''
      for matches in values(matches_dict)
        for candidate in matches.items
          var idx = stridx(tolower(candidate.word), base)
          if idx == -1
            continue
          elseif idx == 0
            add(completions, candidate)
          else
            add(subcompletions, candidate)
          endif
        endfor
      endfor
    endif
    completions += subcompletions

    if !empty(completions)
      asyncomplete#preprocess_complete(context, completions)
      return
    endif

    # Workaround; matchfuzzy() always returns list<string>
    var items: list<any> =
          matches_dict->values()->mapnew((_, val): list<any> => val.items)->flattennew()

    if trim(context.base) !=# ''
      items = matchfuzzy(items, context.base, {key: 'word'})
    endif
    asyncomplete#preprocess_complete(context, items)
  enddef

  g:asyncomplete_auto_popup = 1
  g:asyncomplete_preprocessor = [AsyncompletePreprocessor]
  g:asyncomplete_auto_completeopt = 0
endif

if Pacpack.Tap('vim-lsp')
  # Lazy-loading
  augroup vimrc_lsp_lazyload
    autocmd BufReadPre * LoadLspPlugins()
    autocmd BufNewFile * {
      LoadLspPlugins()
      doautocmd lsp BufNewFile
    }
    if !v:vim_did_enter
      autocmd VimEnter * {
        # Do not load lsp plugins on git commit
        if argc() != 0 && argv()[0] !~# '\<COMMIT_EDITMSG\>$'
          LoadLspPlugins()
          doautocmd lsp BufReadPost
        endif
      }
    endif
  augroup END

  def LoadLspPlugins()
    # Load completion plugin first.
    if Pacpack.Tap('asyncomplete.vim')
      # asyncomplete-lsp.vim must be loaded before asyncomplete.vim
      if Pacpack.Tap('asyncomplete-lsp.vim')
        Pacpack.Load('asyncomplete-lsp.vim')
      endif
      Pacpack.Load('asyncomplete.vim')
    endif

    Pacpack.Load('vim-lsp')

    # vim-lsp-settings must be loaded after vim-lsp
    if Pacpack.Tap('vim-lsp-settings')
      Pacpack.Load('vim-lsp-settings')
    endif

    # Plugin initializations
    # inoremap <expr> <C-n>
    #      \ pumvisible() ? "\<C-n>" : asyncomplete#close_popup() .. "\<C-n>"
    # inoremap <expr> <C-p>
    #      \ pumvisible() ? "\<C-p>" : asyncomplete#close_popup() .. "\<C-p>"
    # inoremap <expr> <C-e> pumvisible() ? asyncomplete#cancel_popup() : "\<C-e>"
    lsp#enable()

    autocmd! vimrc_lsp_lazyload
    command! -bar LoadLspPlugins {
      echohl WarningMsg
      echo 'Lsp plugins are already loaded'
      echohl NONE
    }
  enddef
  command! -bar LoadLspPlugins LoadLspPlugins()|echo 'Loaded lsp plugins'


  g:lsp_use_native_client = 1
  g:lsp_insert_text_enabled = 0
  g:lsp_completion_documentation_delay = 0
  g:lsp_diagnostics_enabled = 1
  g:lsp_diagnostics_signs_enabled = 1
  g:lsp_diagnostics_signs_error = {text: '>>'}
  g:lsp_diagnostics_signs_warning = {text: '--'}
  g:lsp_diagnostics_signs_information = {text: '--'}
  g:lsp_diagnostics_signs_hint = {text: '!?'}
  g:lsp_diagnostics_delay_hint = 0
  g:lsp_diagnostics_float_cursor = 1
  g:lsp_diagnostics_float_delay = 0
  g:lsp_diagnostics_highlights_delay = 0
  g:lsp_diagnostics_virtual_text_delay = 0
  g:lsp_diagnostics_virtual_text_padding_left = 0
  g:lsp_diagnostics_virtual_text_align = 'right'
  g:lsp_diagnostics_virtual_text_wrap = 'truncate'
  g:lsp_document_code_action_signs_delay = 0
  g:lsp_inlay_hints_enabled = 0
  g:lsp_inlay_hints_delay = 0
  g:lsp_signature_help_delay = 0
  g:lsp_fold_enabled = 0
  g:lsp_settings = {
    ocaml-lsp: {
      cmd: ['ocamllsp'],
    },
  }
  g:lsp_settings_filetype_typescript = ['deno']

  def LspNotifyDiagnosticCount()
    # Update location list.
    if lsp#internal#diagnostics#state#_is_enabled_for_buffer(bufnr('%'))
      const uri = lsp#utils#get_buffer_uri()
      const diagnostics =
        lsp#internal#diagnostics#state#_get_all_diagnostics_grouped_by_server_for_uri(uri)
      var loclist = []
      for d in values(diagnostics)
        loclist += lsp#ui#vim#utils#diagnostics_to_loc_list({response: d})
      endfor
      setloclist(0, loclist)
    endif

    if !Pacpack.Tap('vim-notification')
      return
    endif

    # Notify error/warning count.
    const counts = lsp#get_buffer_diagnostics_counts()
    if (counts.error + counts.warning) == 0
      return
    endif

    notification#show({
      text: $"LSP\nError: {counts.error}  Warning: {counts.warning}",
      clicked: function('execute', ['lopen']),
      wait: 10000,
    })
  enddef

  def LspDefineBufferAutocmds()
    LspClearBufferAutocmds()

    if &filetype ==# 'go'
      augroup vimrc_lsp_buffer_go
        autocmd BufWritePre <buffer> silent LspDocumentFormatSync
        autocmd BufWritePre <buffer> silent LspCodeActionSync source.organizeImports
        autocmd Filetype <buffer> ++once LspClearBufferAutocmds()
      augroup END
    endif

    augroup vimrc_lsp_buffer
      autocmd BufWritePost <buffer> LspNotifyDiagnosticCount()
      if Pacpack.Tap('vim-backpair')
        autocmd CompleteDone <buffer> LspDisableBackpairPluginTemporallyOnCompleteDone()
      endif
    augroup END
  enddef

  def LspClearBufferAutocmds()
    augroup vimrc_lsp_buffer
      autocmd! * <buffer>
    augroup END

    if &filetype ==# 'go'
      augroup vimrc_lsp_buffer_go
        autocmd! * <buffer>
      augroup END
    endif
  enddef

  def LspEnableForBuffer()
    setlocal omnifunc=lsp#complete
    nnoremap <buffer> <silent> gd <Plug>(lsp-declaration)zv
    nnoremap <buffer> <Space>i <Plug>(lsp-hover-float)
    nnoremap <buffer> <Up> <Plug>(lsp-previous-error)zv
    nnoremap <buffer> <Down> <Plug>(lsp-next-error)zv

    LspDefineBufferAutocmds()
  enddef

  def LspDisableForBuffer()
    setlocal omnifunc=
    nunmap <buffer> gd
    nunmap <buffer> <Space>i
    nunmap <buffer> <Up>
    nunmap <buffer> <Down>

    LspClearBufferAutocmds()
  enddef

  def LspDisableBackpairPluginTemporallyOnCompleteDone()
    if !empty(get(v:completed_item, 'user_data', ''))
      call backpair#disable()
      autocmd User lsp_complete_done ++once
        \ call feedkeys("\<Cmd>call backpair#enable()\<CR>", 'n')
    endif
  enddef

  augroup vimrc_lsp
    autocmd User lsp_buffer_enabled call LspEnableForBuffer()
    autocmd User lsp_buffer_disabled call LspDisableForBuffer()
  augroup END
endif

if Pacpack.Tap('vim-lsp-settings')
  def LspUpdateAllServers()
    if !exists('g:loaded_lsp_settings')
      packadd vim-lsp-settings
    endif
    const ToDict = (l: list<string>): dict<string> => {
      var d: dict<string>
      for e in l
        d[e] = ''
      endfor
      return d
    }
    var installedServers = lsp_settings#installed_servers()
      ->map('v:val.name')
      ->ToDict()
    if installedServers->empty()
      Echomsg('No servers are installed.')
      return
    endif
    for [ft, servers] in lsp_settings#settings()->items()
      for server in servers
        if has_key(installedServers, server.command)
          installedServers[server.command] = ft
        endif
      endfor
    endfor
    tabnew
    var shouldCloseNormalBuffer = true
    for [server, ft] in installedServers->items()
      lsp_settings#install_server(ft, server)
      if shouldCloseNormalBuffer
        only
        shouldCloseNormalBuffer = false
      else
        wincmd =
      endif
      # TODO: Check if enough spaces are left.
    endfor
    Echomsg('Finished trigger updates.')
  enddef

  command! -bar LspUpdateAllServers LspUpdateAllServers()
endif

if Pacpack.Tap('vim-suda')
  if !Pacpack.GetPlugin('vim-suda').IsLoaded()
    command! -nargs=? -complete=file SudaRead
          \ Pacpack.Load('vim-suda')|SudaRead <args>
    command! -nargs=? -complete=file SudaWrite
          \ Pacpack.Load('vim-suda')|SudaWrite <args>
  endif
endif

if Pacpack.Tap('helpful.vim')
  if !Pacpack.GetPlugin('helpful.vim').IsLoaded()
    command! -nargs=+ -complete=help HelpfulVersion
          \ Pacpack.Load('helpful.vim')|HelpfulVersion <args>
  endif
endif

def MapOperator(plugin_name: string, mapsGiven: list<dict<string>>)
  const maps = mapsGiven->mapnew('extend(v:val, {modes: "nxo"}, "keep")')
  MapTextModifierPlugin(plugin_name, maps)
enddef

def MapTextobj(plugin_name: string, mapsGiven: list<dict<string>>)
  const maps = mapsGiven->mapnew('extend(v:val, {modes: "xo"}, "keep")')
  MapTextModifierPlugin(plugin_name, maps)
enddef

def MapTextModifierPlugin(
      plugin_name: string, maps: list<dict<string>>)
  # When the plugin is already loaded, do not use loader mapping. This load
  # guard is mainly for vimrc-reloading
  if Pacpack.IsLoaded(plugin_name)
    return
  endif

  # Config validation
  for map in maps
    for key in ['rhs', 'lhs', 'modes']
      if !has_key(map, key)
        EchomsgError('MapTextModifierPlugin: This key is missing: ' .. key)
        return
      endif
    endfor
  endfor

  for map in maps
    const loadermap =
      $'<SID>LoadTextModifierPlugin({string(plugin_name)}, {map->string()->keytrans()})'
    for mode in map.modes
      execute $'{mode}map <expr> {map.lhs} {loadermap}'
    endfor
  endfor
enddef

def LoadTextModifierPlugin(plugin: string, map: dict<string>): string
  Pacpack.Load(plugin)

  for mode in map.modes
    execute $'{mode}map {map.lhs} {map.rhs}'
  endfor

  return ReplaceTermcodes(map.rhs)
enddef

if Pacpack.Tap('vim-operator-replace')
  MapOperator('vim-operator-replace', [{lhs: 'ms', rhs: '<Plug>(operator-replace)'}])
endif

if Pacpack.Tap('vim-sandwich')
  g:textobj_sandwich_no_default_key_mappings = 1
  g:operator_sandwich_no_default_key_mappings = 1

  MapOperator('vim-sandwich', [
    {lhs: 'ma', rhs: '<Plug>(operator-sandwich-add)'},
    {lhs: 'md', rhs: '<Plug>(operator-sandwich-delete)'},
    {lhs: 'mr', rhs: '<Plug>(operator-sandwich-replace)'},
  ])

  def SandwichConfig()
    operator#sandwich#set('all', 'all', 'highlight', 0)
  enddef

  augroup vimrc-custom-operator
    autocmd SourcePost */plugin/sandwich.vim SandwichConfig()
  augroup END
endif

if Pacpack.Tap('caw.vim')
  inoremap <Plug>(vimrc:caw:prefix) <C-g>u<ESC>
  inoremap <silent> <Plug>(vimrc:caw:comment:here)
        \ <C-r>=b:caw_oneline_comment<CR>

  def CawLoadFtplugin()
    for ft in split(&filetype, '.')
      execute $'runtime! OPT after/ftplugin/{ft}/caw.vim'
    endfor
  enddef

  augroup vimrc-custom-operator
    autocmd SourcePost */plugin/caw.vim CawLoadFtplugin()
  augroup END

  def CawMap(): string
    var kind = ''
    if col('.') == 1
      kind = 'zeropos'
    elseif col('.') == col('$')
      kind = 'dollarpos'
    elseif getline('.') =~# '^\s\+$'
      kind = 'hatpos'
    else
      return "\<Plug>(vimrc:caw:comment:here)"
    endif
    return "\<Plug>(vimrc:caw:prefix)\<Plug>(caw:" .. kind .. ":comment)"
  enddef
  imap <expr> <Plug>(vimrc:caw:map) <SID>CawMap()

  MapOperator('caw.vim', [
    {lhs: 'mc', rhs: '<Plug>(caw:hatpos:toggle:operator)'},
    {lhs: 'm/', rhs: '<Plug>(caw:hatpos:toggle:operator)'},
    {lhs: '<C-l><C-j>', rhs: '<Plug>(vimrc:caw:map)', modes: 'i'},
  ])
  g:caw_no_default_keymappings = 1
  g:caw_dollarpos_sp_left = '  '
  g:caw_dollarpos_sp_right = ' '
  g:caw_hatpos_sp = ' '
  g:caw_zeropos_sp = ' '
endif

if Pacpack.Tap('vim-operator-swap')
  MapOperator('vim-operator-swap', [
    {lhs: 'my', rhs: '<Plug>(operator-swap-marking)'},
    {lhs: 'mp', rhs: '<Plug>(operator-swap)'},
  ])
endif

if Pacpack.Tap('vim-operator-jump_side')
  MapOperator('vim-operator-jump_side', [
    {lhs: '<C-p>', rhs: '<Plug>(operator-jump-head)'},
    {lhs: '<C-n>', rhs: '<Plug>(operator-jump-tail)'},
  ])
endif

if Pacpack.Tap('vim-textobj-entire')
  MapTextobj('vim-textobj-entire', [
    {lhs: 'aa', rhs: '<Plug>(textobj-entire-a)'},
    {lhs: 'ia', rhs: '<Plug>(textobj-entire-i)'},
  ])
  g:textobj_entire_no_default_key_mappings = 1
endif

if Pacpack.Tap('vim-textobj-function')
  augroup vimrc-textobj-function
    autocmd Filetype * ++once {
      packadd vim-textobj-function
      for ft in split(&filetype, '.')
        if ft =~# '\v^%(c|java|vim)$'
          execute $'runtime ftplugin/vim-textobj-function/{expand('<amatch>')}/textobj-function.vim'
        endif
      endfor
    }
    autocmd SourcePost */plugin/textobj/function.vim ++once ++nested
      \ autocmd! vimrc-textobj-function
  augroup END

  MapTextobj('vim-textobj-function', [
    {lhs: 'af', rhs: '<Plug>(textobj-function-a)'},
    {lhs: 'if', rhs: '<Plug>(textobj-function-i)'},
  ])
  g:textobj_function_no_default_key_mappings = 1
endif

if Pacpack.Tap('vim-textobj-indent')
  MapTextobj('vim-textobj-indent', [
    {lhs: 'ai', rhs: '<Plug>(textobj-indent-a)'},
    {lhs: 'aI', rhs: '<Plug>(textobj-indent-same-a)'},
    {lhs: 'ii', rhs: '<Plug>(textobj-indent-i)'},
    {lhs: 'iI', rhs: '<Plug>(textobj-indent-same-i)'},
  ])
  g:textobj_indent_no_default_key_mappings = 1
endif

if Pacpack.Tap('vim-textobj-line')
  MapTextobj('vim-textobj-line', [
    {lhs: 'al', rhs: '<Plug>(textobj-line-a)'},
    {lhs: 'il', rhs: '<Plug>(textobj-line-i)'},
  ])
  g:textobj_line_no_default_key_mappings = 1
endif

if Pacpack.Tap('vim-textobj-commentblock')
  MapTextobj('vim-textobj-commentblock', [
    {lhs: 'ac', rhs: '<Plug>(textobj-commentblock-a)'},
    {lhs: 'ic', rhs: '<Plug>(textobj-commentblock-i)'},
  ])
  g:textobj_commentblock_no_default_key_mapings = 1

  def TextobjCommentblockPickerCaw()
    if exists('g:loaded_caw')
      textobj#commentblock#pick#caw()
    else
      textobj#commentblock#pick#commentstring()
    endif
  enddef

  def OnLoadingTextobjCommentblock()
    augroup vimrc_textobj_commentblock
      autocmd!
      autocmd Filetype * TextobjCommentblockPickerCaw()
    augroup END
    TextobjCommentblockPickerCaw()
  enddef

  augroup vimrc_textobj_commentblock
    autocmd SourcePost */plugin/textobj/commentblock.vim OnLoadingTextobjCommentblock()
  augroup END
endif

if Pacpack.Tap('vim-textobj-between')
  MapTextobj('vim-textobj-between', [
    {lhs: 'ad', rhs: '<Plug>(textobj-between-a)'},
    {lhs: 'id', rhs: '<Plug>(textobj-between-i)'},
  ])
  g:textobj_between_no_default_key_mappings = 1

  omap i/ id/
  omap a/ ad/
  vmap i/ id/
  vmap a/ ad/
endif

if Pacpack.Tap('denops.vim')
  $DENOPS_TEST_DENOPS_PATH = Pacpack.GetPlugin('denops.vim').path
  if IsWindows
    g:denops_server_addr = '127.0.0.1:32123'
  endif
  if Pacpack.Tap('vim-notification')
    augroup vimrc
      autocmd User DenopsReady notification#show('Denops is ready.')
    augroup END
  endif
  command! -bar DenoUpdateCache denops#cache#update({reload: true})
endif
if Pacpack.Tap('ddu.vim')
  def DduConfig()
    # Pre-load some custom modules.
    ddu#custom#load_config(Fs.JoinPath(Stdpath.dotvim, 'ddu', 'config.ts'))
    ddu#load('ui', ['ff_vim_popup'])
    ddu#load('source', ['mr', 'file', 'file_rec'])
    ddu#load('filter', ['matcher_multi_regex'])

    if Pacpack.Tap('lspoints')
      g:ddu_source_lsp_clientName = 'lspoints'
    elseif Pacpack.Tap('vim-lsp')
      g:ddu_source_lsp_clientName = 'vim-lsp'
    endif

    ddu#custom#patch_local('pack-files', {
      sources:
        [
          PacPath,
          Fs.JoinPath(Stdpath.cache, 'pack', 'local', 'start'),
          Fs.JoinPath(Stdpath.cache, 'pack', 'local', 'opt'),
        ]
        ->filter('isdirectory(v:val)')
        ->mapnew('{"name": "file_rec", "options": {"path": v:val}}'),
      sourceOptions: {file_rec: {converters: [{name: 'converter_packpath'}]}},
      filterParams: {converter_packpath: {hlGroup: 'LineNr'}},
    })
    ddu#custom#patch_local('dotfiles', {
      sources: [
        {name: 'file_rec', options: {path: Stdpath.dotfiles}}
      ],
    })
  enddef

  def DduMapFF()
    nnoremap <buffer> q <Cmd>call ddu#ui#do_action('quit')<CR>
    nnoremap <buffer> <C-o> <Cmd>call ddu#ui#do_action('quit')<CR>
    nnoremap <buffer> <CR> <Cmd>call ddu#ui#do_action('itemAction')<CR>
    nnoremap <buffer> i <Cmd>call ddu#ui#do_action('openFilterWindow')<CR>
    nnoremap <buffer> p <Cmd>call ddu#ui#do_action('togglePreview')<CR>
    nnoremap <buffer> P <Cmd>call ddu#ui#do_action('previewPath')<CR>
    nnoremap <buffer> o <Cmd>call ddu#ui#do_action('expandItem', #{mode: 'toggle'})<CR>
    nnoremap <buffer> O <Cmd>call ddu#ui#do_action('collapseItem')<CR>
    nnoremap <buffer> <Tab> <Cmd>call ddu#ui#do_action('chooseAction')<CR>
    nnoremap <buffer> a <Cmd>call ddu#ui#do_action('chooseAction')<CR>
    nnoremap <buffer> <C-l> <Cmd>call ddu#ui#do_action('refreshItems')<CR>
    nnoremap <buffer> m <Cmd>call ddu#ui#do_action('toggleSelectItem')<CR>
    nnoremap <buffer> * <Cmd>call ddu#ui#do_action('toggleAllItems')<CR>
    nnoremap <buffer> >>
          \ <Cmd>call ddu#ui#do_action('itemAction', {'name': 'quickfix'})<CR>
    nnoremap <buffer> /
          \ <Cmd>call ddu#ui#do_action('itemAction',
          \ {'name': 'searchFilesInContainedProject'})<CR>
    nnoremap <buffer> <C-p>
          \ <Cmd>call ddu#ui#do_action('previewExecute',
          \ {'command': 'execute "normal! \<C-y>"'})<CR>
    nnoremap <buffer> <C-n>
          \ <Cmd>call ddu#ui#do_action('previewExecute',
          \ {'command': 'execute "normal! \<C-e>"'})<CR>
    nnoremap <buffer> <Space>j
          \ <Cmd>call ddu#ui#do_action('quit')<CR><Cmd>call <SID>DduFiles()<CR>
  enddef

  def DduMapFFVimPopup()
    const MapAction = ddu#ui#ff_vim_popup#MapAction
    MapAction('n', 'q', 'quit')
    MapAction('n', 'j', 'selectLowerItem')
    MapAction('n', 'k', 'selectUpperItem')
    MapAction('n', 'i', 'moveToInsertMode')
    MapAction('n', '<CR>', 'itemAction')
    MapAction('n', 'u', 'undoInput')
    MapAction('n', '<C-r>', 'redoInput')
    MapAction('n', 'm', 'toggleSelectItem')
    MapAction('n', '*', 'toggleAllItems')
    MapAction('n', 'o', 'expandItem', {mode: 'toggle'})
    MapAction('n', 'O', 'collapseItem')
    MapAction('n', 'p', 'previewItem')
    MapAction('n', '<<', 'itemAction', {name: 'quickfix'})
    MapAction('n', 'a', 'chooseAction')
    MapAction('n', '<Tab>', 'chooseAction')

    MapAction('i', '<ESC>', 'moveToNormalMode')
    MapAction('i', '<CR>', 'moveToNormalMode')
    MapAction('i', '<C-f>', 'moveForward')
    MapAction('i', '<C-b>', 'moveBackward')
    MapAction('i', '<C-a>', 'moveToHead')
    MapAction('i', '<C-e>', 'moveToTail')
    MapAction('i', '<C-n>', 'selectLowerItem')
    MapAction('i', '<C-p>', 'selectUpperItem')
    MapAction('i', '<C-h>', 'deleteChar')
    MapAction('i', '<Del>', 'deleteChar')
    MapAction('i', '<BS>', 'deleteChar')
    MapAction('i', '<C-w>', 'deleteWord')
    MapAction('i', '<C-u>', 'deleteToHead')
  enddef

  def DduGetSearchRootPath(pathGiven: string, silent: bool = false): string
    if pathGiven ==# ''
      return FindGitroot() ?? getcwd(winnr())
    endif

    const path = pathGiven->expand()
    if !path->isdirectory()
      if !silent
        EchomsgError($'Directory not found: {path}')
      endif
      return ''
    endif

    return path
  enddef

  var dduWaitingUiOpen = false
  def DduOnUiReady()
    dduWaitingUiOpen = false
  enddef

  def DduStartSync(options: dict<any> = {})
    ddu#start(options)
    var keyTypes = ''
    dduWaitingUiOpen = true
    autocmd User Ddu:uiReady ++once DduOnUiReady()
    while dduWaitingUiOpen
      while getcharstr(true) !=# ''
        keyTypes ..= getcharstr()
      endwhile
      sleep 1m
    endwhile
    if keyTypes !=# ''
      feedkeys(keyTypes .. "\<Cmd>redraw\<CR>", 'it')
    endif
  enddef

  def DduLiveGrep(pathGiven: string = '')
    var path = DduGetSearchRootPath(pathGiven)
    if path !=# ''
      if pathGiven ==# ''
        path = Input('live-grep: ', path, 'dir')->expand()
        if !path->isdirectory()
          EchomsgError($'Directory not found: {path}')
          return
        endif
      endif
      DduStartSync({name: 'live-grep', sourceOptions: {rg: {path: path}}})
    endif
  enddef

  def DduFiles(pathGiven: string = '')
    const path = DduGetSearchRootPath(pathGiven)
    if path !=# ''
      DduStartSync({name: 'file-rec', sourceOptions: {file_rec: {path: path}}})
    endif
  enddef

  def DduMru()
    DduStartSync({
      name: 'mru',
      sources: [
        {name: 'mr'},
        {name: 'file', options: {path: DduGetSearchRootPath('')}},
        {name: 'file_rec', options: {path: Stdpath.dotfiles}},
      ],
    })
  enddef

  def DduCommand(...args: list<string>)
    if empty(args)
      EchomsgError('Ddu: No command specified.')
      return
    endif

    const cmd = args[0]
    if cmd =~# '^lsp-\%(workspaceSymbol\|documentSymbol\|callHierarchy\)$'
      DduStartSync({name: cmd})
    elseif cmd =~# '^git\%(-\?files\)\?$'
      DduStartSync({name: 'file_git'})
    elseif cmd =~# '^live-\?grep$'
      call(DduLiveGrep, args[1 :])
    elseif cmd ==# 'files'
      call(DduFiles, args[1 :])
    elseif cmd ==# 'help'
      DduStartSync({sources: [{name: 'help'}]})
    elseif cmd ==# 'man'
      DduStartSync({sources: [{name: 'man'}]})
    endif
  enddef

  def DduCommandComplete(argLead: string, cmdLine: string, cursorPos: number): list<string>
    const argPos = (cmdLine .. '$')->split()->len()
    if argPos <= 2
      return [
        'lsp-workspaceSymbol',
        'lsp-documentSymbol',
        'lsp-callHierarchy',
        'git-files',
        'live-grep',
        'files',
        'help',
      ]->filter((_: number, v: string): bool => stridx(v, argLead) == 0)
    else
      const cmd = cmdLine->split()[1]
      if cmd =~# '^\%(files\|live-\?grep\)$'
        return getcompletion(argLead, 'dir')
          ->map((_: number, v: string): string => v->fnameescape())
      endif
    endif
    return []
  enddef

  nnoremap <Space>k <Cmd>call <SID>DduMru()<CR>
  nnoremap <Space>j <Cmd>call <SID>DduFiles()<CR>
  nnoremap <Space>l <Cmd>call <SID>DduStartSync(#{sources: [#{name: 'line'}]})<CR>
  nnoremap <Space>b <Cmd>call <SID>DduStartSync({'name': 'buffer'})<CR>
  command! PackFiles DduStartSync({'name': 'pack-files'})
  command! Dotfiles DduStartSync({'name': 'dotfiles'})
  command! -nargs=? -complete=dir Files DduFiles(<q-args>)
  command! -nargs=? -complete=dir LiveGrep call DduLiveGrep(<q-args>)
  command! -nargs=+ -complete=customlist,DduCommandComplete Ddu DduCommand(<f-args>)

  augroup vimrc-ddu
    autocmd FileType ddu-ff DduMapFF()
    autocmd User Ddu:ui:ff_vim_popup:openWindowPre DduMapFFVimPopup()
  augroup END

  if !v:vim_did_enter
    autocmd vimrc-ddu User vimrc_initialize ++once DduConfig()
    autocmd vimrc-ddu SourcePost */plugin/ddu_rg.vim ++once delcommand DduRg
  endif
endif

if Pacpack.Tap('ddc.vim')
  def DdcConfig()
    ddc#custom#load_config(Fs.JoinPath(Stdpath.dotvim, 'ddc', 'config.ts'))

    var engine = ''
    if Pacpack.Tap('lspoints')
      engine = 'lspoints'
    elseif Pacpack.Tap('vim-lsp')
      engine = 'vim-lsp'
    endif
    ddc#custom#patch_global('sourceParams', {lsp: {lspEngine: engine}})

    ddc#enable()
    set completefunc=<SID>DdcCompletefunc
  enddef

  def DdcCompletefunc(findstart: number, base: string): any
    if !!findstart
      defer call('ddc#map#manual_complete', [])
      return -3
    else
      return []
    endif
  enddef

  if !v:vim_did_enter
    augroup vimrc-ddc
      autocmd User DenopsReady ++once DdcConfig()
    augroup END
  endif
endif

if Pacpack.Tap('vim-mr')
  def MrPredicate(filename: string): bool
    if filename =~# '\.git\%([\/]\%(config\|hooks\)\>\)\@!\>'
      return false
    endif
    if resolve(expand('%:p')) == filename && &l:buftype !=# ''
      return false
    endif
    return true
  enddef

  g:mr#mru#predicates = [MrPredicate]
  g:mr_mrw_disabled = true
  g:mr_mrr_disabled = true
  g:mr_mrd_disabled = true
endif

if Pacpack.Tap('skkeleton')
  inoremap <expr> <C-e> pumvisible() ? '<C-e>' : '<Plug>(skkeleton-toggle)'

  def SkkeletonInit()
    var config: dict<any> = {eggLikeNewline: true}
    const plugin = Pacpack.GetPlugin('skkeleton')

    if Pacpack.Tap('dict')
      config.globalDictionaries = ['SKK-JISYO.L.json']
        ->map((_: number, v: string): string => Fs.JoinPath(plugin.path, 'json', v))
    endif

    skkeleton#config(config)

    extend(g:skkeleton#mapped_keys, ['<C-n>', '<C-p>', '<C-y>', '<C-e>'])
    skkeleton#register_keymap('input', ';', 'henkanPoint')
    skkeleton#register_keymap('input', '<C-n>', 'henkanFirst')
    skkeleton#register_keymap('henkan', '<C-p>', 'henkanBackward')
    skkeleton#register_keymap('henkan', '<C-n>', 'henkanForward')
    skkeleton#register_keymap('henkan', '<C-y>', 'kakutei')
    skkeleton#register_keymap('henkan', '<C-e>', 'cancel')
  enddef

  def SkkeletonOnEnable()
    popup_create('', {
      line: 'cursor+1',
      col: 'cursor',
      time: 1000,
    })
  enddef

  def SkkeletonOnDisable()
    popup_create('A', {
      line: 'cursor+1',
      col: 'cursor',
      time: 1000,
    })
  enddef

  def SkkeletonOnModeChanged()
    const modemap = {
      hira: '',
      kata: '',
      hankata: '',
      zenkaku: 'A',
      abbrev: 'abbr',
    }

    popup_create(get(modemap, g:skkeleton#mode, 'A'), {
      line: 'cursor+1',
      col: 'cursor',
      time: 1000,
      moved: 'any',
    })
  enddef

  augroup vimrc-skkeleton
    autocmd User skkeleton-initialize-pre SkkeletonInit()
    autocmd User skkeleton-mode-changed SkkeletonOnModeChanged()
  augroup END
endif

if Pacpack.Tap('vim-gin')
  # g:gin_log_default_args = ['--oneline']
  # g:gin_log_persistent_args = ['++opener=noomdeline\ edit']
  g:gin_patch_persistent_args = ['++opener=tabedit', '++no-head']
  g:gin_proxy_apply_without_confirm = true
  nnoremap <Space>g <Cmd>GinStatus<CR>

  def GinStatusOpened()
    nnoremap <buffer> <Space>g <Cmd>Gin commit<CR>
    nnoremap <buffer> <C-l> <Cmd>call gin#util#reload()<CR>
  enddef

  def GinLogOpened()
    nnoremap <buffer> <C-l> <Cmd>call gin#util#reload()<CR>
    nnoremap <buffer> <C-p> <Cmd>call search('^commit\s\w\+', 'bW')<CR>
    nnoremap <buffer> <C-n> <Cmd>call search('^commit\s\w\+', 'W')<CR>
  enddef

  augroup vimrc-gin
    autocmd BufReadCmd ginstatus://* GinStatusOpened()
    autocmd BufReadcmd ginlog://* GinLogOpened()
    autocmd BufReadCmd gin*://* setlocal nomodeline
  augroup END
endif

if Pacpack.Tap('vim-fall')
  augroup vimrc-fall
    autocmd User FallPickerEnter:* vimrc#fall#Setup()
    autocmd User FallPickerLeave:* vimrc#fall#Shutdown()
    autocmd ColorScheme * highlight link FallSelectMatch Special
  augroup END
  highlight link FallSelectMatch Special

  g:fall_disable_default_mapping = true
endif

# ReadingVimrc
command! -bar ReadingVimrc call ReadingVimrc()
augroup vimrc-readingvimrc
  autocmd BufReadCmd readingvimrc://* OnOpenReadingVimrcBuffer()
augroup END
def ReadingVimrc()
  try
    packadd vim-reading-vimrc

    # Use :execute here because :ReadingVimrcNext command doesn't defined yet
    # when compiling this function and E476 error is given
    execute 'ReadingVimrcNext'

    command! ReadingVimrc ReadingVimrcNext
  catch
    EchomsgError(v:throwpoint .. v:exception)
  endtry
enddef

def OnOpenReadingVimrcBuffer()
  const bufname = expand('<amatch>')->matchstr('readingvimrc://\zs.*')
  if bufname ==# 'next'
    if winnr('$') == 1
      return
    endif

    const curwinnr = winnr()
    for winnr in range(1, winnr('$'))
      if winnr == curwinnr
        continue
      elseif line('$') > 1 || winbufnr(winnr)->getbufline(1)[0] !=# ''
        wincmd T
        return
      endif
    endfor

    only
  else
    vmap y <Plug>(reading_vimrc-update_clipboard)
    if winnr('$') > 1
      wincmd T
    endif
  endif
enddef


# matchit plugin
augroup vimrc-matchit
  autocmd Filetype * b:match_words = GetMatchitWords()
augroup END

def GetMatchitWords(): string
  if &l:filetype ==# 'vim'
    return [
      '\<if\>:\<elseif\>:\<else\>:\<endif\>',
      '\<while\>:\<endwhile\>',
      '\<for\>:\<endfor\>',
      '\<def\>:\<enddef\>',
      '\<fu\%[nction]\>:\<endf\%[unction]\>',
      '\<augroup\>\%(\s\+END\)\@!:\<augroup\s\+END\>',
      '\<try\>:\<catch\>:\<finally\>:\<endtry\>',
      '\<class\>:\<endclass\>',
      '\<enum\>:\<endenum\>',
    ]->join(',')
  elseif &l:filetype =~# '^\%(c\|cpp\|objc\%(pp\)\)$'
    var rules = [
      '^\s*#\s*if\%(def\)\?\>:^\s*#\s*elif\%(def\)\?\>:^\s*#\s*else\>:^\s*#\s*endif\>',
      '/\*:\*/',
    ]
    if &l:filetype =~# '^objc\%(pp\)\?$'
      rules += ['^\s*@\%(interface\|implementation\)\>:^\s*@end\>']
    endif
    return rules->join(',')
  elseif &l:filetype =~# '^\%(ba\|z\|fi\|c\)\?sh$'
    return [
      '\<if\>:\<elif\>:\<else\>:\<fi\>',
      '\<do\>:\<done\>',
      '\<case\>:\<esac\>',
    ]->join(',')
  elseif &l:filetype ==# 'ocaml'
    return '(\*:\*)'
  endif
  return ''
enddef


# Showmode
class Showmode
  static const _colors = {
    normal: [['22', '148'], ['#005f00', '#afdf00']],
    insert: [['23', '117'], ['#005f5f', '#87dfff']],
    visual: [['88', '208'], ['#870000', '#ff8700']],
    replace: [['231', '160'], ['#ffffff', '#df0000']],
  }
  static const _labels = {
    n: 'NORMAL',
    i: 'INSERT',
    R: 'REPLACE',
    v: 'VISUAL',
    V: 'V-LINE',
    ["\<C-v>"]: 'V-BLOCK',
    c: 'COMMAND',
    ce: 'EX-COM',
    s: 'SELECT',
    S: 'S-LINE',
    ["\<C-s>"]: 'S-BLOCK',
    t: 'T-INSERT',
    no: 'OPERATOR',
    niI: 'N-INSERT',
    niR: 'N-REPLACE',
    niV: 'N-V-REPLACE',
  }
  static const _highlights = {
     i: 'insert',
     t: 'insert',
     R: 'replace',
     v: 'visual',
     V: 'visual',
     ["\<C-v>"]: 'visual',
  }

  static def DefColor()
    eval _colors
      ->items()
      ->mapnew((_: number, v: list<any>): dict<any> => {
        const mode = v[0]
        const color = v[1]
        return {
          name: $'VimrcShowMode{mode}',
          ctermfg: color[0][0],
          ctermbg: color[0][1],
          guifg: color[1][0],
          guibg: color[1][1],
          force: true}
      })
      ->hlset()
  enddef

  static def GetLabel(): string
    _highlight()
    return _labels->get(mode(), 'UNKNOWN')
  enddef

  static def GetBadge(): string
    if win_getid() == g:statusline_winid &&
          getwinvar(g:statusline_winid, '&modifiable')
      return '%#VimrcShowMode# %{<SID>ShowmodeMode()} %#Statusline#'
    endif
    return ''
  enddef

  static def _highlight()
    const hl = get(_highlights, mode(), 'normal')
    hlset([{name: 'VimrcShowMode', linksto: $'VimrcShowMode{hl}'}])
  enddef
endclass

def ShowmodeMode(): string
  return Showmode.GetLabel()
enddef

augroup vimrc_showmode
  autocmd ColorScheme * Showmode.DefColor()
  autocmd User vimrc_initialize ++once Showmode.DefColor()
augroup END

# statusline
var StatuslineGitBranchProvider = () => 'no-gin'

def StatuslineGitBranch(): string
  return StatuslineGitBranchProvider()
enddef

if Pacpack.Tap('vim-gin')
  def StatuslineGitBranchByGin(): string
    const branch = gin#component#branch#unicode()
    if branch ==# ''
      return 'no-git'
    endif
    return branch .. gin#component#traffic#unicode()
  enddef

  augroup vimrc
    autocmd User DenopsPluginPost:gin
      \ StatuslineGitBranchProvider = StatuslineGitBranchByGin
  augroup END
endif

def StatuslineGenerator(): string
  const statusline =
    '%m' ..
    Showmode.GetBadge() ..
    '[%{&ft ==# "" ? "No ft" : &ft}]' ..
    '[#%{bufnr("%")}]' ..
    '[%{<SID>StatuslineGitBranch()}]' ..
    '%{<SID>FilenameLabel(bufnr("%"))}' ..
    '%<%=' ..
    '[%{&fileformat}]' ..
    '[%{&fileencoding == "" ? &encoding : &fileencoding}]' ..
    '[%{pathshorten(getcwd(winnr()))}]'
  return substitute(statusline, '\c<SID>', SIDPrefix(), 'g')
enddef
def FilenameLabel(bufnr: number): string
  const buftype = getbufvar(bufnr, '&buftype')
  const bufname = bufname(bufnr)
  if buftype ==# 'help'
    return fnamemodify(bufname, ':t')
  elseif buftype ==# 'quickfix'
    return '[quickfix]'
  elseif getbufvar(bufnr, '&previewwindow')
    return '[preview]'
  elseif buftype ==# 'terminal'
    return 'terminal:' .. bufname
  elseif buftype ==# 'prompt'
    return '[prompt]'
  else
    return (buftype ==# 'nofile' ? ' *NoFile* ' : '') ..
      (bufname ==# '' ? '[NoName]' : pathshorten(fnamemodify(bufname, ':.')))
  endif
enddef
&statusline = printf('%%!%sStatuslineGenerator()', SIDPrefix())

# tabline
&tabline = printf('%%!%sTabline()', SIDPrefix())
def GenerateTabinfo(tabnr: number): string
  var tablist = tabpagebuflist(tabnr)
  var info = ''
  info ..= len(filter(copy(tablist), 'getbufvar(v:val, "&mod")')) > 0 ? '[+]' : ''
  info ..= '[' .. tabpagewinnr(tabnr, '$') .. ']'
  return info
enddef
def Tabline(): string
  var tabline = '%#TabLine#|'
  const t = tabpagenr()

  for n in range(1, tabpagenr('$'))
    tabline ..= '%' .. n .. 'T'
    var info = ' ' .. GenerateTabinfo(n) .. ' '
    if t == n
      tabline ..= '%#TabLineSel# %999Xx%X' .. info .. '%#TabLine#'
    else
      tabline ..= info
    endif
    tabline ..= '%T|'
  endfor
  tabline ..= '%>%=[%{pathshorten(getcwd())}]'

  return substitute(tabline, '\c<SID>', SIDPrefix(), 'g')
enddef

# :terminal
augroup vimrc_terminal
  autocmd TerminalWinOpen * setlocal nonumber norelativenumber
augroup END

# EmphasisIndent
highlight link VimrcEmphasisIndent CursorLine
augroup vimrc_emphasize_indent
  autocmd WinEnter * EmphasizeIndent()
  autocmd OptionSet expandtab,smarttab,tabstop,shiftwidth EmphasizeIndent()
  autocmd User vimrc_initialize ++once EmphasizeIndent()
  autocmd ColorScheme * highlight link VimrcEmphasisIndent CursorLine
augroup END
def EmphasizeIndent()
  if exists('w:disable_emphasis_indent') && <bool>w:disable_emphasis_indent
    return
  endif
  if exists('w:emphasis_indent_id')
    matchdelete(w:emphasis_indent_id)
    unlet w:emphasis_indent_id
  endif

  var pat = '\v%%(^%%(%s)*)@<=%s'
  if &l:expandtab
    pat = printf(pat, repeat('\s', shiftwidth()), '\s')
  else
    pat = printf(pat, '\t\t', '\t')
  endif
  w:emphasis_indent_id = matchadd('VimrcEmphasisIndent', pat)
enddef
def EmphasisIndentEnable()
  w:disable_emphasis_indent = 0
  EmphasizeIndent()
enddef
def EmphasisIndentDisable()
  w:disable_emphasis_indent = 1
  if exists('w:emphasis_indent_id')
    matchdelete(w:emphasis_indent_id)
    unlet w:emphasis_indent_id
  endif
enddef
command! EmphasisIndentDisable call EmphasisIndentDisable()
command! EmphasisIndentEnable call EmphasisIndentEnable()

# WarningSpace
highlight link WarningSpace Error
augroup vimrc_warningspace
  # Call WarningSpace() function on TerminalWinOpen event to disable warning
  # space emphasis; it seems WinEnter event triggered on the previous window
  # when opening terminal window.
  autocmd WinEnter,TerminalWinOpen * WarningSpace()
  autocmd OptionSet buftype,modifiable WarningSpace()
  autocmd User vimrc_initialize ++once WarningSpace()
  autocmd ColorScheme * highlight link WarningSpace Error
augroup END
def WarningSpace()
  # Clean up.
  if exists('w:twobyte_space_id')
    matchdelete(w:twobyte_space_id)
    unlet w:twobyte_space_id
  endif
  if exists('w:end_of_line_space_id')
    matchdelete(w:end_of_line_space_id)
    unlet w:end_of_line_space_id
  endif

  if &l:buftype !=# '' || !&l:modifiable
    return
  endif

  # Zenkaku space
  # NOTE: '\%d12288' means one zenkaku space. HINT: nr2char(12288)
  w:twobyte_space_id = matchadd('WarningSpace', '\%d12288')

  # White spaces in the end of line
  w:end_of_line_space_id = matchadd('WarningSpace', '\s\+$')
enddef
command! ReplaceTwobyteSpace keeppatterns :%s/\%d12288/ /g
command! DeleteLineEndSpace keeppatterns :%s/\s\+$//g

# filore
def FiloreMapping()
  const mapping = [
   ['q', 'exit'],
   ['o', 'toggle-directory-folding'],
   ['l', 'enter-directory'],
   ['h', 'leave-directory'],
   ['.', 'toggle-show-hidden-files'],
   ['k', 'loop-cursor-up'],
   ['j', 'loop-cursor-down'],
   ['<CR>', 'open-file'],
   ['/', 'filter-files'],
   ['<C-h>', 'start-history'],
  ]->mapnew((_: number, val: list<string>): string =>
       ('nmap <buffer> ' .. val[0] .. ' <Plug>(filore-' .. val[1] .. ')'))
  execute join(mapping, "\n")
enddef
augroup vimrc_additional_plugins
  autocmd FileType filore call FiloreMapping()
augroup END

# splash
command! Splash call vimrc#splash#Show()
if !v:vim_did_enter && !(IsMac && has('gui_running'))
  augroup vimrc_splash
    autocmd VimEnter * ++once ++nested call vimrc#splash#Intro()
    autocmd StdinReadPre * ++once autocmd! vimrc_splash VimEnter
  augroup END
endif

# gvimrc
if has('gui_running')
  if !v:vim_did_enter
    if IsWSL
      # Avoid too large window.
      set lines=35 columns=100
    elseif IsLinux && executable('i3')
      # It seems that too large window on i3 does not work properly.
      set lines=50 columns=200
    else
      set lines=999 columns=9999
    endif

    if IsWindows
      winpos 0 0
      autocmd GuiEnter * ++once simalt ~x
      cd $USERPROFILE
      if &shell =~? 'cmd\.exe' && executable('C:/msys64/usr/bin/bash.exe')
        # Set MSYS2 MinGW64 related environmental variables.
        if executable('C:/msys64/msys2_shell.cmd')
          eval systemlist('C:/msys64/msys2_shell.cmd -mingw64 -defterm -no-start -c env')
            ->filter((_: number, v: string): bool => v =~# '\v^%(MSYS|MINGW)')
            ->map((_: number, v: string): string => substitute(
              v,
              '\v(^[^=]*)\=(.*)$',
              (m: list<string>): string => $'${m[1]} = {m[2]->expand()->string()}',
              ''))
            ->execute()
        endif
        # Then change shell.
        &shell = 'C:/msys64/usr/bin/bash.exe'
        &shellcmdflag = '-c'
      endif
    endif
  endif
  set guioptions& guioptions-=e guioptions-=T guioptions-=m
  set guioptions-=R guioptions-=r guioptions-=L guioptions-=l
  set mouse=a
  set nomousefocus
  set mousehide

  if IsWindows
    set guifont=Cica:h12,MS_Gothic:h10:cSHIFTJIS
    set linespace=1
  elseif IsMac
    set guifont=Cica:h14,Osaka-Mono:h14
    nnoremap <D-n> <Cmd>macaction newWindow:<CR>
  elseif has('xfontset')
    # for unix (use xfontset)
    set guifont=a14,r14,k14
  elseif IsLinux
    set guifont=Cica\ 14,DejaVu\ Sans\ Mono\ 14
  endif

  if has('multi_byte_ime') || has('xim')
    set iminsert=0 imsearch=0
    augroup vimrc_iminsert
      autocmd InsertLeave * set iminsert=0
    augroup END
  endif
endif

# lvimrc
{
  const lvimrc = Fs.JoinPath('~', Fs.Rc('lvimrc'))
  execute 'command! -bar -nargs=* LVimrc ' ..
          'execute <q-args> ?? "edit"' string(lvimrc)
  if filereadable(expand(lvimrc))
    execute 'source' lvimrc
  endif
}

# Load plugins
if !v:vim_did_enter
  Pacpack.LoadNonLazyPlugins()
endif

# Initialize when loading this file.
if exists('#User#vimrc_initialize')
  if v:vim_did_enter
    doautocmd User vimrc_initialize
  else
    def VimrcInitialize(statusLineSave: string): string
      &statusline = statusLineSave
      timer_start(5, (timer) => execute('doautocmd User vimrc_initialize', ''))
      return ''
    enddef
    &statusline = $'%!{SIDPrefix()}VimrcInitialize({&statusline->string()})'
  endif
endif
