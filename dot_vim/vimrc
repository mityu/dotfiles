" Author: mityu
" Last Change: 03-Dec-2020.
" vim: shiftwidth=2
" vim9script
" Encoding
if has('vim_starting')
  set encoding=utf-8
  scriptencoding utf-8
  let $MYVIMRC = resolve(expand('<sfile>'))
endif
def! s:FoldIsBlockOpen(line: string): bool
  return line =~# '\v^%(fu%[nction]|%(export\s+)?def|if|for|while|try)'
enddef
def! s:FoldIsBlockClose(line: string): bool
  return line =~# '\v^end%(func%[tion]|def|if|for|while|try)'
enddef
function! FoldExprForVimrc() abort
  " TODO: Fold with marker
  let line = getline(v:lnum)
  if line =~# '^\s'
    return '='
  elseif s:FoldIsBlockOpen(line)
    return '>1'
  elseif v:lnum == 1 || s:FoldIsBlockClose(getline(v:lnum - 1))
    return 0
  endif
  return '='
endfunction

" Local utility functions
function! s:SIDPrefix() abort
  " Returns "<SNR>{script-ID}_"
  return expand('<SID>')
endfunction
function! s:SNR() abort
  return matchstr(s:SIDPrefix(), '<SNR>\zs\d\+\ze_$')
endfunction
" function! s:Rc(fname) abort
"   return s:filesystem.rcfile_prefix .. a:fname
" endfunction
" def! s:JoinPath(...arg: list<any>): string
"   return join(arg, s:filesystem.slash)
" enddef
if has('win32')
  def! s:Rc(fname: string): string
    return '_' .. fname
  enddef
  def! s:JoinPath(...arg: list<any>): string
    return join(arg, '\')
  enddef
else
  def! s:Rc(fname: string): string
    return '.' .. fname
  enddef
  def! s:JoinPath(...arg: list<any>): string
    return join(arg, '/')
  enddef
endif
function! s:has(object, to_search) abort
  let object_type = type(a:object)
  if object_type == v:t_string
    let func = 'stridx'
    let not_found = -1
  elseif object_type == v:t_list
    let func = 'index'
    let not_found = -1
  elseif object_type == v:t_dict
    let func = 'has_key'
    let not_found = 0
  else
    return 0
  endif
  return (call(func, [a:object, a:to_search]) != not_found)
endfunction
def! s:GetMsgString(msg: string): string
  return '[vimrc] ' .. msg
enddef
def! s:EchomsgWithColor(msg: string, hl_group: string): void
  execute 'echohl' hl_group
  echomsg s:GetMsgString(msg)
  echohl NONE
enddef
def! s:echomsg(msg: string): void
  call s:EchomsgWithColor(msg, 'NONE')
enddef
def! s:EchomsgError(msg: string): void
  call s:EchomsgWithColor(msg, 'Error')
enddef
def! s:EchomsgWarning(msg: string): void
  call s:EchomsgWithColor(msg, 'WarningMsg')
enddef
def! s:echo(msg: string): void
  echo s:GetMsgString(msg)
enddef
def! s:EchoQuestion(question: string): void
  echon s:GetMsgString(question) .. ' '
  echohl Question
  echon '[Y/N]'
  echohl NONE
  echon "\n"
enddef
def! s:IsVisualmode(): bool
  return s:has(['v', 'V', "\<C-v>"], mode())
enddef
def! s:IsCmdwin(): bool
  return getcmdwintype() !=# ''
enddef
def! s:glob(expr: string): list<string>
  return split(glob(expr), "\n")
enddef
def! s:GetcharString(...expr: list<number>): any
  return nr2char(call('getchar', expr))
enddef
def! s:ask(question: string): bool
  call s:EchoQuestion(question)
  return s:has(['y', 'Y'], s:getchar_string())
enddef
def! s:Mkdir(dir: string, ...opt: list<any>): bool
  if isdirectory(dir)
    return true
  endif
  if !exists('*mkdir')
    s:EchomsgError('built-in mkdir() not found.')
    return false
  endif
  return call('mkdir', [dir] + opt) ? true : false
enddef
function! s:input(prompt, ...) abort
  try
    return call('input', [a:prompt] + a:000)
  catch /\C^Vim:Interrupt$/
    return ''
  endtry
endfunction
function! s:WinExecute(id, command, ...) abort
  let eventignore_save = &eventignore
  set eventignore=all
  try
    return call('win_execute', [a:id, a:command] + a:000)
  finally
    let &eventignore = eventignore_save
  endtry
endfunction

" Global utility functions
function! VimrcSIDPrefix() abort
  return s:SIDPrefix()
endfunction
function! VimrcFunc(func) abort
  return function(s:SIDPrefix() .. a:func)
endfunction
function! SetUndoFtplugin(config) abort
  let restorer = 'execute ' .. string(a:config)
  if exists('b:undo_ftplugin')
    let b:undo_ftplugin = restorer .. '|' .. b:undo_ftplugin
  else
    let b:undo_ftplugin = restorer
  endif
endfunction
command! -nargs=1 -complete=command SetUndoFtplugin
      \ call SetUndoFtplugin(<q-args>)

" Startup config
const s:Windows = has('win32')
const s:Unix = !s:Windows
if has('vim_starting')
  if has('multi_lang')
    if has('menu')
      set langmenu=ja.utf-8
    endif
  endif

  if &term =~# '\<256color\>' && expand('$TERM_PROGRAM') !=# 'Apple_Terminal'
    set termguicolors  " Use true color if possible.
  endif
  if &term =~# '\<xterm\>'
    let &t_EI = "\<ESC>[2 q"  " Use Block style cursor in Normal-mode.
    let &t_SI = "\<ESC>[6 q"  " Use Bar style cursor in Insert-mode.
    let &t_SR = "\<ESC>[4 q"  " Use underline style cursor in Replace-mode.
    set mouse=a
  endif

  let s:filesystem = {}
  if s:Windows
    let $DOT_VIM = expand('~\vimfiles')
    " let s:filesystem.slash = '\'
    " let s:filesystem.path_separator = ';'
    " let s:filesystem.rcfile_prefix = '_'
  else
    let $DOT_VIM = expand('~/.vim')
    " let s:filesystem.slash = '/'
    " let s:filesystem.path_separator = ':'
    " let s:filesystem.rcfile_prefix = '.'
  endif

  " disable default plugins
  let g:loaded_2html_plugin = 1
  let g:loaded_getscriptPlugin = 1
  let g:loaded_gzip = 1
  let g:loaded_zipPlugin = 1
  let g:loaded_tarPlugin = 1
  let g:loaded_vimballPlugin = 1
  let g:loaded_netrwPlugin = 1

  let &runtimepath ..= ',' .. escape(s:JoinPath($DOT_VIM, 'runtime'), ' \')

  " Set environmental variables on gVim.
  let s:_envrc = s:JoinPath(expand('~'), s:Rc('envrc'))
  if has('gui_running') && filereadable(s:_envrc)
    let s:contents = readfile(s:_envrc)
    call map(s:contents, "substitute(v:val, '\\(\\_^\\|\\s\\)#.*$', '', 'g')")
    call filter(s:contents, '!empty(v:val)')
    call map(s:contents, "split(v:val, '=')")
    call map(s:contents,
        \ "execute(printf('let $%s=%s', v:val[0], string(expand(v:val[1]))))")
    unlet s:contents
  endif | unlet s:_envrc
endif
" Initialize autocmd
def! s:InitializeAutocmd(filename: string)
  var pattern = '^\s*aug\%[roup]\s\+\zs\S\+\ze\s*'
  var augroups = readfile(filename)
                    ->filter({_, line -> stridx(line, 'aug') != -1})
                    ->filter({_, line -> line =~# pattern})
                    ->map({_, line -> matchstr(line, pattern)})
                    ->filter({_, augroup -> augroup !=? 'END'})
                    ->sort()
                    ->uniq()
  for augroup in augroups
    execute 'augroup ' .. augroup
      autocmd!
    execute 'augroup END'
  endfor
enddef
call s:InitializeAutocmd(expand('<sfile>'))
delfunction s:InitializeAutocmd

" minpac
if &loadplugins
  let s:plugin_list = map(filter(s:glob(
        \ s:JoinPath($DOT_VIM, 'pack', 'minpac', 'start', '*')
        \), 'isdirectory(v:val)'), 'fnamemodify(v:val, ":p:h:t")')
  function! s:PluginExists(plugin) abort
    return s:has(s:plugin_list, a:plugin)
  endfunction
else
  function! s:PluginExists(plugin) abort
    return 0
  endfunction
endif
def! s:PackRegister(): void
  minpac#add('k-takata/minpac', {'type': 'opt'})

  minpac#add('itchyny/vim-cursorword')
  minpac#add('kana/vim-altr')
  minpac#add('kana/vim-gf-user')
  minpac#add('kana/vim-operator-replace')
  minpac#add('kana/vim-operator-user')
  minpac#add('kana/vim-textobj-entire')
  minpac#add('kana/vim-textobj-function')
  minpac#add('kana/vim-textobj-indent')
  minpac#add('kana/vim-textobj-line')
  minpac#add('kana/vim-textobj-user')
  # minpac#add('lambdalisue/fila.vim')
  minpac#add('lambdalisue/gina.vim')
  minpac#add('lambdalisue/vim-findent')
  minpac#add('lambdalisue/vim-gista')
  minpac#add('mattn/vim-lsp-settings')
  minpac#add('mityu/vim-brownie')
  minpac#add('mityu/vim-gram')
  minpac#add('mityu/vim-gram-sources')
  minpac#add('mityu/vim-textobj-commentblock')
  minpac#add('osyo-manga/vim-jplus')
  minpac#add('osyo-manga/vim-operator-swap')
  minpac#add('prabirshrestha/async.vim')
  minpac#add('prabirshrestha/asyncomplete-buffer.vim')
  minpac#add('prabirshrestha/asyncomplete-lsp.vim')
  minpac#add('prabirshrestha/asyncomplete.vim')
  minpac#add('prabirshrestha/vim-lsp')
  minpac#add('previm/previm')
  minpac#add('rhysd/vim-operator-surround')
  minpac#add('sgur/vim-gf-autoload')
  minpac#add('sgur/vim-operator-openbrowser')
  minpac#add('thinca/vim-ambicmd')
  minpac#add('thinca/vim-ft-help_fold')
  # minpac#add('thinca/vim-operator-sequence')
  minpac#add('thinca/vim-partedit')
  minpac#add('thinca/vim-prettyprint')
  minpac#add('thinca/vim-quickrun')
  minpac#add('thinca/vim-textobj-between')
  minpac#add('thinca/vim-themis')
  minpac#add('tyru/capture.vim')
  minpac#add('tyru/caw.vim')
  minpac#add('tyru/open-browser.vim')
  minpac#add('vim-jp/autofmt')
  minpac#add('vim-jp/syntax-vim-ex')
  minpac#add('vim-jp/vimdoc-ja')
  minpac#add('vim-jp/vital.vim')
  minpac#add('vim-scripts/autodate.vim')

  minpac#add('gyim/vim-boxdraw', {'type': 'opt'})
  # minpac#add('mityu/vim-readingvimrc-files', {'type': 'opt'})
  minpac#add('tweekmonster/helpful.vim', {'type': 'opt'})
  minpac#add('y0za/vim-reading-vimrc', {'type': 'opt'})
  minpac#add('rbtnn/vim-coloredit', {'type': 'opt'})
enddef
def! s:PackInit(): bool
  try
    packadd minpac
  catch /^Vim\%((\a\+)\)\=:E919/
    # Download minpac...
    var minpac_path = s:JoinPath($DOT_VIM, 'pack', 'minpac', 'opt', 'minpac')
    s:echomsg('Downloading minpac...')
    system('git clone https://github.com/k-takata/minpac.git ' ..
          \ minpac_path)
    try
      packadd minpac
    catch
      echoerr v:exception
      return false
    endtry
  endtry

  minpac#init()
  s:PackRegister()

  return true
enddef
def! s:PackUpdate(): void
  if s:PackInit()
    minpac#update()
  endif
enddef
def! s:PackClean(): void
  if s:PackInit()
    minpac#clean()
  endif
enddef
def! s:PackStatus()
  if exists('*minpac#status')
    minpac#status()
  else
    s:EchomsgError('minpac isn''t loaded yet.')
  endif
enddef
command! -bar PackInit   call s:PackInit()
command! -bar PackUpdate call s:PackUpdate()
command! -bar PackClean  call s:PackClean()
command! -bar PackStatus call s:PackStatus()

" Options
syntax on
filetype plugin indent on
colorscheme domusaurea
language C
set relativenumber number
set wrap
set smartindent autoindent
set cinoptions=:0,g0,N-s,E-s
set backspace=eol,start,indent
set pumheight=10
set completefunc=vimrc#pathComplete
set noequalalways
set scrolloff=1
set colorcolumn=78
set tabstop=4
set shiftwidth=4
set expandtab
set smarttab
set softtabstop=4
set hlsearch
set display=lastline
set listchars=tab:\|-
set autoread
set incsearch ignorecase
set showmatch matchtime=1
set cursorline cursorlineopt=number
set laststatus=2
set showtabline=2
set cmdheight=2 cmdwinheight=10
set wildmenu
set wildignore& wildignore+=*.DS_STORE,*.jpg,*.png,*.gif
set history=500
set keywordprg=:help
set shortmess& shortmess+=Ic
set helplang=ja
set foldmethod=marker
set hidden
set diffopt=internal,algorithm:histogram
"set breakindent
"set virtualedit& virtualedit+=block
set virtualedit=block
set complete=.,i,d,w,b,u
set noimdisable
set lazyredraw
set previewpopup=highlight:Normal
set termwinkey=<C-w>
set noesckeys
set nowrapscan


let s:cache_dir = s:JoinPath(expand('~'), '.cache', 'vimrc')
call s:Mkdir(s:cache_dir, 'p')
let s:_undodir = s:JoinPath(s:cache_dir, 'undodir')
if s:Mkdir(s:_undodir, 'p')
  set undofile
  let &undodir = s:_undodir
else
  set noundofile
endif
unlet s:_undodir

let s:_directory = s:JoinPath(s:cache_dir, 'swapfile')
if s:Mkdir(s:_directory, 'p')
  set swapfile
  let &directory = s:JoinPath(fnamemodify(s:_directory, ':p'), '')
else
  set noswapfile
endif
unlet s:_directory
set nobackup nowritebackup

if has('kaoriya')
  set fileencodings=guess,utf-8
  set ambiwidth=auto
else
  set fileencodings=utf-8
  set ambiwidth=double
endif
if s:Unix
  set path& path+=/usr/local/include
endif
if executable('ag')
  let &grepprg = 'ag --vimgrep'
  let &grepformat = '%f:%l:%c:%m'
endif
augroup vimrc_syntax
  autocmd User vimrc_initialize syntax enable
augroup END
augroup vimrc_filetype
  autocmd FileType c,cpp setlocal foldmethod=indent
  autocmd BufRead .envrc set filetype=sh
  autocmd FileType makefile setlocal noexpandtab nosmarttab

  " Cannot set foldexpr in modeline without modelineexpr, so use autocmd.
  execute 'autocmd BufRead ' .. $MYVIMRC .. ' setlocal foldmethod=expr ' ..
        \ 'foldexpr=FoldExprForVimrc()'
augroup END
augroup vimrc_mru
  autocmd BufWritePost * call vimrc#mru#onReadFile()  " TODO: Change func name
augroup END
augroup vimrc_checktime
  autocmd CursorHold * if getcmdwintype() ==# '' | checktime | endif
augroup END
"
" Mapping
nnoremap : q:A
vnoremap : q:A
nnoremap <Space>: q:k
vnoremap <Space>: q:k
nnoremap / q/A
vnoremap / q/A
nnoremap <Space>/ q/k
vnoremap <Space>/ q/k
nnoremap ? q?A
vnoremap ? q?A
nnoremap <Space>? q?k
vnoremap <Space>? q?k
nnoremap <Space>; :
vnoremap <Space>; :

noremap - <C-x>
noremap + <C-a>

nnoremap j gj
nnoremap k gk
nnoremap <CR> o<ESC>
nnoremap <S-CR> O<ESC>
nnoremap Y y$
nnoremap <C-h> <Cmd>nohlsearch<CR>
nnoremap <C-w>s <Cmd>belowright wincmd s<CR>
nnoremap <C-w><C-s> <Cmd>belowright wincmd s<CR>
nnoremap <C-w>v <Cmd>belowright wincmd v<CR>
nnoremap <C-w><C-v> <Cmd>belowright wincmd v<CR>
nnoremap <C-w>c <Cmd>belowright copen<CR>
nnoremap <C-w>t <Cmd>tabnew<CR>
nnoremap <C-w><C-t> <Cmd>tabnew<CR>
nnoremap <Space>th <Cmd>vertical terminal ++close<CR>
nnoremap <Space>tj <Cmd>belowright terminal ++close<CR>
nnoremap <Space>tk <Cmd>terminal ++close<CR>
nnoremap <Space>tl <Cmd>belowright vertical terminal ++close<CR>
nnoremap <Space>tt <Cmd>tab terminal ++close<CR>
nnoremap <Space>w <Cmd>update<CR>
nnoremap <Space>q <Cmd>quit<CR>
nnoremap ZZ <Nop>
nnoremap ZQ <Nop>
nnoremap <nowait> Z <Cmd>call <SID>toggle_zooming_window()<CR>
nnoremap <C-w>z <Cmd>call <SID>toggle_zooming_window()<CR>
" nnoremap <expr> n 'Nn'[v:searchforward] .. 'zzzv'
" nnoremap <expr> N 'nN'[v:searchforward] .. 'zzzv'
nnoremap <C-k> 7gk
nnoremap <C-j> 7gj
" Avoid to regester calling textobj function commands to the command-history
" when use textobj via dot.
nnoremap <silent> . .
nnoremap * *N

inoremap <C-m> <C-g>u<C-m>
inoremap <C-u> <C-g>u<C-u>
inoremap <C-j> <C-g>u<C-j>
inoremap <C-l> <C-x>
inoremap <silent> <expr> <C-y> pumvisible() ? '<C-y>' : '<C-r>=vimrc#pinsnip#expand()<CR>'

vnoremap g+ g<C-a>
vnoremap g- g<C-x>
vnoremap <C-k> 7gk
vnoremap <C-j> 7gj

cnoremap <C-l> <C-f>
cnoremap <C-f> <Right>
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>
cnoremap <C-b> <Left>
cnoremap <C-a> <C-b>
cnoremap <C-[> <C-c>

let s:Omap = {range, lhs, rhs ->
      \[execute(printf('onoremap %s%s %s%s', range, lhs, range, rhs)),
      \execute(printf('vnoremap %s%s %s%s', range, lhs, range, rhs))]}
let s:EnhancedOmap = {lhs, rhs ->
      \ [s:Omap('a', lhs, rhs), s:Omap('i', lhs, rhs)]
      \}
call s:EnhancedOmap('2', '"')
call s:EnhancedOmap('7', "'")
call s:EnhancedOmap('8', '(')
call s:EnhancedOmap(', ', '<')
unlet s:Omap s:EnhancedOmap

def! s:TerminalMap(mapcmd: string, lhs: string, rhs: string, mods: string = ''): void
  execute printf('%s %s %s%s %s%s',
       \ mapcmd, mods, &termwinkey, lhs, &termwinkey, rhs)
enddef
call s:TerminalMap('tnoremap', ':', ':<C-f>A')
call s:TerminalMap('tnoremap', '<Space>:', ':<C-f>k')
call s:TerminalMap('tnoremap', '<ESC>', 'N')
call s:TerminalMap('tnoremap', 'p', '""')
call s:TerminalMap('tnoremap', '<C-r>', '"')

" Loop
function! s:_loop_define(config) abort
  let prefix = printf('<Plug>(<SID>-loop-%s)', a:config.id)
  let enter_with = a:config.enter_with
  let mode = get(a:config, 'mode', 'n')
  let plug_map = {}
  for key in ['prefix', 'main', 'do']
    let plug_map[key] = printf("%s(%s)", prefix, key)
  endfor

  execute printf('%snoremap %s <Nop>', mode, plug_map.prefix)
  for [lhs, rhs] in a:config.map
    let [lhs, rhs] =
          \ map([lhs, rhs], {_, val -> substitute(val, '|', '<bar>', 'g')})
    let com = []
    call add(com, [mode .. 'noremap',
          \ plug_map.do .. lhs,
          \ rhs])
    call add(com, [mode .. 'map',
          \ enter_with .. lhs,
          \ plug_map.main .. lhs])
    call add(com, [mode .. 'map',
          \ plug_map.main .. lhs,
          \ plug_map.do .. lhs .. plug_map.prefix
          \])
    call add(com, [mode .. 'map',
          \ plug_map.prefix .. lhs,
          \ plug_map.main .. lhs])
    execute join(map(com, 'join(v:val, " ")'), "\n")
  endfor

  if mode ==# 'n'
    let config = deepcopy(a:config)
    let config.mode = 't'
    call map(config.map, 's:_loop_define_generate_tmap(v:val)')
    call s:_loop_define(config)
  endif
endfunction
function! s:_loop_define_generate_tmap(value) abort
  let rhs = a:value[1]
  let rhs = substitute(rhs, '\c<SID>', s:SIDPrefix(), 'g')
  let rhs = substitute(rhs, '\zs<\ze.\{-}>', '\\<lt>', 'g')
  let rhs = '<Cmd>execute "normal! ' .. rhs .. '"<CR>'
  return [a:value[0], rhs]
endfunction
function! s:_simple_loop_define(config) abort
  let config = deepcopy(a:config)
  let config.map = map(split(config.follow_key, '\zs'),
        \ '[v:val, config.enter_with .. v:val]')
  call s:_loop_define(config)
endfunction
"Window management
call s:_simple_loop_define({
      \ 'id': 'Window',
      \ 'enter_with': '<C-w>',
      \ 'follow_key': 'hjklHJKLq<>-+_|='
      \ })
call s:_loop_define({
      \ 'id': 'Tab',
      \ 'enter_with': 'g',
      \ 'map': [
      \   ['h', 'gT'],
      \   ['l', 'gt'],
      \   ['T', '<Cmd>call <SID>MapTabmove(-1)<CR>'],
      \   ['t', '<Cmd>call <SID>MapTabmove(1)<CR>']
      \ ]
      \ })
def! s:MapTabmove(delta: number)
  var tab_count = tabpagenr('$')
  if tab_count == 1
    return
  endif
  var current = tabpagenr() - 1
  var move_to = current + delta
  if move_to < 0
    while move_to < 0
      move_to += tab_count
    endwhile
  endif
  if move_to >= tab_count
    move_to = move_to % tab_count
  endif
  var movement = move_to - current
  var movecmd = 'tabmove '
  if movement < 0
    movecmd ..= string(movement)
  else
    movecmd ..= '+' .. string(movement)
  endif
  execute movecmd
enddef
delfunc s:_loop_define
delfunc s:_simple_loop_define
"
" Shift-ten-key
let s:ten_key_pair = [
      \['1', '!'],
      \['2', '"'],
      \['3', '#'],
      \['4', '$'],
      \['5', '%'],
      \['6', '&'],
      \['7', "'"],
      \['8', '('],
      \['9', ')'],
      \]
let s:ten_key_mapbase = '<Plug>(vimrc-tenkey-%s)'
for s:pair in s:ten_key_pair
  for s:key in s:pair
    execute 'inoremap' printf(s:ten_key_mapbase, s:key) s:key
  endfor
  unlet s:key
endfor|unlet s:pair
function! s:ShiftTenKey(enablize) abort
  if a:enablize
    for [key1, key2] in s:ten_key_pair
      execute 'imap' key1 printf(s:ten_key_mapbase, key2)
      execute 'imap' key2 printf(s:ten_key_mapbase, key1)
    endfor
  else
    for [key1, key2] in s:ten_key_pair
      execute 'imap' key1 printf(s:ten_key_mapbase, key1)
      execute 'imap' key2 printf(s:ten_key_mapbase, key2)
    endfor
  endif
endfunction
command! -bar EnableShiftTenKey call s:ShiftTenKey(1)
command! -bar DisableShiftTenKey call s:ShiftTenKey(0)


" Use :execute here to avoid creepy highlight.
execute 'digraphs (( 65288'
execute 'digraphs )) 65289'
execute 'digraphs {{ 12302'
execute 'digraphs }} 12303'
digraphs [[ 12300
digraphs ]] 12301
digraphs sp 12288
digraphs \"\" 8221
digraphs !! 65281
digraphs ?? 65311
digraphs << 65308
digraphs >> 65310
digraphs ,, 12289
digraphs .. 12290
digraphs -- 12540

function! s:cmdwin_enter() abort
  " Type <CR> to execute current line in command-line window.
  nnoremap <buffer> <CR> <CR>

  " Return back to the current window from command-line window with
  " inputting <C-c> once.
  nnoremap <buffer> <C-c> <C-c><C-c>
  nmap <buffer> q <C-c>
  imap <buffer> <C-c> <ESC><C-c>

  inoremap <buffer> <C-l><C-n> <C-x><C-n>
  inoremap <buffer> <C-l><C-p> <C-x><C-n>

  " Execute an previous command easiler.
  nnoremap <buffer> / <Cmd>call <SID>CmdwinSelectHistory()<CR>

  set completefunc=vimrc#pathComplete

  let cmdwin_type = expand('<afile>')
  if cmdwin_type ==# ':'
    inoremap <expr> <buffer> <C-p> <SID>cmdwin_completion(0)
    inoremap <expr> <buffer> <C-n> <SID>cmdwin_completion(1)
    let s:cmdwin_save_options = vital#vital#import('Vim.Guard').store(['&l:completeopt'])
    setlocal completeopt=menu,preview
    " TODO: Delete lines only when gram.vim is loaded.
    execute printf('silent! 1,$-%d delete _', &cmdwinheight)
    normal! G
    call asyncomplete#disable_for_buffer()
  elseif s:has('/?', cmdwin_type)
    " NOTE: :set hlsearch here does not work.
    augroup vimrc_incsearch
      autocmd!
      autocmd TextChanged,TextchangedI,CursorMoved <buffer>
           \ call s:cmdwin_incsearch()
    augroup END
    let s:cmdwin_incsearch = {'pattern_save': @/}
    if exists('*win_execute')
      let s:cmdwin_incsearch.current_winid = win_getid(winnr('#'))
      function! s:cmdwin_incsearch.win_execute(command) abort
        return s:WinExecute(self.current_winid, a:command)
      endfunction
      call s:cmdwin_incsearch.win_execute(
            \ 'let s:cmdwin_incsearch.curpos = getpos(".")')
    endif
  endif
endfunction
function! s:cmdwin_leave() abort
  if exists('s:cmdwin_save_options')
    call s:cmdwin_save_options.restore()
  endif
  if s:has('/?', expand('<afile>'))
    let @/ = s:cmdwin_incsearch.pattern_save
    if has_key(s:cmdwin_incsearch, 'curpos')
      call s:cmdwin_incsearch.win_execute(
            \ 'call setpos(".", s:cmdwin_incsearch.curpos)')
    endif
    augroup vimrc_incsearch
      autocmd!
    augroup END
  endif
endfunction
function! s:cmdwin_completion(select_next) abort
  if pumvisible()
    return a:select_next ? '<C-n>' : '<C-p>'
  else
    return "\<C-x>\<C-v>"
  endif
endfunction
function! s:cmdwin_incsearch() abort
  let @/ = getline('.')
  if exists('*win_execute')
    call s:cmdwin_incsearch.win_execute('call s:cmdwin_incsearch_jump()')
  endif
  set hlsearch
  redraw
endfunction
function! s:cmdwin_incsearch_jump() abort
  call setpos('.', s:cmdwin_incsearch.curpos)
  try
    normal! n
  catch
  endtry
endfunction
def! s:CmdwinSelectHistory()
  var history = split(execute('history ' .. getcmdwintype()), "\n")[1 :]
  map(history, {_, val -> matchstr(val, '^>\?\s*\d\+\s\+\zs.\+$')})
  reverse(history)
  gram#select({
         name: getcmdwintype() .. 'history',
         items: history,
         callback: s:SIDPrefix() .. 'CmdwinSelectHistoryCallback',
       })
enddef
def! s:CmdwinSelectHistoryCallback(item: dict<string>)
  if getline('$') ==# ''
    setline('$', item.word)
  else
    append('$', item.word)
  endif
  execute 'noautocmd normal! G$'
enddef

augroup vimrc_mapping
  autocmd CmdWinEnter * call s:cmdwin_enter()
  autocmd CmdWinLeave * call s:cmdwin_leave()
augroup END

if has('mac')
  let mapleader = '_'
endif
if has('win32')
  inoremap \ _
  inoremap _ \
endif

" Command
let s:_map = []
call add(s:_map, ['nnoremap', 'ev', 'edit $MYVIMRC'])
call add(s:_map, ['nnoremap', 'sv', 'source $MYVIMRC'])
call add(s:_map, ['nnoremap', 'k', 'call vimrc#mru#start()'])
call add(s:_map, ['nnoremap', 'b', 'call gram#sources#buffers#launch()'])
call add(s:_map, ['nnoremap', 'j', 'call <SID>GofForMapping()'])
call add(s:_map, ['nnoremap', 'f', 'call vimrc#filore#start()'])
call add(s:_map, ['nnoremap', 'm', 'MemoList'])
call add(s:_map, ['nnoremap', 'o', 'OtameshiList'])
execute join(map(s:_map, {->join([
      \  v:val[0],
      \  '<Space>' .. v:val[1],
      \  printf('<Cmd>%s<CR>', v:val[2])
      \ ], ' ')}), "\n")
unlet s:_map


" Abbreviates
iabbrev todo: TODO:
iabbrev fixme: FIXME:
iabbrev xxx: XXX:
iabbrev note: NOTE:

" Commands
" Declarations
command! -bar CdCurrent cd %:p:h
command! -bar LcdCurrent lcd %:p:h
command! -bar TcdCurrent tcd %:p:h
command! -nargs=1 -complete=file Rename file <args>|call delete(expand('#'))
command! CopyToClipboard let @*=@"
command! ClearMessage execute repeat("echom ''\n", 201)
command! Helptags helptags ALL
command! -bang -nargs=+ -complete=command Filter call s:filter(<bang>0, <f-args>)
command! -bar Draft call s:Draft()
command! -bar UnDraft call s:Undraft()
command! -bar -nargs=* -complete=customlist,VimrcScratchComplete
      \ Scratch call s:Scratch(<q-args>)
command! -bar -nargs=+ -complete=command Vimrc <args> $MYVIMRC
command! -bar -nargs=* -complete=file ListTasks call s:ListTasks(<q-args>)
command! DeleteUndoFiles call vimrc#delete_undofiles()
command! -nargs=? -complete=dir Gof call s:Gof(<q-args>)

" Plugin Shortcuts
command! -bar -nargs=* MruEditHistoryStart call vimrc#mru#edit_history_start(<q-args>)
command! -bar MruDeleteUnexistHistory call vimrc#mru#delete_unexist_file_history()
command! -bar -nargs=? -complete=dir Filore call vimrc#filore#start(<q-args>)
command! -bar -bang -nargs=? -complete=dir Ls call vimrc#shcmd#ls(<bang>0, <f-args>)
command! -bar -bang -nargs=+ -complete=dir Mkdir call vimrc#shcmd#mkdir(<bang>0, <f-args>)
command! -bar -nargs=+ -complete=dir Touch call vimrc#shcmd#touch(<f-args>)
command! -bar -nargs=+ -complete=dir CpFile call vimrc#shcmd#cpfile(<f-args>)
command! -bar -bang -nargs=+ -complete=file Rm call vimrc#shcmd#rm(<bang>0, <f-args>)

def! Filter(pat: string, com: string): list<string>
  return execute(com)->split("\n")->filter({_, val -> val =~? pat})
enddef
def! s:filter(bang: number, pat: string, ...cmd: list<string>): void
  var output = Filter(pat, join(cmd, ' '))->join("\n")
  if bang
    echomsg output
  else
    echo output
  endif
enddef
function! s:Draft() abort
  let b:vimrc_draft_save_options = vital#vital#import('Vim.Guard').store(['&l:buftype', '&l:swapfile'])
  setlocal buftype=nofile noswapfile
endfunction
def! s:Undraft()
  if !exists('b:vimrc_draft_save_options')
    return
  endif
  call b:vimrc_draft_save_options.restore()
enddef
def! s:Scratch(opener_arg: string)
  var opener = opener_arg
  var prefix = 'scratch://'
  var name = s:input('Scratch buffer name? ')
  if name ==# ''
    var identifier = 1
    name = 'nameless/buffer-'
    while bufexists(prefix .. name .. string(identifier))
      identifier += 1
    endwhile
    name ..= string(identifier)
  endif
  if opener ==# ''
    opener = 'split'
  endif
  execute opener prefix .. name
  s:Draft()
enddef
def! VimrcScratchComplete(lead: string, line: string, pos: number): list<string>
  var pat = '^' .. lead
  return filter(['split', 'vsplit', 'tabedit', 'edit'], {_, val -> val =~? pat})
enddef
def! s:ListTasks(args: string)
  var target = '%'
  if args =~# 'rf'
    target = '**/*.' .. expand('%:e')
  elseif args !=# ''
    target = args
  endif
  execute 'vimgrep /\C\v<(TODO|FIXME|XXX)>/' target
enddef
def! s:FindGitroot(arg_target: string = bufname('%')): string
  var target: string = resolve(arg_target)
  var git_dir: string = finddir('.git', target .. ';')
  if git_dir ==# ''
    s:EchomsgWarning('Not a git repository: ' .. target)
    return ''
  endif
  return fnamemodify(git_dir, ':h')
enddef
def! s:Gof(path: string): void
  if !executable('gof')
    echo '"gof" command not found.'
    return
  endif
  var gofcmd = 'gof -f -tf "Tapi_gof"'
  if !empty(path)
    gofcmd ..= ' -d ' .. path
  endif
  var minwidth = min([&columns, 100])
  var minheight = min([&lines, 40])
  popup_create(term_start(gofcmd, {'hidden': 1, 'term_finish': 'close'}),
        \ {'minwidth': minwidth, 'minheight': minheight})
enddef
def! s:GofForMapping()
  var git_root = s:FindGitroot()
  s:Gof(git_root ==# '' ? getcwd(winnr()) : git_root)
enddef
"TODO: Add export when I add :vim9script on the top of this file.
def! Tapi_gof(bufnum: number, file_info: dict<string>): void
  var winid = win_getid(winnr('#'))
  var buftype = getwinvar(winid, '&buftype')
  var open_cmd = 'edit'
  if !(buftype ==# 'nofile' || buftype ==# '')
    open_cmd = 'split'
  endif
  call win_execute(winid,
         printf('%s %s', open_cmd, fnameescape(file_info.fullpath)))
enddef

" Installed plugins
if s:PluginExists('vim-altr')
  command! -bar AlterForward call altr#forward()
  command! -bar AlterBack call altr#back()
endif
if s:PluginExists('vim-operator-replace')
  map _r  <Plug>(operator-replace)
endif
if s:PluginExists('vim-operator-user')
  nmap zf <Plug>(operator-vimrc-fold-zf)
  nmap zF <Plug>(operator-vimrc-fold-zF)
  nmap zd <Plug>(operator-vimrc-fold-zd)
  nmap zD <Plug>(operator-vimrc-fold-zD)
  nmap zE <Plug>(operator-vimrc-fold-zE)
  vmap zf <Plug>(operator-vimrc-fold-zf)
  vmap zF <Plug>(operator-vimrc-fold-zF)
  vmap zd <Plug>(operator-vimrc-fold-zd)
  vmap zD <Plug>(operator-vimrc-fold-zD)
  vmap zE <Plug>(operator-vimrc-fold-zE)
  function! s:map_fold_cmd(keys) abort
    " Available only when foldmethod is marker or manual.
    if !s:has(['marker', 'manual'], &l:foldmethod)
      return
    endif
    let save_options = vital#vital#new('Vim.Guard').store(['&l:commentstring'])
    let &l:commentstring = ' ' .. &l:commentstring
    try
      execute 'normal!' a:keys
    catch " Usaully this :catch gets E490, 'Folding not found.'
      call s:EchomsgError(v:exception)
    finally
      call save_options.restore()
    endtry
  endfunction
  function! s:map_range_fold_cmd(motion_wizeness, keys) abort
    let v_cmd = operator#user#visual_command_from_wise_name(a:motion_wizeness)
    call s:map_fold_cmd(printf('`[%s`]%s', v_cmd, a:keys))

    " Remove spaces in beginning of the line which are inserted when the line was
    " an empty line.
    if &foldmethod ==# 'marker'
      let marker_only_pat = '\m^\s\+%s'
      let marker_pair = ["'[", "']"]
      let foldmarker_pair = split(&l:foldmarker, ', ')
      for index in range(0, len(foldmarker_pair)-1)
        let marker = marker_pair[index]
        let foldmarker = printf(&l:commentstring, foldmarker_pair[index])
        let lnum = getpos(marker)[1]
        if getline(lnum) =~# printf(marker_only_pat, foldmarker)
          call setline(lnum, foldmarker)
        endif
      endfor
    endif
  endfunction
  function! s:map_define_operator() abort
    " ---fold---
    let foldmotions_with_range = 'fF'
    let foldmotions_standalone = 'dDE'
    let sid = s:SIDPrefix()
    for keys in split(foldmotions_with_range .. foldmotions_standalone, '\zs')
      let keys = 'z' .. keys
      let func = [
            \ printf('function! %smap_fold_%s(motion_wise) abort', sid, keys),
            \ printf('  call s:map_range_fold_cmd(a:motion_wise, "%s")', keys),
            \ 'endfunction'
            \]
      execute join(func, "\n")
      call operator#user#define(
            \ 'vimrc-fold-' .. keys,
            \ sid .. 'map_fold_' .. keys)
    endfor

    " Override for normal mode; Any ranges aren't need for following commands.
    let map_cmd = join(['nnoremap',
          \ '<silent>',
          \ '<Plug>(operator-vimrc-fold-%s)',
          \ '<Cmd>call <SID>map_fold_cmd("%s")<CR>'], ' ')
    for keys in split(foldmotions_standalone, '\zs')
      let keys = 'z' .. keys
      execute printf(map_cmd, keys, keys)
    endfor
  endfunction
  augroup vimrc_mapping
    autocmd User vimrc_initialize call s:map_define_operator()
  augroup END
endif
if s:PluginExists('vim-textobj-entire')
  omap aa <Plug>(textobj-entire-a)
  omap ia <Plug>(textobj-entire-i)
  vmap aa <Plug>(textobj-entire-a)
  vmap ia <Plug>(textobj-entire-i)
  let g:textobj_entire_no_default_key_mappings = 1
endif
if s:PluginExists('vim-textobj-function')
  omap if <Plug>(textobj-function-i)
  omap af <Plug>(textobj-function-a)
  vmap if <Plug>(textobj-function-i)
  vmap af <Plug>(textobj-function-a)
  let g:textobj_function_no_default_key_mappings = 1
endif
if s:PluginExists('vim-textobj-indent')
  omap ii <Plug>(textobj-indent-i)
  omap iI <Plug>(textobj-indent-same-i)
  omap ai <Plug>(textobj-indent-a)
  omap aI <Plug>(textobj-indent-same-a)
  vmap ii <Plug>(textobj-indent-i)
  vmap iI <Plug>(textobj-indent-same-i)
  vmap ai <Plug>(textobj-indent-a)
  vmap aI <Plug>(textobj-indent-same-a)
  let g:textobj_indent_no_default_key_mappings = 1
endif
if s:PluginExists('gina.vim')
  let g:gina#action#mark_sign_text = '*'
  let g:gina#core#console#enable_message_history = 1

  def! s:gina_config()
    def Gina_nnoremap(scheme: string, lhs: string, rhs: string)
      gina#custom#mapping#nmap(scheme, lhs, rhs, {noremap: 1, silent: 1})
    enddef

    Gina_nnoremap('status', '<C-]>', '<Cmd>Gina commit<CR>')
    Gina_nnoremap('commit', '<C-]>', '<Cmd>Gina status<CR>')
    Gina_nnoremap('status', '<Space>g', '<Cmd>Gina commit<CR>')
    Gina_nnoremap('commit', '<Space>g', '<Cmd>Gina status<CR>')
    Gina_nnoremap('branch', 'N',
            '<Cmd>call gina#action#call("branch:new")<CR>')
    Gina_nnoremap('/\v%(status|branch|log)', 'q', '<Cmd>close<CR>')
    nnoremap <Space>g <Cmd>Gina status<CR>

    # Jump between unadded files with n/p ..
    var rhs_base = printf(
            '<Cmd>call %sGinaStatusSelectAnother(v:count1, %%s)<CR>',
            s:SIDPrefix())
    Gina_nnoremap('status', 'n', printf(rhs_base, v:false))
    Gina_nnoremap('status', 'N', printf(rhs_base, v:true))

    Gina_nnoremap('status', 'dd',
           printf('<Cmd>call %sGinaDiff()<CR>', s:SIDPrefix()))

    gina#custom#action#alias('branch', 'merge', 'commit:merge:no-ff')
    gina#custom#action#alias('branch', 'merge-ff', 'commit:merge:ff')

    gina#custom#command#option('\v%(^<%(cd|lcd|qrep)>)@<!$', '--opener=edit')
  enddef
  def! s:GinaStatusSelectAnother(repeat_count: number, search_previous: bool)
    var flags = 'w'
    flags ..= search_previous ? 'b' : ''
    for i in range(1, repeat_count)
      search('\e[31.\+\e[m', flags)
    endfor
  enddef
  def! s:GinaDiff()
    var filename = matchstr(getline('.'), '\e[31m\zs.\+\ze\e[m')
    filename = matchstr(filename, '\%(\_^modified\:\s\+\)\?\zs.\+')
    if filename ==# ''
      return
    endif
    var gitroot = fnamemodify(gina#core#get().repository, ':h')
    var cmd = 'git -C ' .. gitroot ..
            ' --no-pager diff --no-color ' .. filename
    var bufnr = term_start(cmd, {
            term_name: '[gina diff] ' .. filename,
            norestore: 1,
            })
    if bufnr != 0
      setlocal nocursorline nocursorcolumn filetype=diff
      nnoremap <buffer> <nowait> q <Cmd>quit<CR>
      cursor(1, 0)
    endif
  enddef
  augroup vimrc_gina
    autocmd User vimrc_initialize call s:gina_config()
  augroup END
endif
if s:PluginExists('vim-findent')
  augroup vimrc_findent
    autocmd FileType * if &l:modifiable | execute 'Findent' | endif
  augroup END
endif
if s:PluginExists('vim-Verdin')
  let g:Verdin#autoparen = 1
endif
if s:PluginExists('vim-brownie')
  let g:brownie_template_dirs =
        \ [s:JoinPath(expand('$DOT_VIM'), 'runtime', 'extension', 'brownie')]
  let g:brownie_extra_imports = {
        \ 'cpp' : ['c'],
        \ 'vimspec': ['vim'],
        \ }

  def! s:BrownieFiletype(): string
    return getbufvar(brownie#get_current_bufnr(), '&filetype')
  enddef
  def! VimrcTemplateComplete(arg: string, line: string, pos: number): list<string>
    return filter(brownie#list(s:BrownieFiletype(), 'template'),
                {_, val -> stridx(val, arg) == 0})
  enddef

  command! -nargs=1 -complete=customlist,VimrcTemplateComplete Template
        \ call brownie#extract(s:BrownieFiletype(), 'template', <q-args>)
endif
if s:PluginExists('vim-gram')
  augroup vimrc_gram_init
    autocmd User gram-first-start call s:InitGramMapping()
  augroup END

  def! s:InitGramMapping()
    gram#custom#map_action('n', '<CR>', 'select-item')
    gram#custom#map_action('n', 'q', 'quit')
    gram#custom#map_action('n', 'j', 'select-next-item')
    gram#custom#map_action('n', 'k', 'select-prev-item')
    gram#custom#map_action('n', 'i', 'start-insert')
    gram#custom#map_action('n', 'p', 'preview')
    gram#custom#map_action('i', '<ESC>', 'stop-insert')
    gram#custom#map_action('i', '<CR>', 'stop-insert')
    gram#custom#map_action('i', '<C-j>', 'stop-insert')
    gram#custom#map_action('i', '<C-h>', 'delete-char')
    gram#custom#map_action('i', '<C-w>', 'delete-word')
    gram#custom#map_action('i', '<C-b>', 'move-to-right')
    gram#custom#map_action('i', '<C-f>', 'move-to-left')
    gram#custom#map_action('i', '<C-a>', 'move-to-head')
    gram#custom#map_action('i', '<C-e>', 'move-to-tail')
    gram#custom#map_action('i', '<C-u>', 'delete-to-head')
    gram#custom#map_key('n', '<NL>', '<CR>')
    gram#custom#map_key('i', '<Del>', '<C-h>')
    gram#custom#map_key('i', '<BS>', '<C-h>')
  enddef
endif
if s:PluginExists('vim-textobj-commentblock')
  omap ac <Plug>(textobj-commentblock-a)
  omap ic <Plug>(textobj-commentblock-i)
  vmap ac <Plug>(textobj-commentblock-a)
  vmap ic <Plug>(textobj-commentblock-i)
  let g:textobj_commentblock_no_default_key_mapings = 1

  augroup vimrc_textobj_commentblock
    execute 'autocmd Filetype * call textobj#commentblock#pick#' ..
          \   (s:PluginExists('caw.vim') ? 'caw' :
          \   'commentstring')
          \ .. '()'
  augroup END
endif
if s:PluginExists('vim-jplus')
  map J <Plug>(jplus)
endif
if s:PluginExists('vim-operator-swap')
  map _sy <Plug>(operator-swap-marking)
  map _sp <Plug>(operator-swap)
endif
if s:PluginExists('asyncomplete.vim')
  " Ignorecase.
  function! s:AsyncompletePreprocessor(context, matches) abort
    let completions = []
    let base = tolower(a:context.base)
    for [source, matches] in items(a:matches)
      for candidate in matches.items
        if stridx(tolower(candidate.word), base) == 0
          call add(completions, candidate)
        endif
      endfor
    endfor
    call asyncomplete#preprocess_complete(a:context, completions)
  endfunction

  let g:asyncomplete_auto_popup = 1
  let g:asyncomplete_force_refresh_on_context_changed = 1
  let g:asyncomplete_smart_completion = 1
  let g:asyncomplete_preprocessor = [function('s:AsyncompletePreprocessor')]
  let g:asyncomplete_auto_completeopt = 0
  set completeopt=menuone,noselect

  inoremap <expr> <C-n>
        \ pumvisible() ? "\<C-n>" : asyncomplete#close_popup() .. "\<C-x>\<C-n>"
  inoremap <expr> <C-p>
        \ pumvisible() ? "\<C-p>" : asyncomplete#close_popup() .. "\<C-x>\<C-p>"
  inoremap <expr> <C-e> pumvisible() ? asyncomplete#cancel_popup() : "\<C-e>"
  inoremap <C-l><C-n> <C-x><C-n><C-n>
  inoremap <C-l><C-p> <C-x><C-p><C-p>

  def! s:RegisterAsyncompleteSources()
    if s:PluginExists('asyncomplete-buffer.vim')
      asyncomplete#register_source(
          asyncomplete#sources#buffer#get_source_options({
            name: 'buffer',
            whitelist: ['*'],
            completor: function('asyncomplete#sources#buffer#completor'),
          }))
    endif
  enddef
  augroup vimrc_asyncomplete_sources
    autocmd User asyncomplete_setup call s:RegisterAsyncompleteSources()
  augroup END
endif
if s:PluginExists('vim-lsp')
  let g:lsp_signs_enabled = 1
  let g:lsp_signs_error = {'text': '>>'}
  let g:lsp_signs_warning = {'text': '--'}
  let g:lsp_signs_information = {'text': '--'}
  let g:lsp_signs_hint = {'text': '? '}
  let g:lsp_diagnostics_enabled = 1
  let g:lsp_diagnostics_float_delay = 10
  let g:lsp_diagnostics_float_cursor = 1

  nnoremap <Plug>(<SID>-open-folding) zv
  nmap <silent> gd <Plug>(lsp-declaration)<Plug>(<SID>-open-folding)
  " nmap <silent> <C-p> <Plug>(lsp-previous-error)
  " nmap <silent> <C-n> <Plug>(lsp-next-error)
endif
if s:PluginExists('previm')
  let g:previm_show_header = 0
  let g:previm_enable_realtime = 1
endif
if s:PluginExists('vim-operator-surround')
  map _sa <Plug>(operator-surround-append)
  map _sd <Plug>(operator-surround-delete)
  map _sr <Plug>(operator-surround-replace)
endif
if s:PluginExists('vim-ambicmd')
  def! s:AmbicmdExpand(key: string): string
    var expander = ambicmd#expand(key)
    return (expander ==# key ? '' : "\<C-g>u") .. expander
  enddef
  augroup vimrc_ambicmd
    autocmd CmdWinEnter : call s:SetupAmbicmdForCmdwin()
  augroup END
  cnoremap <expr> <Space> ambicmd#expand("\<Space>")
  cnoremap <expr> <CR> ambicmd#expand("\<CR>")
  cnoremap <expr> <bar> ambicmd#expand("\<bar>")

  def! s:SetupAmbicmdForCmdwin()
    inoremap <buffer> <expr> <Space> <SID>AmbicmdExpand("\<Space>")
    inoremap <buffer> <expr> <bar> <SID>AmbicmdExpand("\<bar>")
    inoremap <buffer> <expr> <CR> <SID>AmbicmdExpand("\<CR>")
    inoremap <buffer> <expr> <C-y> <SID>AmbicmdExpand('')
  enddef

  let g:ambicmd#show_completion_menu = 1

  def! s:AmbicmdBuildRule(cmd: string): list<string>
    var rule = []
    rule += ['\c^' .. cmd .. '$']
    rule += ['\c^' .. cmd]

    for len in range(1, strlen(cmd))
      var prefix = strpart(cmd, 0, len)->toupper()->substitute('.\zs', '\\l*', 'g')
      var suffix = cmd[len :]
      # prefix = substitute(toupper(prefix), '.\zs', '\\l*', 'g')
      var matcher = '\C^' .. prefix .. suffix
      rule += [matcher .. '$', matcher]
    endfor

    rule += ['\c' .. cmd]
    rule += ['.*' .. substitute(cmd, '.\zs', '.*', 'g')]
    return rule
  enddef
  let g:ambicmd#build_rule = s:SIDPrefix() .. 'AmbicmdBuildRule'
endif
if s:PluginExists('vim-quickrun')
  let g:quickrun_config = {}
  let g:quickrun_config._ = {
    \  'outputter/message': 1,
    \  'outputter/message/log': 1,
    \  'outputter/buffer/close_on_empty': 1,
    \  'runner': 'job',
    \}
  let g:quickrun_config.cpp = {
    \  'cmdopt' : '-std=c++17'
    \}
  " TODO: Improve. (Support windows, etc)
  let g:quickrun_config['cpp/sfml'] = {
    \  'type' : 'cpp',
    \  'cmdopt' : '-std=c++17 -lsfml-audio -lsfml-graphics -lsfml-network -lsfml-system -lsfml-window',
    \}
  let g:quickrun_config.objc = {
    \  'command' : 'cc',
    \  'execute' : ['%c %s -o %s:p:r -framework Foundation', '%s:p:r %a', 'rm -f %s:p:r'],
    \  'tempfile' : '%{tempname()}.m',
    \}
  let g:quickrun_config.applescript = {
    \  'command' : 'osascript',
    \  'execute' : '%c %s:p',
    \  'tempfile' : '%{tempname()}.applescript',
    \}
  let g:quickrun_config.swift = {
    \  'command' : 'swift',
    \  'execute' : '%c %s%p',
    \  'tempfile' : '%{tempname()}.swift',
    \}
  nnoremap <expr> <C-c> quickrun#is_running() ?
        \ '<Cmd>call quickrun#sweep_sessions()<CR>' :
        \ '<C-c>'
  nmap <Space>r <Plug>(quickrun)
  vmap <Space>r <Plug>(quickrun)
  augroup vimrc_filetype
    autocmd FileType quickrun nnoremap <buffer> q <Cmd>q<CR>
  augroup END
endif
if s:PluginExists('vim-textobj-between')
  omap ad <Plug>(textobj-between-a)
  omap id <Plug>(textobj-between-i)
  vmap ad <Plug>(textobj-between-a)
  vmap id <Plug>(textobj-between-i)
  let g:textobj_between_no_default_key_mappings = 1
endif
if s:PluginExists('caw.vim')
  inoremap <Plug>(vimrc:caw:prefix) <C-g>u<ESC>
  inoremap <silent> <Plug>(vimrc:caw:comment:here)
        \ <C-r>=b:caw_oneline_comment<CR>

  def! s:CawMap(): string
    var kind = ''
    if col('.') == 1
      kind = 'zeropos'
    elseif col('.') == col('$')
      kind = 'dollarpos'
    elseif getline('.') =~# '^\s\+$'
      kind = 'hatpos'
    else
      return "\<Plug>(vimrc:caw:comment:here)"
    endif
    return "\<Plug>(vimrc:caw:prefix)\<Plug>(caw:" .. kind .. ":comment)"
  enddef

  map _c <Plug>(caw:hatpos:toggle:operator)
  imap <expr> <C-l><C-l> <SID>CawMap()
  let g:caw_no_default_keymappings = 1
  let g:caw_dollarpos_sp_left = ' '
  let g:caw_dollarpos_sp_right = ' '
  let g:caw_hatpos_sp = ' '
  let g:caw_zeropos_sp = ' '
endif
if s:PluginExists('autofmt')
  set formatexpr=autofmt#japanese#formatexpr()
endif
" ReadingVimrc
command! -bar ReadingVimrc call s:ReadingVimrc()
function! s:ReadingVimrc()
  try
    packadd vim-reading-vimrc
    ReadingVimrcNext
  catch
    call s:EchomsgError(v:throwpoint .. v:exception)
  endtry
endfunction

" Additional plugins
" Taking notes
let s:notes = {'save_dir_': ''}
function! s:notes.instance(path) abort
  let new_obj = deepcopy(self)
  let new_obj.save_dir_ = a:path
  return new_obj
endfunction
function! s:notes.list_files() abort
  return map(s:glob(s:JoinPath(self.save_dir_, '*.*')),
        \ 'fnamemodify(v:val, ":p:t")')
endfunction
function! s:notes.new(opener) abort
  let name = s:input('Name: ')
  if name ==# ''
    call s:echo('Canceled.')
    return
  endif
  if s:has(self, 'expand_filename')
    let name = self.expand_filename(name)
  endif
  let filepath = s:JoinPath(self.save_dir_, name)
  execute (a:opener ==# '' ? 'edit' : a:opener) fnameescape(filepath)
endfunction
function! s:notes.list() abort
  call vimrc#files#start(self.save_dir_)
endfunction
function! s:notes.delete(...) abort
  let files = self.list_files()
  for target in a:000
    if !s:has(files, target)
      call s:EchomsgError('File does not exists: ' .. target)
      continue
    endif
    call s:echomsg(printf('Delete %s ? [y/n]', target))
    if s:GetcharString() !~? 'y'
      call s:echomsg('Canceled.')
      continue
    endif
    if delete(s:JoinPath(self.save_dir_, target)) == 0
      call s:echomsg('Successfully deleted: ' .target)
    else
      call s:echomsg('Failed to delete: ' .target)
    endif
  endfor
endfunction
function! s:notes.get_save_dir() abort
  return self.save_dir_
endfunction
function! s:notes.get_completion(arg_lead) abort
  return map(filter(self.list_files(), 'v:val =~? a:arg_lead'),
        \ 'fnameescape(v:val)')
endfunction
" Define :Memo* :Otameshi*
for s:type_ in ['memo', 'otameshi']
  let s:{s:type_} = s:notes.instance(s:JoinPath(
      \ s:cache_dir, s:type_))
  if !isdirectory(s:{s:type_}.get_save_dir())
    call mkdir(s:{s:type_}.get_save_dir(), 'p')
  endif
  if isdirectory(s:{s:type_}.get_save_dir())
    let s:com_prefix_ = toupper(s:type_[0]) .. s:type_[1:]
    execute printf('command! -bar -nargs=* %sNew call s:%s.new(<q-args>)',
          \ s:com_prefix_, s:type_)
    execute printf('command! -bar -nargs=+ -complete=customlist,Vimrc%sComplete %sDelete call s:%s.delete(<f-args>)',
          \ s:com_prefix_, s:com_prefix_, s:type_)
    execute printf('command! -bar %sList call s:%s.list()',
          \ s:com_prefix_, s:type_)
    unlet s:com_prefix_
  endif
endfor | unlet s:type_
"
function! s:memo.expand_filename(name) abort
  let name = a:name
  if !s:has(name, '.')
    " Add .md extension only when use didn't specificate extension.
    let name ..= '.md'
  endif
  let name = strftime('%Y-%m-%d %H:%M ') .. name
  return name
endfunction
function! s:otameshi.expand_filename(name) abort
  if s:has(a:name, '.') " Filename already has an extension.
    return a:name
  endif
  let extension = s:input('Extension? (Empty will be non-extension file):')
  if extension ==# ''
    return a:name
  else
    return a:name .. '.' .. extension
  endif
endfunction
function! VimrcMemoComplete(arg_lead, cmd_line, cur_pos) abort
  return s:memo.get_completion(a:arg_lead)
endfunction
function! VimrcOtameshiComplete(arg_lead, cmd_line, cur_pos) abort
  return s:otameshi.get_completion(a:arg_lead)
endfunction
"
" working-plugin
command! -bar -nargs=+ -complete=customlist,vimrc#workingplugin#complete
      \ WorkingPluginLoad call vimrc#workingplugin#load(<f-args>)
command! -bar -bang -nargs=1 -complete=customlist,vimrc#workingplugin#complete
      \ WorkingPluginCd call vimrc#workingplugin#cd(<bang>0, <q-args>)
command! -bar -nargs=+ WorkingPluginClone call vimrc#workingplugin#clone(<f-args>)
command! -bar -nargs=+ WorkingPluginNew call vimrc#workingplugin#new(<f-args>)
command! -bar -nargs=+ -complete=customlist,vimrc#workingplugin#complete
      \ WorkingPluginRm call vimrc#workingplugin#rm(<f-args>)
" Sessions
let s:session_dir = s:JoinPath(s:cache_dir, 'sessions')
call s:Mkdir(s:session_dir)
command! MkSession call vimrc#session#make()
command! -nargs=+ -complete=custom,vimrc#session#complete DelSession
      \ call vimrc#session#delete(1, <f-args>)
command! -nargs=1 -complete=custom,vimrc#session#complete RestoreSession
      \ call vimrc#session#restore(<q-args>)

" Showmode
def! s:ShowmodeInit()
  var colors = {
    normal: [['22', '148'], ['#005f00', '#afdf00']],
    insert: [['23', '117'], ['#005f5f', '#87dfff']],
    visual: [['88', '208'], ['#870000', '#ff8700']],
    replace: [['231', '160'], ['#ffffff', '#df0000']],
  }
  for [mode, color] in items(colors)
    execute printf(
      'highlight VimrcShowMode%s ctermfg=%s ctermbg=%s guifg=%s guibg=%s',
      mode, color[0][0], color[0][1], color[1][0], color[1][1])
  endfor
enddef
def! s:ShowmodeMode(): string
  s:ShowmodeHighlight()
  var map = {
    n: 'NORMAL',
    i: 'INSERT',
    R: 'REPLACE',
    v: 'VISUAL',
    V: 'V-LINE',
    ["\<C-v>"]: 'V-BLOCK',
    c: 'COMMAND',
    ce: 'EX-COM',
    s: 'SELECT',
    S: 'S-LINE',
    ["\<C-s>"]: 'S-BLOCK',
    t: 'T-INSERT',
    no: 'OPERATOR',
    niI: 'N-INSERT',
    niR: 'N-REPLACE',
    niV: 'N-V-REPLACE',
  }
  return get(map, mode(), 'UNKNOWN')
enddef
def! s:ShowmodeHighlight()
  var type = get({
     i: 'insert',
     t: 'insert',
     R: 'replace',
     v: 'visual',
     V: 'visual',
     ["\<C-v>"]: 'visual',
   }, mode(), 'normal')
  execute 'highlight link VimrcShowMode VimrcShowMode' .. type
enddef
def! s:ShowmodeLabel(): string
  if win_getid() == g:statusline_winid &&
        getwinvar(g:statusline_winid, '&modifiable') == 1
    return '%#VimrcShowMode# %{<SID>ShowmodeMode()} %#Statusline#'
  endif
  return ''
enddef
augroup vimrc_showmode
  autocmd ColorScheme,Syntax * call s:ShowmodeInit()
  autocmd User vimrc_initialize call s:ShowmodeInit()
augroup END

" statusline
def! s:StatuslineGenerator(): string
  var gina = s:PluginExists('gina.vim') ?
      '[%{gina#component#repo#branch() ==# "" ? "no-git" : gina#component#repo#branch()}]' :
      ''
  var statusline =
    '%m' ..
    s:ShowmodeLabel() ..
    '[%{&ft ==# "" ? "No ft" : &ft}]' ..
    '[#%{bufnr("%")}]' ..
    gina ..
    '%{<SID>FilenameLabel(bufnr("%"))}' ..
    '%<%=' ..
    '[%{pathshorten(getcwd(winnr()))}]'
  return substitute(statusline, '\c<SID>', s:SIDPrefix(), 'g')
enddef
def! s:FilenameLabel(bufnr: number): string
  var buftype = getbufvar(bufnr, '&buftype')
  var bufname = bufname(bufnr)
  if buftype ==# 'help'
    return fnamemodify(bufname, ':t')
  elseif buftype ==# 'quickfix'
    return '[quickfix]'
  elseif getbufvar(bufnr, '&previewwindow')
    return '[preview]'
  elseif buftype ==# 'terminal'
    return 'terminal:' .. bufname
  elseif buftype ==# 'prompt'
    return '[prompt]'
  else
    return (buftype ==# 'nofile' ? ' *NoFile* ' : '') ..
      (bufname ==# '' ? '[NoName]' : pathshorten(fnamemodify(bufname, ':.')))
  endif
enddef
let &statusline = printf('%%!%sStatuslineGenerator()', s:SIDPrefix())

" tabline
let &tabline = printf('%%!%sTabline()', s:SIDPrefix())
def! s:GenerateTabinfo(tabnr: number): string
  var tablist = tabpagebuflist(tabnr)
  var info = ''
  info ..= len(filter(copy(tablist), 'getbufvar(v:val, "&mod")')) > 0 ? '[+]' : ''
  info ..= '[' .. tabpagewinnr(tabnr, '$') .. ']'
  return info
enddef
def! s:Tabline(): string
  var tabline = '%#TabLine#|'
  var t = tabpagenr()

  for n in range(1, tabpagenr('$'))
    tabline ..= '%' .. n .. 'T'
    var info = ' ' .. s:GenerateTabinfo(n) .. ' '
    if t == n
      tabline ..= '%#TabLineSel# %999Xx%X' .. info .. '%#TabLine#'
    else
      tabline ..= info
    endif
    tabline ..= '%T|'
  endfor
  tabline ..= '%>%=[%{pathshorten(getcwd())}]'

  return substitute(tabline, '\c<SID>', s:SIDPrefix(), 'g')
enddef

" :terminal
augroup vimrc_terminal
  autocmd TerminalWinOpen * call s:TerminalWinOpen()
augroup END
def! s:TerminalWinOpen()
  setlocal nonumber norelativenumber
enddef

" EmphasisIndent
highlight link VimrcEmphasisIndent CursorLine
augroup vimrc_emphasize_indent
  autocmd WinEnter * call s:EmphasizeIndent()
  autocmd OptionSet expandtab,smarttab,tabstop,shiftwidth call s:EmphasizeIndent()
  autocmd User vimrc_initialize call s:EmphasizeIndent()
  autocmd Syntax * highlight link VimrcEmphasisIndent CursorLine
augroup END
def! s:EmphasizeIndent()
  if exists('w:disable_emphasis_indent') && <bool>w:disable_emphasis_indent
    return
  endif
  if exists('w:emphasis_indent_id')
    matchdelete(w:emphasis_indent_id)
  endif

  var pat = '\v%%(^%%(%s)*)@<=%s'
  if &l:expandtab || &l:smarttab
    pat = printf(pat, repeat('\s', shiftwidth()), '\s')
  else
    pat = printf(pat, '\t\t', '\t')
  endif
  w:emphasis_indent_id = matchadd('VimrcEmphasisIndent', pat)
enddef
def! s:EmphasisIndentEnable()
  w:disable_emphasis_indent = 0
  s:EmphasizeIndent()
enddef
def! s:EmphasisIndentDisable()
  w:disable_emphasis_indent = 0
  if exists('w:emphasis_indent_id')
    matchdelete(w:emphasis_indent_id)
    unlet w:emphasis_indent_id
  endif
enddef
command! EmphasisIndentDisable call s:EmphasisIndentDisable()
command! EmphasisIndentEnable call s:EmphasisIndentEnable()

" WarningSpace
highlight link WarningSpace Error
augroup vimrc_warningspace
  autocmd WinEnter * call s:WarningSpace()
  autocmd OptionSet * call s:WarningSpace()
  autocmd User vimrc_initialize call s:WarningSpace()
  autocmd Syntax * highlight link WarningSpace Error
augroup END
def! s:WarningSpace()
  # Clean up.
  if exists('w:twobyte_space_id')
    matchdelete(w:twobyte_space_id)
    unlet w:twobyte_space_id
  endif
  if exists('w:end_of_line_space_id')
    matchdelete(w:end_of_line_space_id)
    unlet w:end_of_line_space_id
  endif

  if &buftype !=# '' || !&modifiable
    return
  endif

  # Zenkaku space
  # NOTE: '\%d12288' means one zenkaku space. HINT: nr2char(12288)
  w:twobyte_space_id = matchadd('WarningSpace', '\%d12288')

  # White spaces in the end of line
  w:end_of_line_space_id = matchadd('WarningSpace', '\s\+$')
enddef
command! ReplaceTwobyteSpace keeppatterns %s/\%d12288/ /g
command! DeleteLineEndSpace keeppatterns %s/\s\+$//g

" mru
let g:mru_history_file = s:JoinPath(s:cache_dir, 'mru', 'history')
let g:mru_ignore_pattern = [
      \ '\.git\>',
      \ '^\V\%(' .. escape(expand('~'), '\') .. '\)\@!'
      \ ]

" filore
def! s:FiloreMapping()
  var mapping = [
         ['q', 'exit'],
         ['o', 'toggle-directory-folding'],
         ['l', 'enter-directory'],
         ['h', 'leave-directory'],
         ['.', 'toggle-show-hidden-files'],
         ['k', 'loop-cursor-up'],
         ['j', 'loop-cursor-down'],
         ['<CR>', 'open-file'],
         ['<C-h>', 'start-history'],
        ]
  map(mapping, {key, val ->
         'nmap <buffer> ' .. val[0] .. ' <Plug>(filore-' .. val[1] .. ')'})
  execute join(mapping, "\n")
enddef
augroup vimrc_additional_plugins
  autocmd FileType filore call s:FiloreMapping()
augroup END

" git
def! s:GitDiffGetcmd(arg_target: string): string
  var target: string = resolve(arg_target)
  var gitroot: string = s:FindGitroot(target)
  if gitroot ==# ''
    return ''
  endif
  return printf('git -C %s --no-pager diff --no-color %s',
          gitroot, shellescape(target))
enddef
def! s:GitDiff(arg_target: string = bufname('%')): void
  var target: string = resolve(arg_target)
  if getftype(target) ==# ''
    s:EchomsgError('File or directory does not exists: ' .. target)
    return
  endif
  var cmd: string = s:GitDiffGetcmd(target)
  if cmd ==# ''
    return
  endif
  var bufnr = term_start(cmd, {
          term_name: '[git diff] ' .. fnamemodify(target, ':~:.'),
          norestore: 1,
        })
  if bufnr
    setlocal nocursorline nocursorcolumn filetype=diff
    nnoremap <buffer> <nowait> q <Cmd>quit<CR>
    cursor(1, 0)
  endif
  return
enddef
command! -nargs=? -complete=file GitDiff call s:GitDiff(<q-args>)

" gyoza
augroup vimrc_gyoza
  autocmd User vimrc_initialize call vimrc#gyoza#enable()
augroup END

" zsh
" function! Tapi_edit_line(bufnr, args) abort
"   let buffer = a:args[0]
"   let curpos = a:args[1]
"   echom $KEYMAP
" endfunction

" lvimrc
let s:_lvimrc = s:Rc('lvimrc')
if filereadable(s:JoinPath(expand('~'), s:_lvimrc))
  let s:_lvimrc = s:JoinPath('~', s:_lvimrc)
  execute 'command! -bar -nargs=* LVimrc ' ..
        \ 'execute ((<q-args> ==# "") ? "edit" : <q-args>)' string(s:_lvimrc)
  execute 'source' s:_lvimrc
endif | unlet s:_lvimrc

" gvimrc
if has('gui_running')
  if has('vim_starting')
    set lines=999
    set columns=9999
  endif
  set guioptions& guioptions-=e guioptions-=T
  set guioptions-=R guioptions-=r guioptions-=L guioptions-=l
  set mouse=a
  set nomousefocus
  set mousehide

  if has('win32')
    set guifont=MS_Gothic:h10:cSHIFTJIS
    set linespace=1

    set columns=120
  elseif has('mac')
    set guifont=Osaka-Mono:h14
    "set columns=120
  elseif has('xfontset')
    "for unix (use xfontset)
    set guifont=a14,r14,k14
  endif

  if has('multi_byte_ime') || has('xim')
    set iminsert=0 imsearch=0
    augroup vimrc_iminsert
      autocmd InsertLeave * set iminsert=0
    augroup END
  endif
endif
" Initialize when loading this file.
augroup vimrc_initialize_dummy
  " Do not provide an error. For more information, see `:h E217`
  autocmd User vimrc_initialize " Do nothing.
augroup END

if has('vim_starting')
  augroup vimrc_initialize
    autocmd VimEnter * doautocmd User vimrc_initialize
  augroup END
else
  doautocmd User vimrc_initialize
endif
