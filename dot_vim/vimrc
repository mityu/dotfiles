" Author: mityu
" Last Change: 06-Jun-2020.
" vim: shiftwidth=2
" vim9script
" Encoding
if has('vim_starting')
  set encoding=utf-8
  scriptencoding utf-8
  let $MYVIMRC = resolve(expand('<sfile>'))
endif
def! s:fold_is_blockopen(line: string): bool
  return line =~# '\v^%(fu%[nction]|%(export\s+)?def|if|for|while|try)'
enddef
def! s:fold_is_blockclose(line: string): bool
  return line =~# '\v^end%(func%[tion]|def|if|for|while|try)'
enddef
function! FoldExprForVimrc() abort
  " TODO: Fold with marker
  let line = getline(v:lnum)
  if line =~# '^\s'
    return '='
  elseif s:fold_is_blockopen(line)
    return '>1'
  elseif v:lnum == 1 || s:fold_is_blockclose(getline(v:lnum - 1))
    return 0
  endif
  return '='
endfunction

" Local utility functions
function! s:vars() abort
  return s:
endfunction
function! s:SIDPrefix() abort
  " Returns "<SNR>{script-ID}_"
  return matchstr(expand('<sfile>'), '\zs<SNR>\d\+_\zeSIDPrefix$')
endfunction
function! s:SNR() abort
  return matchstr(s:SIDPrefix(), '<SNR>\zs\d\+\ze_$')
endfunction
function! s:rc(fname) abort
  return s:filesystem.rcfile_prefix .. a:fname
endfunction
function! s:join_path(...) abort
  return join(a:000, s:filesystem.slash)
endfunction
function! s:has(object, to_search) abort
  let object_type = type(a:object)
  if object_type == v:t_string
    let func = 'stridx'
    let not_found = -1
  elseif object_type == v:t_list
    let func = 'index'
    let not_found = -1
  elseif object_type == v:t_dict
    let func = 'has_key'
    let not_found = 0
  else
    return 0
  endif
  return (call(func, [a:object, a:to_search]) != not_found)
endfunction
def! s:get_msg_string(msg: string): string
  return '[vimrc] ' .. msg
enddef
function! s:echomsg_with_color(msg, hl_group) abort
  execute 'echohl' a:hl_group
  echomsg s:get_msg_string(a:msg)
  echohl NONE
endfunction
def! s:echomsg(msg: string): void
  call s:echomsg_with_color(msg, 'NONE')
enddef
def! s:echomsg_error(msg: string): void
  call s:echomsg_with_color(msg, 'Error')
enddef
def! s:echomsg_warning(msg: string): void
  call s:echomsg_with_color(msg, 'WarningMsg')
enddef
def! s:echo(msg: string): void
  echo s:get_msg_string(msg)
enddef
def! s:echo_question(question: string): void
  echon s:get_msg_string(question) .. ' '
  echohl Question
  echon '[Y/N]'
  echohl NONE
  echon "\n"
enddef
def! s:is_visualmode(): bool
  return s:has(['v', 'V', "\<C-v>"], mode())
enddef
def! s:is_cmdwin(): bool
  return getcmdwintype() !=# ''
enddef
def! s:glob(expr: string): list<string>
  return split(glob(expr), "\n")
enddef
function! s:getchar_string(...) abort
  return nr2char(call('getchar', a:000))
endfunction
def! s:ask(question: string): bool
  call s:echo_question(question)
  return s:has(['y', 'Y'], s:getchar_string())
enddef
function! s:mkdir(dir, ...) abort
  " Return 1 when process finished without errors; otherwise, return 0.
  if isdirectory(a:dir)
    return 1
  endif
  if !exists('*mkdir')
    call s:echomsg_error('built-in mkdir() not found.')
    return 0
  endif
  return call('mkdir', [a:dir] + a:000)
endfunction
def! s:strdivpos(str: string, pos: number): list<string>
  return [strpart(str, 0, pos),
        \ strpart(str, pos, strlen(str) - pos)]
enddef
function! s:input(prompt, ...) abort
  try
    return call('input', [a:prompt] + a:000)
  catch /\C^Vim:Interrupt$/
    return ''
  endtry
endfunction
function! s:win_execute(id, command, ...) abort
  let eventignore_save = &eventignore
  set eventignore=all
  try
    return call('win_execute', [a:id, a:command] + a:000)
  finally
    let &eventignore = eventignore_save
  endtry
endfunction

" Global utility functions
function! VimrcSIDPrefix() abort
  return s:SIDPrefix()
endfunction
function! VimrcFunc(func) abort
  return function(s:SIDPrefix() .. a:func)
endfunction
function! SetUndoFtplugin(config) abort
  let restorer = 'execute ' .. string(a:config)
  if exists('b:undo_ftplugin')
    let b:undo_ftplugin = restorer .. '|' .. b:undo_ftplugin
  else
    let b:undo_ftplugin = restorer
  endif
endfunction
command! -nargs=1 -complete=command SetUndoFtplugin
      \ call SetUndoFtplugin(<q-args>)

" Startup config
" FIXME: Error occurs without executing inner this if statement.
if has('vim_starting') || 1
  if has('multi_lang')
    if has('menu')
      set langmenu=ja.utf-8
    endif
  endif

  if &term =~# '\<256color\>' && expand('$TERM_PROGRAM') !=# 'Apple_Terminal'
    set termguicolors  " Use true color if possible.
  endif
  if expand('$TERM_PROGRAM') ==# 'alacritty'
    let &t_EI = "\<ESC>[2 q"  " Use Block style cursor in Normal-mode.
    let &t_SI = "\<ESC>[6 q"  " Use Bar style cursor in Insert-mode.
    let &t_SR = "\<ESC>[4 q"  " Use underline style cursor in Replace-mode.
  endif
  if &term =~# '\<xterm\>'
    set mouse=a
  endif

  let s:Windows = has('win32')
  let s:Unix = !s:Windows
  lockvar s:Windows
  lockvar s:Unix


  let s:filesystem = {}
  if s:Windows
    let $DOT_VIM = expand('~\vimfiles')
    let s:filesystem.slash = '\'
    let s:filesystem.path_separator = ';'
    let s:filesystem.rcfile_prefix = '_'
  else
    let $DOT_VIM = expand('~/.vim')
    let s:filesystem.slash = '/'
    let s:filesystem.path_separator = ':'
    let s:filesystem.rcfile_prefix = '.'
  endif

  let s:cache_dir = s:join_path(expand('~'), '.cache', 'vimrc')
  call s:mkdir(s:cache_dir, 'p')

  " disable default plugins
  let g:loaded_2html_plugin = 1
  let g:loaded_getscriptPlugin = 1
  let g:loaded_gzip = 1
  let g:loaded_zipPlugin = 1
  let g:loaded_tarPlugin = 1
  let g:loaded_vimballPlugin = 1
  let g:loaded_netrwPlugin = 1

  let &runtimepath .= ',' .. escape(s:join_path($DOT_VIM, 'runtime'), ' \')

  " Set environmental variables on gVim.
  let s:_envrc = s:join_path(expand('~'), s:rc('envrc'))
  if has('gui_running') && filereadable(s:_envrc)
    let s:contents = readfile(s:_envrc)
    call map(s:contents, "substitute(v:val, '\\(\\_^\\|\\s\\)#.*$', '', 'g')")
    call filter(s:contents, '!empty(v:val)')
    call map(s:contents, "split(v:val, '=')")
    call map(s:contents,
        \ "execute(printf('let $%s=%s', v:val[0], string(expand(v:val[1]))))")
    unlet s:contents
  endif | unlet s:_envrc
endif
" Initialize autocmd
let s:_augroups = readfile(expand('<sfile>'))
let s:_pattern = '^\s*aug\%[roup]\s\+\zs\S\+\ze\s*'
call filter(s:_augroups, 'stridx(v:val, "aug") != -1')
call filter(s:_augroups, 'v:val =~# s:_pattern')
call map(s:_augroups, 'matchstr(v:val, s:_pattern)')
call uniq(sort(filter(s:_augroups, 'v:val !=? "END"')))
for s:_augroup in s:_augroups
  execute 'augroup' s:_augroup
    autocmd!
  execute 'augroup END'
endfor | unlet s:_augroup s:_augroups s:_pattern

" minpac
let s:plugin = {}
if &loadplugins
  let s:plugin.plugins_ = map(filter(s:glob(
        \ s:join_path($DOT_VIM, 'pack', 'minpac', 'start', '*')
        \), 'isdirectory(v:val)'), 'fnamemodify(v:val, ":p:h:t")')
  function! s:plugin.exists(plugin) abort
    return s:has(self.plugins_, a:plugin)
  endfunction
else
  function! s:plugin.exists(plugin) abort
    return 0
  endfunction
endif
function! s:pack_register() abort
  call minpac#add('k-takata/minpac', {'type': 'opt'})

  call minpac#add('itchyny/vim-cursorword')
  call minpac#add('kana/vim-altr')
  call minpac#add('kana/vim-gf-user')
  call minpac#add('kana/vim-operator-replace')
  call minpac#add('kana/vim-operator-user')
  call minpac#add('kana/vim-textobj-entire')
  call minpac#add('kana/vim-textobj-function')
  call minpac#add('kana/vim-textobj-indent')
  call minpac#add('kana/vim-textobj-line')
  call minpac#add('kana/vim-textobj-user')
  " call minpac#add('lambdalisue/fila.vim')
  call minpac#add('lambdalisue/gina.vim')
  call minpac#add('lambdalisue/vim-findent')
  call minpac#add('lambdalisue/vim-gista')
  call minpac#add('mattn/vim-lsp-settings')
  call minpac#add('mityu/vim-brownie')
  call minpac#add('mityu/vim-gram')
  call minpac#add('mityu/vim-gram-sources')
  call minpac#add('mityu/vim-textobj-commentblock')
  call minpac#add('osyo-manga/vim-jplus')
  call minpac#add('osyo-manga/vim-operator-swap')
  call minpac#add('prabirshrestha/async.vim')
  call minpac#add('prabirshrestha/asyncomplete-buffer.vim')
  call minpac#add('prabirshrestha/asyncomplete-lsp.vim')
  call minpac#add('prabirshrestha/asyncomplete.vim')
  call minpac#add('prabirshrestha/vim-lsp')
  call minpac#add('previm/previm')
  call minpac#add('rhysd/vim-operator-surround')
  call minpac#add('sgur/vim-gf-autoload')
  call minpac#add('sgur/vim-operator-openbrowser')
  call minpac#add('thinca/vim-ambicmd')
  call minpac#add('thinca/vim-ft-help_fold')
  " call minpac#add('thinca/vim-operator-sequence')
  call minpac#add('thinca/vim-partedit')
  call minpac#add('thinca/vim-prettyprint')
  call minpac#add('thinca/vim-quickrun')
  call minpac#add('thinca/vim-textobj-between')
  call minpac#add('thinca/vim-themis')
  call minpac#add('tyru/capture.vim')
  call minpac#add('tyru/caw.vim')
  call minpac#add('tyru/open-browser.vim')
  call minpac#add('vim-jp/autofmt')
  call minpac#add('vim-jp/syntax-vim-ex')
  call minpac#add('vim-jp/vimdoc-ja')
  call minpac#add('vim-jp/vital.vim')
  call minpac#add('vim-scripts/autodate.vim')

  call minpac#add('gyim/vim-boxdraw', {'type': 'opt'})
  " call minpac#add('mityu/vim-readingvimrc-files', {'type': 'opt'})
  call minpac#add('tweekmonster/helpful.vim', {'type': 'opt'})
  call minpac#add('y0za/vim-reading-vimrc', {'type': 'opt'})
  call minpac#add('rbtnn/vim-coloredit', {'type': 'opt'})
endfunction
function! s:pack_init() abort
  try
    packadd minpac
  catch /^Vim\%((\a\+)\)\=:E919/
    "Download minpac...
    let minpac_path = s:join_path($DOT_VIM, 'pack', 'minpac', 'opt', 'minpac')
    call s:echomsg('Downloading minpac...')
    call system('git clone https://github.com/k-takata/minpac.git ' ..
          \ minpac_path)
    try
      packadd minpac
    catch
      echoerr v:exception
      return 0
    endtry
  endtry

  call minpac#init()
  call s:pack_register()

  return 1
endfunction
function! s:pack_update() abort
  if s:pack_init()
    call minpac#update()
  endif
endfunction
function! s:pack_clean() abort
  if s:pack_init()
    call minpac#clean()
  endif
endfunction
function! s:pack_status() abort
  if exists('*minpac#status')
    call minpac#status()
  else
    call s:echomsg_error('minpac isn''t loaded yet.')
  endif
endfunction
command! -bar PackInit   call s:pack_init()
command! -bar PackUpdate call s:pack_update()
command! -bar PackClean  call s:pack_clean()
command! -bar PackStatus call s:pack_status()

" Options
syntax on
filetype plugin indent on
colorscheme domusaurea
set relativenumber number
set wrap
set smartindent autoindent
set cinoptions=:0,g0,N-s,E-s
set backspace=eol,start,indent
set pumheight=10
set completefunc=vimrc#path_complete
set noequalalways
set scrolloff=1
set colorcolumn=78
set tabstop=4
set shiftwidth=4
set expandtab
set smarttab
set softtabstop=4
set hlsearch
set display=lastline
set listchars=tab:\|-
set autoread
set incsearch ignorecase
set showmatch matchtime=1
set cursorline cursorlineopt=number
set laststatus=2
set showtabline=2
set cmdheight=2 cmdwinheight=10
set wildmenu
set wildignore& wildignore+=*.DS_STORE,*.jpg,*.png,*.gif
set history=500
set keywordprg=:help
set shortmess& shortmess+=Ic
set helplang=ja
set foldmethod=marker
set hidden
set diffopt=internal,algorithm:histogram
"set breakindent
"set virtualedit& virtualedit+=block
set virtualedit=block
set complete=.,i,d,w,b,u
set noimdisable
set lazyredraw
set previewpopup=highlight:Normal
set termwinkey=<C-w>
set noesckeys
set nowrapscan

let s:_undodir = s:join_path(s:cache_dir, 'undodir')
if s:mkdir(s:_undodir, 'p')
  set undofile
  let &undodir = s:_undodir
else
  set noundofile
endif
unlet s:_undodir

let s:_directory = s:join_path(s:cache_dir, 'swapfile')
if s:mkdir(s:_directory, 'p')
  set swapfile
  let &directory = s:join_path(fnamemodify(s:_directory, ':p'), '')
else
  set noswapfile
endif
unlet s:_directory
set nobackup nowritebackup

if has('kaoriya')
  set fileencodings=guess,utf-8
  set ambiwidth=auto
else
  set fileencodings=utf-8
  set ambiwidth=double
endif
if s:Unix
  set path& path+=/usr/local/include
endif
if executable('ag')
  let &grepprg = 'ag --vimgrep'
  let &grepformat = '%f:%l:%c:%m'
endif
augroup vimrc_syntax
  autocmd User vimrc_initialize syntax enable
augroup END
augroup vimrc_filetype
  autocmd FileType c,cpp setlocal foldmethod=indent
  autocmd BufRead .envrc set filetype=sh
  autocmd FileType makefile setlocal noexpandtab nosmarttab

  " Cannot set foldexpr in modeline without modelineexpr, so use autocmd.
  execute 'autocmd BufRead ' .. $MYVIMRC .. ' setlocal foldmethod=expr ' ..
        \ 'foldexpr=FoldExprForVimrc()'
augroup END
augroup vimrc_mru
  autocmd BufWritePost * call vimrc#mru#onReadFile()  " TODO: Change func name
augroup END
augroup vimrc_checktime
  autocmd CursorHold * if getcmdwintype() ==# '' | checktime | endif
augroup END
"
" Mapping
nnoremap ; q:A
vnoremap ; q:A
nnoremap <Space>; q:
vnoremap <Space>; q:
nnoremap / q/A
vnoremap / q/A
nnoremap <Space>/ q/
vnoremap <Space>/ q/
nnoremap ? q?A
vnoremap ? q?A
nnoremap <Space>? q?
vnoremap <Space>? q?
nnoremap : ;
vnoremap : ;
nnoremap <Space>: :
vnoremap <Space>: :

noremap - <C-x>
noremap + <C-a>

nnoremap j gj
nnoremap k gk
nnoremap <CR> o<ESC>
nnoremap <S-CR> O<ESC>
nnoremap Y y$
nnoremap <C-h> :<C-u>nohlsearch<CR>
nnoremap <silent> <C-w>s :<C-u>belowright wincmd s<CR>
nnoremap <silent> <C-w><C-s> :<C-u>belowright wincmd s<CR>
nnoremap <silent> <C-w>v :<C-u>belowright wincmd v<CR>
nnoremap <silent> <C-w><C-v> :<C-u>belowright wincmd v<CR>
nnoremap <silent> <C-w>c :<C-u>belowright copen<CR>
nnoremap <silent> <C-w>t :<C-u>tabnew<CR>
nnoremap <silent> <C-w><C-t> :<C-u>tabnew<CR>
nnoremap <silent> <Space>th :<C-u>vertical terminal ++close<CR>
nnoremap <silent> <Space>tj :<C-u>belowright terminal ++close<CR>
nnoremap <silent> <Space>tk :<C-u>terminal ++close<CR>
nnoremap <silent> <Space>tl :<C-u>belowright vertical terminal ++close<CR>
nnoremap <silent> <Space>tt :<C-u>tab terminal ++close<CR>
nnoremap <Space>w :<C-u>update<CR>
nnoremap <Space>q :<C-u>quit<CR>
nnoremap ZZ <Nop>
nnoremap ZQ <Nop>
nnoremap <silent> <nowait> Z :<C-u>call <SID>toggle_zooming_window()<CR>
nnoremap <silent> <C-w>z :<C-u>call <SID>toggle_zooming_window()<CR>
nnoremap <expr> n 'Nn'[v:searchforward] .. 'zzzv'
nnoremap <expr> N 'nN'[v:searchforward] .. 'zzzv'
nnoremap <C-k> 7gk
nnoremap <C-j> 7gj
" Avoid to regester calling textobj function commands to the command-history
" when use textobj via dot.
nnoremap <silent> . .

inoremap <C-m> <C-g>u<C-m>
inoremap <C-u> <C-g>u<C-u>
inoremap <C-j> <C-g>u<C-j>
inoremap <C-l> <C-x>

vnoremap g+ g<C-a>
vnoremap g- g<C-x>
vnoremap <C-k> 7gk
vnoremap <C-j> 7gj

cnoremap <C-l> <C-f>
cnoremap <C-f> <Right>
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>
cnoremap <C-b> <Left>
cnoremap <C-a> <C-b>
cnoremap <C-[> <C-c>

let s:Omap = {range, lhs, rhs ->
      \[execute(printf('onoremap %s%s %s%s', range, lhs, range, rhs)),
      \execute(printf('vnoremap %s%s %s%s', range, lhs, range, rhs))]}
let s:EnhancedOmap = {lhs, rhs ->
      \ [s:Omap('a', lhs, rhs), s:Omap('i', lhs, rhs)]
      \}
call s:EnhancedOmap('2', '"')
call s:EnhancedOmap('7', "'")
call s:EnhancedOmap('8', '(')
call s:EnhancedOmap(', ', '<')
unlet s:Omap s:EnhancedOmap

def! s:terminal_map(mapcmd: string, lhs: string, rhs: string, mods: string = ''): void
  execute printf('%s %s %s%s %s%s',
       \ mapcmd, mods, &termwinkey, lhs, &termwinkey, rhs)
enddef
call s:terminal_map('tnoremap', ';', ':<C-f>A')
call s:terminal_map('tnoremap', ':', ';')
call s:terminal_map('tnoremap', '<ESC>', 'N')
call s:terminal_map('tnoremap', 'p', '""')
call s:terminal_map('tnoremap', '<C-r>', '"')
" call s:terminal_map('tmap', '<C-j>', '<ESC>')
tnoremap <C-j> <ESC>

" Loop
function! s:_loop_define(config) abort
  let prefix = printf('<Plug>(<SID>-loop-%s)', a:config.id)
  let enter_with = a:config.enter_with
  let mode = get(a:config, 'mode', 'n')
  let plug_map = {}
  for key in ['prefix', 'main', 'do']
    let plug_map[key] = printf("%s(%s)", prefix, key)
  endfor

  execute printf('%snoremap %s <Nop>', mode, plug_map.prefix)
  for [lhs, rhs] in a:config.map
    let [lhs, rhs] =
          \ map([lhs, rhs], {_, val -> substitute(val, '|', '<bar>', 'g')})
    let com = []
    call add(com, [mode .. 'noremap <silent>',
          \ plug_map.do .. lhs,
          \ rhs])
    call add(com, [mode .. 'map',
          \ enter_with .. lhs,
          \ plug_map.main .. lhs])
    call add(com, [mode .. 'map',
          \ plug_map.main .. lhs,
          \ plug_map.do .. lhs .. plug_map.prefix
          \])
    call add(com, [mode .. 'map',
          \ plug_map.prefix .. lhs,
          \ plug_map.main .. lhs])
    execute join(map(com, 'join(v:val, " ")'), "\n")
  endfor

  if mode ==# 'n'
    let config = deepcopy(a:config)
    let config.mode = 't'
    call map(config.map, 's:_loop_define_generate_tmap(v:val)')
    if config.enter_with !~?
          \ printf("\\v^%%(%s|\\%s)", &termwinkey, &termwinkey)
      let config.enter_with = &termwinkey .. config.enter_with
    endif
    call s:_loop_define(config)
  endif
endfunction
function! s:_loop_define_generate_tmap(value) abort
  let rhs = a:value[1]
  let rhs = substitute(rhs, '\c<SID>', s:SIDPrefix(), 'g')
  let rhs = substitute(rhs, '\zs<\ze.\{-}>', '\\<lt>', 'g')
  let rhs = &termwinkey .. ':<C-u>execute "normal! ' .. rhs .. '"<CR>'
  return [a:value[0], rhs]
endfunction
function! s:_simple_loop_define(config) abort
  let config = deepcopy(a:config)
  let config.map = map(split(config.follow_key, '\zs'),
        \ '[v:val, config.enter_with .. v:val]')
  call s:_loop_define(config)
endfunction
"Window management
call s:_simple_loop_define({
      \ 'id': 'Window',
      \ 'enter_with': '<C-w>',
      \ 'follow_key': 'hjklHJKLq<>-+_|='
      \ })
call s:_loop_define({
      \ 'id': 'Tab',
      \ 'enter_with': 'g',
      \ 'map': [
      \   ['h', 'gT'],
      \   ['l', 'gt'],
      \   ['T', ':<C-u>call <SID>map_tabmove(-1)<CR>'],
      \   ['t', ':<C-u>call <SID>map_tabmove(1)<CR>']
      \ ]
      \ })
function! s:map_tabmove(delta) abort
  let tab_count = tabpagenr('$')
  if tab_count == 1
    return
  endif
  let current = tabpagenr() - 1
  let move_to = current + a:delta
  if move_to < 0
    while move_to < 0
      let move_to += tab_count
    endwhile
  endif
  if move_to >= tab_count
    let move_to = move_to % tab_count
  endif
  let movement = move_to - current
  let command = 'tabmove '
  if movement < 0
    let command .= string(movement)
  else
    let command .= '+' .. movement
  endif
  execute command
endfunction
delfunc s:_loop_define
delfunc s:_simple_loop_define
"
" Shift-ten-key
let s:ten_key_pair = [
      \['1', '!'],
      \['2', '"'],
      \['3', '#'],
      \['4', '$'],
      \['5', '%'],
      \['6', '&'],
      \['7', "'"],
      \['8', '('],
      \['9', ')'],
      \]
let s:ten_key_mapbase = '<Plug>(vimrc-tenkey-%s)'
for s:pair in s:ten_key_pair
  for s:key in s:pair
    execute 'inoremap' printf(s:ten_key_mapbase, s:key) s:key
  endfor
  unlet s:key
endfor|unlet s:pair
function! s:shift_ten_key(enablize) abort
  if a:enablize
    for [key1, key2] in s:ten_key_pair
      execute 'imap' key1 printf(s:ten_key_mapbase, key2)
      execute 'imap' key2 printf(s:ten_key_mapbase, key1)
    endfor
  else
    for [key1, key2] in s:ten_key_pair
      execute 'imap' key1 printf(s:ten_key_mapbase, key1)
      execute 'imap' key2 printf(s:ten_key_mapbase, key2)
    endfor
  endif
endfunction
command! -bar EnableShiftTenKey call s:shift_ten_key(1)
command! -bar DisableShiftTenKey call s:shift_ten_key(0)
if has('vim_starting')
  EnableShiftTenKey
endif

function! s:cmdwin_enter() abort
  call s:cmdwin_save_options.clear()

  " Type <CR> to execute current line in command-line window.
  nnoremap <buffer> <CR> <CR>

  " Return back to the current window from command-line window with
  " inputting <C-c> once.
  nnoremap <buffer> <C-c> <C-c><C-c>
  nmap <buffer> q <C-c>
  imap <buffer> <C-c> <ESC><C-c>

  " Execute an previous command easiler.
  " nnoremap <silent> <buffer> / :<C-u>call <SID>cmdwin_select_history()<CR>

  let cmdwin_type = expand('<afile>')
  if cmdwin_type ==# ':'
    inoremap <expr> <buffer> <C-p> <SID>cmdwin_completion(0)
    inoremap <expr> <buffer> <C-n> <SID>cmdwin_completion(1)
    call s:cmdwin_save_options.store('completeopt')
    setlocal completeopt=menu,preview
    " TODO: Delete lines only when gram.vim is loaded.
    execute printf('silent! 1,$-%d delete _', &cmdwinheight)
    normal! G
    call asyncomplete#disable_for_buffer()
  elseif s:has('/?', cmdwin_type)
    " NOTE: :set hlsearch here does not work.
    augroup vimrc_incsearch
      autocmd!
      autocmd TextChanged,TextchangedI,CursorMoved <buffer>
           \ call s:cmdwin_incsearch()
    augroup END
    let s:cmdwin_incsearch = {'pattern_save': @/}
    if exists('*win_execute')
      let s:cmdwin_incsearch.current_winid = win_getid(winnr('#'))
      function! s:cmdwin_incsearch.win_execute(command) abort
        return s:win_execute(self.current_winid, a:command)
      endfunction
      call s:cmdwin_incsearch.win_execute(
            \ 'let s:cmdwin_incsearch.curpos = getpos(".")')
    endif
  endif
endfunction
function! s:cmdwin_leave() abort
  if exists('s:cmdwin_save_options')
    call s:cmdwin_save_options.restore_all()
  endif
  if s:has('/?', expand('<afile>'))
    let @/ = s:cmdwin_incsearch.pattern_save
    if has_key(s:cmdwin_incsearch, 'curpos')
      call s:cmdwin_incsearch.win_execute(
            \ 'call setpos(".", s:cmdwin_incsearch.curpos)')
    endif
    augroup vimrc_incsearch
      autocmd!
    augroup END
  endif
endfunction
function! s:cmdwin_completion(select_next) abort
  if pumvisible()
    return a:select_next ? '<C-n>' : '<C-p>'
  else
    return "\<C-x>\<C-v>"
  endif
endfunction
function! s:cmdwin_incsearch() abort
  let @/ = getline('.')
  if exists('*win_execute')
    call s:cmdwin_incsearch.win_execute('call s:cmdwin_incsearch_jump()')
  endif
  set hlsearch
  redraw
endfunction
function! s:cmdwin_incsearch_jump() abort
  call setpos('.', s:cmdwin_incsearch.curpos)
  try
    normal! n
  catch
  endtry
endfunction
" function! s:cmdwin_select_history() abort
"   let history = split(execute('history ' .. getcmdwintype()), "\n")[1 :]
"   call map(history, {-> matchstr(v:val, '^>\?\s*\d\+\s\+\zs.\+$')})
"   call reverse(history)
"   call gram#select({
"        \ 'name': getcmdwintype() .. 'history',
"        \ 'items': history,
"        \ 'callback': s:SIDPrefix() .. 'cmdwin_select_history_callback',
"        \ })
" endfunction
" function! s:cmdwin_select_history_callback(item) abort
"   if getline('$') ==# ''
"     call setline('$', a:item.word)
"   else
"     call append('$', a:item.word)
"   endif
"   execute 'noautocmd normal! G$'
" endfunction

let s:cmdwin_save_options = vimrc#class#new('save_options')
augroup vimrc_mapping
  autocmd CmdWinEnter * call s:cmdwin_enter()
  autocmd CmdWinLeave * call s:cmdwin_leave()
augroup END

if has('mac')
  let mapleader='_'
endif
if has('win32')
  inoremap \ _
  inoremap _ \
endif

" Command
let s:_map = []
call add(s:_map, ['nnoremap', '', 'ev', 'edit $MYVIMRC'])
call add(s:_map, ['nnoremap', '', 'sv', 'source $MYVIMRC'])
call add(s:_map, ['nnoremap', '<silent>', 'k', 'call vimrc#mru#start()'])
call add(s:_map, ['nnoremap', '<silent>', 'b', 'call gram#sources#buffers#launch()'])
call add(s:_map, ['nnoremap', '<silent>', 'j', 'call <SID>gof_from_mapping()'])
call add(s:_map, ['nnoremap', '<silent>', 'f', 'call vimrc#filore#start()'])
call add(s:_map, ['nnoremap', '<silent>', 'm', 'MemoList'])
call add(s:_map, ['nnoremap', '<silent>', 'o', 'OtameshiList'])
execute join(map(s:_map, {->join([
      \  v:val[0],
      \  v:val[1],
      \  '<Space>' .. v:val[2],
      \  printf(':<C-u>%s<CR>', v:val[3])
      \ ], ' ')}), "\n")
unlet s:_map
"
"
" Abbreviates
iabbrev todo: TODO:
iabbrev fixme: FIXME:
iabbrev xxx: XXX:
iabbrev note: NOTE:
"
" Commands
" Declarations
command! -bar CdCurrent cd %:p:h
command! -bar LcdCurrent lcd %:p:h
command! -bar TcdCurrent tcd %:p:h
command! -nargs=1 -complete=file Rename file <args>|call delete(expand('#'))
command! CopyToClipboard let @*=@"
command! ClearMessage execute repeat("echom ''\n", 201)
command! Helptags helptags ALL
command! -bang -nargs=+ -complete=command Filter call s:filter(<bang>0, <f-args>)
command! -bar Draft call s:draft()
command! -bar UnDraft call s:undraft()
command! -bar -nargs=* -complete=customlist,VimrcScratchComplete
      \ Scratch call s:scratch(<q-args>)
command! -bar -nargs=+ -complete=command Vimrc <args> $MYVIMRC
command! -bar -nargs=* -complete=file ListTasks call s:list_tasks(<q-args>)
command! DeleteUndoFiles call vimrc#delete_undofiles()
command! -nargs=? -complete=dir Gof call s:gof(<q-args>)
command! Col setlocal cursorcolumn|call popup_create([], {
      \ 'moved': 'any', 'mask': [[1, 1, 1, 1]],
      \ 'callback': {-> execute('setlocal nocursorcolumn')}})

" Plugin Shortcuts
command! -bar -nargs=* MruEditHistoryStart call vimrc#mru#edit_history_start(<q-args>)
command! -bar MruDeleteUnexistHistory call vimrc#mru#delete_unexist_file_history()
command! -bar -nargs=? -complete=dir Filore call vimrc#filore#start(<q-args>)
command! -bar -bang -nargs=? -complete=dir Ls call vimrc#shcmd#ls(<bang>0, <f-args>)
command! -bar -bang -nargs=+ -complete=dir Mkdir call vimrc#shcmd#mkdir(<bang>0, <f-args>)
command! -bar -nargs=+ -complete=dir Touch call vimrc#shcmd#touch(<f-args>)
command! -bar -nargs=+ -complete=dir CpFile call vimrc#shcmd#cpfile(<f-args>)
command! -bar -bang -nargs=+ -complete=file Rm call vimrc#shcmd#rm(<bang>0, <f-args>)
"
function! Execute_list(com) abort
  return split(execute(a:com), "\n")
endfunction
function! Filter(pat, com) abort
  let output = Execute_list(a:com)
  call filter(output, 'v:val=~?a:pat')
  return output
endfunction
function! s:filter(bang, pat, ...) abort
  let output = join(Filter(a:pat, join(a:000, ' ')), "\n")
  if a:bang
    echom output
  else
    echo output
  endif
endfunction
function! s:draft() abort
  let b:vimrc_draft_save_options = vimrc#class#new('save_options')
  call b:vimrc_draft_save_options.store(['buftype', 'swapfile'])
  setlocal buftype=nofile noswapfile
endfunction
function! s:undraft() abort
  if !exists('b:vimrc_draft_savedata')
    return
  endif
  call b:vimrc_draft_savedata.restore_all()
endfunction
function! s:scratch(opener) abort
  let opener = a:opener
  let prefix = 'scratch://'
  let name = s:input('Scratch buffer name? ')
  if name ==# ''
    let identifier = 1
    let name = 'nameless/buffer-'
    while bufexists(prefix .. name .. identifier)
      let identifier += 1
    endwhile
    let name .= identifier
  endif
  if opener ==# ''
    let opener = 'split'
  endif
  execute opener prefix .. name
  call s:draft()
endfunction
function! VimrcScratchComplete(arg_lead, cmd_line, cur_pos) abort
  let pat = '^' .. a:arg_lead
  return filter(['split', 'vsplit', 'tabedit', 'edit'], 'v:val =~? pat')
endfunction
function! s:list_tasks(args) abort
  let target = '%'
  if a:args =~# 'rf'
    let target = '**/*.' .. expand('%:e')
  elseif a:args !=# ''
    let target = a:args
  endif
  execute 'vimgrep /\C\v<(TODO|FIXME|XXX)>/' target
endfunction
def! s:find_gitroot(arg_target: string = bufname('%')): string
  let target: string = resolve(arg_target)
  let git_dir: string = finddir('.git', target .. ';')
  if git_dir ==# ''
    s:echomsg_warning('Not a git repository: ' .. target)
    return ''
  endif
  return fnamemodify(git_dir, ':h')
enddef
def! s:gof(path: string): void
  if !executable('gof')
    echo '"gof" command not found.'
    return
  endif
  let gofcmd = 'gof -f -tf "Tapi_gof"'
  if !empty(path)
    gofcmd ..= ' -d ' .. path
  endif
  let minwidth = min([&columns, 100])
  let minheight = min([&lines, 40])
  popup_create(term_start(gofcmd, {'hidden': 1, 'term_finish': 'close'}),
        \ {'minwidth': minwidth, 'minheight': minheight})
enddef
def! s:gof_from_mapping()
  let git_root = s:find_gitroot()
  s:gof(git_root ==# '' ? getcwd(winnr()) : git_root)
enddef
"TODO: Add export when I add :vim9script on the top of this file.
def! Tapi_gof(bufnum: number, file_info: dict<string>): void
  let winid = win_getid(winnr('#'))
  let buftype = getwinvar(winid, '&buftype')
  let open_cmd = 'edit'
  if !(buftype ==# 'nofile' || buftype ==# '')
    open_cmd = 'split'
  endif
  call win_execute(winid,
        \ printf('%s %s', open_cmd, fnameescape(file_info.fullpath)))
enddef

" Installed plugins
if s:plugin.exists('vim-altr')
  command! -bar AlterForward call altr#forward()
  command! -bar AlterBack call altr#back()
endif
if s:plugin.exists('vim-operator-replace')
  map _r  <Plug>(operator-replace)
endif
if s:plugin.exists('vim-operator-user')
  nmap zf <Plug>(operator-vimrc-fold-zf)
  nmap zF <Plug>(operator-vimrc-fold-zF)
  nmap zd <Plug>(operator-vimrc-fold-zd)
  nmap zD <Plug>(operator-vimrc-fold-zD)
  nmap zE <Plug>(operator-vimrc-fold-zE)
  vmap zf <Plug>(operator-vimrc-fold-zf)
  vmap zF <Plug>(operator-vimrc-fold-zF)
  vmap zd <Plug>(operator-vimrc-fold-zd)
  vmap zD <Plug>(operator-vimrc-fold-zD)
  vmap zE <Plug>(operator-vimrc-fold-zE)
  function! s:map_fold_cmd(keys) abort
    " Available only when foldmethod is marker or manual.
    if !s:has(['marker', 'manual'], &l:foldmethod)
      return
    endif
    let save_options = vimrc#class#new('save_options')
    call save_options.store(['commentstring'])
    let &l:commentstring = ' ' .. &l:commentstring
    try
      execute 'normal!' a:keys
    catch " Usaully this :catch gets E490, 'Folding not found.'
      call s:echomsg_error(v:exception)
    finally
      call save_options.restore_all()
    endtry
  endfunction
  function! s:map_range_fold_cmd(motion_wizeness, keys) abort
    let v_cmd = operator#user#visual_command_from_wise_name(a:motion_wizeness)
    call s:map_fold_cmd(printf('`[%s`]%s', v_cmd, a:keys))

    " Remove spaces in beginning of the line which are inserted when the line was
    " an empty line.
    if &foldmethod ==# 'marker'
      let marker_only_pat = '\m^\s\+%s'
      let marker_pair = ["'[", "']"]
      let foldmarker_pair = split(&l:foldmarker, ', ')
      for index in range(0, len(foldmarker_pair)-1)
        let marker = marker_pair[index]
        let foldmarker = printf(&l:commentstring, foldmarker_pair[index])
        let lnum = getpos(marker)[1]
        if getline(lnum) =~# printf(marker_only_pat, foldmarker)
          call setline(lnum, foldmarker)
        endif
      endfor
    endif
  endfunction
  function! s:map_define_operator() abort
    " ---fold---
    let foldmotions_with_range = 'fF'
    let foldmotions_standalone = 'dDE'
    let sid = s:SIDPrefix()
    for keys in split(foldmotions_with_range .. foldmotions_standalone, '\zs')
      let keys = 'z' .. keys
      let func = [
            \ printf('function! %smap_fold_%s(motion_wise) abort', sid, keys),
            \ printf('  call s:map_range_fold_cmd(a:motion_wise, "%s")', keys),
            \ 'endfunction'
            \]
      execute join(func, "\n")
      call operator#user#define(
            \ 'vimrc-fold-' .. keys,
            \ sid .. 'map_fold_' .. keys)
    endfor

    " Override for normal mode; Any ranges aren't need for following commands.
    let map_cmd = join(['nnoremap',
          \ '<silent>',
          \ '<Plug>(operator-vimrc-fold-%s)',
          \ ':<C-u>call <SID>map_fold_cmd("%s")<CR>'], ' ')
    for keys in split(foldmotions_standalone, '\zs')
      let keys = 'z' .. keys
      execute printf(map_cmd, keys, keys)
    endfor
  endfunction
  augroup vimrc_mapping
    autocmd User vimrc_initialize call s:map_define_operator()
  augroup END
endif
if s:plugin.exists('vim-textobj-entire')
  omap aa <Plug>(textobj-entire-a)
  omap ia <Plug>(textobj-entire-i)
  vmap aa <Plug>(textobj-entire-a)
  vmap ia <Plug>(textobj-entire-i)
  let g:textobj_entire_no_default_key_mappings = 1
endif
if s:plugin.exists('vim-textobj-function')
  omap if <Plug>(textobj-function-i)
  omap af <Plug>(textobj-function-a)
  vmap if <Plug>(textobj-function-i)
  vmap af <Plug>(textobj-function-a)
  let g:textobj_function_no_default_key_mappings = 1
endif
if s:plugin.exists('vim-textobj-indent')
  omap ii <Plug>(textobj-indent-i)
  omap iI <Plug>(textobj-indent-same-i)
  omap ai <Plug>(textobj-indent-a)
  omap aI <Plug>(textobj-indent-same-a)
  vmap ii <Plug>(textobj-indent-i)
  vmap iI <Plug>(textobj-indent-same-i)
  vmap ai <Plug>(textobj-indent-a)
  vmap aI <Plug>(textobj-indent-same-a)
  let g:textobj_indent_no_default_key_mappings = 1
endif
if s:plugin.exists('gina.vim')
  let g:gina#action#mark_sign_text = '*'
  let g:gina#core#console#enable_message_history = 1
  function! s:gina_config() abort
    function! s:gina_nnoremap(scheme, lhs, rhs) abort
      call gina#custom#mapping#nmap(
            \ a:scheme, a:lhs, a:rhs,
            \ {'noremap': 1, 'silent' : 1})
    endfunction

    " <C-]> is expeimental.
    call s:gina_nnoremap('status', '<C-]>', ':<C-u>Gina commit<CR>')
    call s:gina_nnoremap('commit', '<C-]>', ':<C-u>Gina status<CR>')
    call s:gina_nnoremap('status', '<Space>g', ':<C-u>Gina commit<CR>')
    call s:gina_nnoremap('commit', '<Space>g', ':<C-u>Gina status<CR>')
    call s:gina_nnoremap('branch', 'N',
          \ ':<C-u>call gina#action#call("branch:new")<CR>')
    call s:gina_nnoremap('/\v%(status|branch|log)', 'q', ':<C-u>close<CR>')
    nnoremap <silent> <Space>g :<C-u>Gina status<CR>

    " Jump between unadded files with n/p ..
    let rhs_base = printf(
          \ ':<C-u>call %sgina_status_select_another(v:count1, %%d)<CR>',
          \ s:SIDPrefix())
    call s:gina_nnoremap('status', 'n', printf(rhs_base, 0))
    call s:gina_nnoremap('status', 'N', printf(rhs_base, 1))

    call s:gina_nnoremap('status', 'dd',
         \ printf(':<C-u>call %sgina_diff()<CR>', s:SIDPrefix()))

    " Cleanup
    delfunction s:gina_nnoremap

    call gina#custom#action#alias('branch', 'merge', 'commit:merge:no-ff')
    call gina#custom#action#alias('branch', 'merge-ff', 'commit:merge:ff')

    call gina#custom#command#option(
          \ '\v%(^<%(cd|lcd|qrep)>)@<!$', '--opener=edit')
  endfunction
  function! s:gina_status_select_another(repeat_count, search_previous) abort
    let flags = 'w'
    let flags .= a:search_previous ? 'b' : ''
    for i in range(1, a:repeat_count)
      call search('\e[31.\+\e[m', flags)
    endfor
  endfunction
  function! s:gina_diff() abort
    let file = matchstr(getline('.'), '\e[31m\zs.\+\ze\e[m')
    let file = matchstr(file, '\%(\_^modified\:\s\+\)\?\zs.\+')
    if file ==# ''
      return
    endif
    let gitroot = fnamemodify(gina#core#get().repository, ':h')
    let cmd = 'git -C ' .. gitroot ..
          \ ' --no-pager diff --no-color ' .. file
    let bufnr = term_start(cmd , {
          \ 'term_name': '[gina diff] ' .. file,
          \ 'norestore': 1,
          \ })
    if bufnr
      setlocal nocursorline nocursorcolumn filetype=diff
      nnoremap <silent> <buffer> <nowait> q :<C-u>quit<CR>
      call cursor(1, 0)
    endif
  endfunction
  augroup vimrc_gina
    autocmd User vimrc_initialize call s:gina_config()
  augroup END
endif
if s:plugin.exists('vim-findent')
  augroup vimrc_findent
    autocmd FileType * if &l:modifiable | execute 'Findent' | endif
  augroup END
endif
if s:plugin.exists('vim-Verdin')
  let g:Verdin#autoparen = 1
endif
if s:plugin.exists('vim-brownie')
  let g:brownie_template_dirs =
        \ [s:join_path(expand('$DOT_VIM'), 'runtime', 'extension', 'brownie')]
  let g:brownie_extra_imports = {
        \ 'cpp' : ['c'],
        \ 'vimspec': ['vim'],
        \ }

  function! s:brownie_ft() abort
    return getbufvar(brownie#get_current_bufnr(), '&ft')
  endfunction

  command! -nargs=1 -complete=customlist,VimrcTemplateComplete Template
        \ call brownie#extract(s:brownie_ft(), 'template', <q-args>)
  function! VimrcTemplateComplete(arg, line, pos) abort
    return filter(brownie#list(s:brownie_ft(), 'template'),
          \ 'stridx(v:val, a:arg) == 0')
  endfunction
endif
if s:plugin.exists('vim-gram')
  augroup vimrc_gram_init
    autocmd User gram-first-start call s:init_gram_map()
  augroup END

  function! s:init_gram_map() abort
    call gram#custom#map_action('n', '<CR>', 'select-item')
    call gram#custom#map_action('n', 'q', 'quit')
    call gram#custom#map_action('n', 'j', 'select-next-item')
    call gram#custom#map_action('n', 'k', 'select-prev-item')
    call gram#custom#map_action('n', 'i', 'start-insert')
    call gram#custom#map_action('n', 'p', 'preview')
    call gram#custom#map_action('i', '<ESC>', 'stop-insert')
    call gram#custom#map_action('i', '<CR>', 'stop-insert')
    call gram#custom#map_action('i', '<C-j>', 'stop-insert')
    call gram#custom#map_action('i', '<C-h>', 'delete-char')
    call gram#custom#map_action('i', '<C-w>', 'delete-word')
    call gram#custom#map_action('i', '<C-b>', 'move-to-right')
    call gram#custom#map_action('i', '<C-f>', 'move-to-left')
    call gram#custom#map_action('i', '<C-a>', 'move-to-head')
    call gram#custom#map_action('i', '<C-e>', 'move-to-tail')
    call gram#custom#map_action('i', '<C-u>', 'delete-to-head')
    call gram#custom#map_key('n', '<NL>', '<CR>')
    call gram#custom#map_key('i', '<Del>', '<C-h>')
    call gram#custom#map_key('i', '<BS>', '<C-h>')
  endfunction
endif
if s:plugin.exists('vim-textobj-commentblock')
  omap ac <Plug>(textobj-commentblock-a)
  omap ic <Plug>(textobj-commentblock-i)
  vmap ac <Plug>(textobj-commentblock-a)
  vmap ic <Plug>(textobj-commentblock-i)
  let g:textobj_commentblock_no_default_key_mapings = 1

  augroup vimrc_textobj_commentblock
    execute 'autocmd Filetype * call textobj#commentblock#pick#' ..
          \   (s:plugin.exists('caw.vim') ? 'caw' :
          \   'commentstring')
          \ .. '()'
  augroup END
endif
if s:plugin.exists('vim-jplus')
  map J <Plug>(jplus)
endif
if s:plugin.exists('vim-operator-swap')
  map _sy <Plug>(operator-swap-marking)
  map _sp <Plug>(operator-swap)
endif
if s:plugin.exists('asyncomplete.vim')
  " Ignorecase.
  function! s:asyncomplete_preprocessor(context, matches) abort
    let completions = []
    let base = tolower(a:context.base)
    for [source, matches] in items(a:matches)
      for candidate in matches.items
        if stridx(tolower(candidate.word), base) == 0
          call add(completions, candidate)
        endif
      endfor
    endfor
    call asyncomplete#preprocess_complete(a:context, completions)
  endfunction

  let g:asyncomplete_auto_popup = 1
  let g:asyncomplete_force_refresh_on_context_changed = 1
  let g:asyncomplete_smart_completion = 1
  let g:asyncomplete_preprocessor = [function('s:asyncomplete_preprocessor')]

  inoremap <expr> <C-n>
        \ pumvisible() ? "\<C-n>" : asyncomplete#close_popup() .. "\<C-x>\<C-n>"
  inoremap <expr> <C-p>
        \ pumvisible() ? "\<C-p>" : asyncomplete#close_popup() .. "\<C-x>\<C-p>"
  inoremap <expr> <C-e> pumvisible() ? asyncomplete#cancel_popup() : "\<C-e>"

  function! s:register_asyncomplete_sources() abort
    let Register = {options ->
          \ asyncomplete#register_source(
          \ asyncomplete#sources#{options.name}#get_source_options(
          \ options))
          \ }
    if s:plugin.exists('asyncomplete-buffer.vim')
      call Register({
            \ 'name': 'buffer',
            \ 'whitelist': ['*'],
            \ 'completor':
            \   function('asyncomplete#sources#buffer#completor'),
            \ })
    endif
  endfunction
  augroup vimrc_asyncomplete_sources
    autocmd User asyncomplete_setup call s:register_asyncomplete_sources()
  augroup END
endif
if s:plugin.exists('vim-lsp')
  let g:lsp_signs_enabled = 1
  let g:lsp_signs_error = {'text': '>>'}
  let g:lsp_signs_warning = {'text': '--'}
  let g:lsp_signs_information = {'text': '--'}
  let g:lsp_signs_hint = {'text': '? '}
  let g:lsp_diagnostics_enabled = 1
  let g:lsp_diagnostics_float_delay = 10
  let g:lsp_diagnostics_float_cursor = 1

  nnoremap <Plug>(<SID>-open-folding) zv
  nmap <silent> gd <Plug>(lsp-declaration)<Plug>(<SID>-open-folding)
  " nmap <silent> <C-p> <Plug>(lsp-previous-error)
  " nmap <silent> <C-n> <Plug>(lsp-next-error)
endif
if s:plugin.exists('previm')
  let g:previm_show_header = 0
  let g:previm_enable_realtime = 1
endif
if s:plugin.exists('vim-operator-surround')
  map _sa <Plug>(operator-surround-append)
  map _sd <Plug>(operator-surround-delete)
  map _sr <Plug>(operator-surround-replace)
endif
if s:plugin.exists('vim-ambicmd')
  function! s:ambicmd_expand(key) abort
    let expander = ambicmd#expand(a:key)
    return (expander ==# a:key ? '' : "\<C-g>u") .. expander
  endfunction
  augroup vimrc_ambicmd
    autocmd CmdWinEnter : call s:setup_ambicmd_for_cmdwin()
  augroup END
  cnoremap <expr> <Space> ambicmd#expand("\<Space>")
  cnoremap <expr> <CR> ambicmd#expand("\<CR>")
  cnoremap <expr> <bar> ambicmd#expand("\<bar>")

  function! s:setup_ambicmd_for_cmdwin() abort
    inoremap <buffer> <expr> <Space> <SID>ambicmd_expand("\<Space>")
    inoremap <buffer> <expr> <bar> <SID>ambicmd_expand("\<bar>")
    inoremap <buffer> <expr> <CR> <SID>ambicmd_expand("\<CR>")
  endfunction

  let g:ambicmd#show_completion_menu = 1

  function! s:ambicmd_build_rule(cmd) abort
    let rule = []
    let rule += ['\c^' .. a:cmd .. '$']
    let rule += ['\c^' .. a:cmd]

    for len in range(1, strlen(a:cmd))
      let [prefix, suffix] = [strpart(a:cmd, 0, len), a:cmd[len :]]
      let prefix = substitute(toupper(prefix), '.\zs', '\\l*', 'g')
      let matcher ='\C^' .. prefix .. suffix
      let rule += [matcher .. '$', matcher]
    endfor

    let rule += ['\c' .. a:cmd]
    let rule += ['.*' .. substitute(a:cmd, '.\zs', '.*', 'g')]
    return rule
  endfunction
  let g:ambicmd#build_rule = s:SIDPrefix() .. 'ambicmd_build_rule'
endif
if s:plugin.exists('vim-quickrun')
  let g:quickrun_config = {}
  let g:quickrun_config._ = {
    \  'outputter/message': 1,
    \  'outputter/message/log': 1,
    \  'outputter/buffer/close_on_empty': 1,
    \  'runner': 'job',
    \}
  let g:quickrun_config.cpp = {
    \  'cmdopt' : '-std=c++17'
    \}
  " TODO: Improve. (Support windows, etc)
  let g:quickrun_config['cpp/sfml'] = {
    \  'type' : 'cpp',
    \  'cmdopt' : '-std=c++17 -lsfml-audio -lsfml-graphics -lsfml-network -lsfml-system -lsfml-window',
    \}
  let g:quickrun_config.objc = {
    \  'command' : 'cc',
    \  'execute' : ['%c %s -o %s:p:r -framework Foundation', '%s:p:r %a', 'rm -f %s:p:r'],
    \  'tempfile' : '%{tempname()}.m',
    \}
  let g:quickrun_config.applescript = {
    \  'command' : 'osascript',
    \  'execute' : '%c %s:p',
    \  'tempfile' : '%{tempname()}.applescript',
    \}
  let g:quickrun_config.swift = {
    \  'command' : 'swift',
    \  'execute' : '%c %s%p',
    \  'tempfile' : '%{tempname()}.swift',
    \}
  nnoremap <expr> <C-c> quickrun#is_running() ?
        \ ':<C-u>call quickrun#sweep_sessions()<CR>' :
        \ '<C-c>'
  nmap <Space>r <Plug>(quickrun)
  vmap <Space>r <Plug>(quickrun)
  augroup vimrc_filetype
    autocmd FileType quickrun nnoremap <silent> <buffer> q :<C-u>q<CR>
  augroup END
endif
if s:plugin.exists('vim-textobj-between')
  omap ad <Plug>(textobj-between-a)
  omap id <Plug>(textobj-between-i)
  vmap ad <Plug>(textobj-between-a)
  vmap id <Plug>(textobj-between-i)
  let g:textobj_between_no_default_key_mappings = 1
endif
if s:plugin.exists('caw.vim')
  inoremap <Plug>(vimrc:caw:builtin:ESC) <ESC>
  inoremap <Plug>(vimrc:caw:separate-undo) <C-g>u
  inoremap <silent> <Plug>(vimrc:caw:oneline:comment)
        \ <C-r>=b:caw_oneline_comment .. g:caw_dollarpos_sp_right<CR>
  imap <Plug>(vimrc:caw:hatpos:comment)
        \ <Plug>(vimrc:caw:builtin:ESC)<Plug>(caw:hatpos:comment)
  imap <Plug>(vimrc:caw:dollarpos:comment)
        \ <Plug>(vimrc:caw:builtin:ESC)<Plug>(caw:dollarpos:comment)

  function! s:caw_oneline_comment_map(key) abort
    execute printf(
          \ 'inoremap <silent> <Plug>(vimrc:caw:oneline:do-input)%s %s',
          \ a:key, a:key)
    execute printf('imap <expr> %s <SID>caw_oneline_comment(%s)',
          \ a:key, string(a:key))
  endfunction
  function! s:caw_oneline_comment(key) abort
    let do_input = "\<Plug>(vimrc:caw:oneline:do-input)" .. a:key
    if !exists('b:caw_oneline_comment')
      return do_input
    endif

    let prefix = do_input .. "\<Plug>(vimrc:caw:separate-undo)" ..
          \ repeat("\<C-h>", strlen(a:key))
    if getline('.') =~# '\m^\s*$'
      let key = "\<Plug>(vimrc:caw:hatpos:comment)"
    elseif col('.') == col('$')
      let key = "\<Plug>(vimrc:caw:dollarpos:comment)"
    else
      let key = "\<Plug>(vimrc:caw:oneline:comment)"
    endif
    return prefix .. key
  endfunction

  map _c <Plug>(caw:hatpos:toggle:operator)
  call s:caw_oneline_comment_map('<C-l>/')
  let g:caw_no_default_keymappings = 1
  let g:caw_dollarpos_sp_left = repeat("\<Space>", 2)
  let g:caw_dollarpos_sp_right = ' '
  let g:caw_hatpos_sp = ' '
  let g:caw_zeropos_sp = ' '
endif
if s:plugin.exists('autofmt')
  set formatexpr=autofmt#japanese#formatexpr()
endif
" ReadingVimrc
command! -bar ReadingVimrc call s:readingvimrc()
function! s:readingvimrc() abort
  " try
  "   packadd vim-reading-vimrc
  "   ReadingVimrc
  " catch
  " endtry
  " try
  "   packadd vim-readingvimrc-files
  "   let g:readingvimrc_files_listing_window_open_command = 'tabedit'
  "   ReadingVimrcFiles
  "   unlet g:readingvimrc_files_listing_window_open_command
  " catch
  " endtry
  try
    packadd vim-reading-vimrc
    ReadingVimrcNext
  catch
  endtry
endfunction

" Additional plugins
" Taking notes
let s:notes = {'save_dir_': ''}
function! s:notes.instance(path) abort
  let new_obj = deepcopy(self)
  let new_obj.save_dir_ = a:path
  return new_obj
endfunction
function! s:notes.list_files() abort
  return map(s:glob(s:join_path(self.save_dir_, '*.*')),
        \ 'fnamemodify(v:val, ":p:t")')
endfunction
function! s:notes.new(opener) abort
  let name = s:input('Name: ')
  if name ==# ''
    call s:echo('Canceled.')
    return
  endif
  if s:has(self, 'expand_filename')
    let name = self.expand_filename(name)
  endif
  let filepath = s:join_path(self.save_dir_, name)
  execute (a:opener ==# '' ? 'edit' : a:opener) fnameescape(filepath)
endfunction
function! s:notes.list() abort
  call vimrc#files#start(self.save_dir_)
endfunction
function! s:notes.delete(...) abort
  let files = self.list_files()
  for target in a:000
    if !s:has(files, target)
      call s:echomsg_error('File does not exists: ' .. target)
      continue
    endif
    call s:echomsg(printf('Delete %s ? [y/n]', target))
    if s:getchar_string() !~? 'y'
      call s:echomsg('Canceled.')
      continue
    endif
    if delete(s:join_path(self.save_dir_, target)) == 0
      call s:echomsg('Successfully deleted: ' .target)
    else
      call s:echomsg('Failed to delete: ' .target)
    endif
  endfor
endfunction
function! s:notes.get_save_dir() abort
  return self.save_dir_
endfunction
function! s:notes.get_completion(arg_lead) abort
  return map(filter(self.list_files(), 'v:val =~? a:arg_lead'),
        \ 'fnameescape(v:val)')
endfunction
" Define :Memo* :Otameshi*
for s:type_ in ['memo', 'otameshi']
  let s:{s:type_} = s:notes.instance(s:join_path(
      \ s:cache_dir, s:type_))
  if !isdirectory(s:{s:type_}.get_save_dir())
    call mkdir(s:{s:type_}.get_save_dir(), 'p')
  endif
  if isdirectory(s:{s:type_}.get_save_dir())
    let s:com_prefix_ = toupper(s:type_[0]) .. s:type_[1:]
    execute printf('command! -bar -nargs=* %sNew call s:%s.new(<q-args>)',
          \ s:com_prefix_, s:type_)
    execute printf('command! -bar -nargs=+ -complete=customlist,Vimrc%sComplete %sDelete call s:%s.delete(<f-args>)',
          \ s:com_prefix_, s:com_prefix_, s:type_)
    execute printf('command! -bar %sList call s:%s.list()',
          \ s:com_prefix_, s:type_)
    unlet s:com_prefix_
  endif
endfor | unlet s:type_
"
function! s:memo.expand_filename(name) abort
  let name = a:name
  if !s:has(name, '.')
    " Add .md extension only when use didn't specificate extension.
    let name .= '.md'
  endif
  let name = strftime('%Y-%m-%d %H:%M ') .. name
  return name
endfunction
function! s:otameshi.expand_filename(name) abort
  if s:has(a:name, '.') " Filename already has an extension.
    return a:name
  endif
  let extension = s:input('Extension? (Empty will be non-extension file):')
  if extension ==# ''
    return a:name
  else
    return a:name .. '.' .. extension
  endif
endfunction
function! VimrcMemoComplete(arg_lead, cmd_line, cur_pos) abort
  return s:memo.get_completion(a:arg_lead)
endfunction
function! VimrcOtameshiComplete(arg_lead, cmd_line, cur_pos) abort
  return s:otameshi.get_completion(a:arg_lead)
endfunction
"
" working-plugin
command! -bar -nargs=+ -complete=customlist,vimrc#workingplugin#complete
      \ WorkingPluginLoad call vimrc#workingplugin#load(<f-args>)
command! -bar -bang -nargs=1 -complete=customlist,vimrc#workingplugin#complete
      \ WorkingPluginCd call vimrc#workingplugin#cd(<bang>0, <q-args>)
command! -bar -nargs=+ WorkingPluginClone call vimrc#workingplugin#clone(<f-args>)
command! -bar -nargs=+ WorkingPluginNew call vimrc#workingplugin#new(<f-args>)
command! -bar -nargs=+ -complete=customlist,vimrc#workingplugin#complete
      \ WorkingPluginRm call vimrc#workingplugin#rm(<f-args>)
" Sessions
let s:session_dir = s:join_path(s:cache_dir, 'sessions')
call s:mkdir(s:session_dir)
command! MkSession call vimrc#session#make()
command! -nargs=+ -complete=custom,vimrc#session#complete DelSession
      \ call vimrc#session#delete(1, <f-args>)
command! -nargs=1 -complete=custom,vimrc#session#complete RestoreSession
      \ call vimrc#session#restore(<q-args>)

" statusline
function! s:statusline_generator() abort
  let statusline =
        \ '%m' ..
        \ '[%{&ft ==# "" ? "No ft" : &ft}]' ..
        \ '[#%{bufnr("%")}]' ..
        \ (s:plugin.exists('gina.vim') ?
        \   '[%{gina#component#repo#branch() ==# "" ? "no-git" : gina#component#repo#branch()}]' :
        \   '') ..
        \ '%{<SID>filename_label(bufnr("%"))}' ..
        \ '%<%=' ..
        \ '[%{pathshorten(getcwd(winnr()))}]'
  return substitute(statusline, '\c<SID>', s:SIDPrefix(), 'g')
endfunction
def! s:filename_label(bufnr: number): string
  let buftype = getbufvar(bufnr, '&buftype')
  let bufname = bufname(bufnr)
  if buftype ==# 'help'
    return fnamemodify(bufname, ':t')
  elseif buftype ==# 'quickfix'
    return '[quickfix]'
  elseif getbufvar(bufnr, '&previewwindow')
    return '[preview]'
  elseif buftype ==# 'terminal'
    return 'terminal:' .. bufname
  elseif buftype ==# 'prompt'
    return '[prompt]'
  else
    return (buftype ==# 'nofile' ? ' *NoFile* ' : '') ..
      \ (bufname ==# '' ? '[NoName]' : pathshorten(fnamemodify(bufname, ':.')))
  endif
  return ''
enddef
let &statusline = printf('%%!%sstatusline_generator()', s:SIDPrefix())

" tabline
let &tabline = printf('%%!%stabline()', s:SIDPrefix())
function! s:showmode_init() abort
  let colors={
    \ 'normal': [['22', '148'], ['#005f00', '#afdf00']],
    \ 'insert': [['23', '117'], ['#005f5f', '#87dfff']],
    \ 'visual': [['88', '208'], ['#870000', '#ff8700']],
    \ 'replace': [['231', '160'], ['#ffffff', '#df0000']],
    \ }
  for mode in keys(colors)
    execute printf('highlight VimrcShowMode%s ctermfg=%s ctermbg=%s guifg=%s guibg=%s',
          \ mode,
          \ colors[mode][0][0],
          \ colors[mode][0][1],
          \ colors[mode][1][0],
          \ colors[mode][1][1])
  endfor
endfunction
function! s:showmode_mode() abort
  call s:showmode_highlight()
  let map = {
    \ 'n': 'NORMAL',
    \ 'i': 'INSERT',
    \ 'R': 'REPLACE',
    \ 'v': 'VISUAL',
    \ 'V': 'V-LINE',
    \ "\<C-v>": 'V-BLOCK',
    \ 'c': 'COMMAND',
    \ 'ce': 'EX-COM',
    \ 's': 'SELECT',
    \ 'S': 'S-LINE',
    \ "\<C-s>": 'S-BLOCK',
    \ 't': 'T-INSERT',
    \ 'no': 'OPERATOR',
    \ 'niI': 'N-INSERT',
    \ 'niR': 'N-REPLACE',
    \ 'niV': 'N-V-REPLACE',
    \ }
  return get(map, mode(), 'UNKNOWN')
endfunction
function! s:showmode_highlight() abort
  let type = get({
    \  'i': 'insert',
    \  't': 'insert',
    \  'R': 'replace',
    \  'v': 'visual',
    \  'V': 'visual',
    \  "\<C-v>": 'visual',
    \  },
    \ mode(), 'normal')
  execute 'highlight link VimrcShowMode VimrcShowMode' .. type
  return ''
endfunction
def! s:showmode_label(): string
  return '%#VimrcShowMode# %{<SID>showmode_mode()} %#TabLine#'
enddef
def! s:generate_tabinfo(tabnr: number): string
  let tablist = tabpagebuflist(tabnr)
  let info = ''
  info ..= len(filter(copy(tablist), 'getbufvar(v:val, "&mod")')) ? '[+]' : ''
  info ..= '[' .. tabpagewinnr(tabnr, '$') .. ']'
  return info
enddef
def! s:tabline(): string
  let tabline = s:showmode_label() .. '%#TabLine#|'
  let t = tabpagenr()

  for n in range(1, tabpagenr('$'))
    tabline ..= '%' .. n .. 'T'
    let info = ' ' .. s:generate_tabinfo(n) .. ' '
    if t == n
      tabline ..= '%#TabLineSel# %999Xx%X' .. info .. '%#TabLine#'
    else
      tabline ..= info
    endif
    tabline ..= '%T|'
  endfor
  tabline ..= '%>%=[%{pathshorten(getcwd())}]'

  return substitute(tabline, '\c<SID>', s:SIDPrefix(), 'g')
enddef
augroup vimrc_showmode
  autocmd ColorScheme * call s:showmode_init()
  autocmd User vimrc_initialize call s:showmode_init()
augroup END

" :terminal
augroup vimrc_terminal
  autocmd TerminalOpen * call s:terminal_open()
augroup END
def! s:terminal_open(): void
  " Ignore terminal in popup-window.
  " FIXME: Using getbufvar() doesn't work.
  if bufnr('%') == expand('<abuf>')
    setlocal nonumber norelativenumber
  endif
enddef
"
" EmphasisIndent
hi link VimrcEmphasisIndent CursorLine
augroup vimrc_emphasize_indent
  autocmd WinEnter * call s:emphasize_indent()
  autocmd OptionSet expandtab,smarttab,tabstop,shiftwidth call s:emphasize_indent()
  autocmd User vimrc_initialize call s:emphasize_indent()
augroup END
function! s:emphasize_indent() abort
  if exists('w:disable_emphasis_indent') && w:disable_emphasis_indent
    return
  endif
  if exists('w:emphasis_indent_id')
    call matchdelete(w:emphasis_indent_id)
  endif

  let pat = '\v%%(^%%(%s)*)@<=%s'
  if &l:expandtab || &l:smarttab
    let pat = printf(pat, repeat('\s', shiftwidth()), '\s')
  else
    let pat = printf(pat, '\t\t', '\t')
  endif
  let w:emphasis_indent_id=matchadd('VimrcEmphasisIndent', pat)
endfunction
function! s:emphasis_indent_enable() abort
  let w:disable_emphasis_indent = 0
  call s:emphasize_indent()
endfunction
function! s:emphasis_indent_disable() abort
  let w:disable_emphasis_indent = 1
  if exists('w:emphasis_indent_id')
    call matchdelete(w:emphasis_indent_id)
    unlet w:emphasis_indent_id
  endif
endfunction
command! EmphasisIndentDisable call s:emphasis_indent_disable()
command! EmphasisIndentEnable call s:emphasis_indent_enable()
"
" WarningSpace
hi link WarningSpace Error
augroup vimrc_warningspace
  autocmd WinEnter * call s:warningspace()
  autocmd OptionSet * call s:warningspace()
  autocmd User vimrc_initialize call s:warningspace()
augroup END
function! s:warningspace() abort
  " Clean up.
  if exists('w:twobyte_space_id')
    call matchdelete(w:twobyte_space_id)
    unlet w:twobyte_space_id
  endif
  if exists('w:end_of_line_space_id')
    call matchdelete(w:end_of_line_space_id)
    unlet w:end_of_line_space_id
  endif

  if &buftype!=#'' || !(&ma)
    return
  endif

  " Zenkaku space
  " NOTE: '\%d12288' means one zenkaku space. HINT: nr2char(12288)
  let w:twobyte_space_id = matchadd('WarningSpace', '\%d12288')

  " End of line's space
  let w:end_of_line_space_id = matchadd('WarningSpace', '\s\+$')
endfunction
command! ReplaceTwobyteSpace keeppatterns %s/\%d12288/ /g
command! DeleteLineEndSpace keeppatterns %s/\s\+$//g
"
" mru
let g:mru_history_file = s:join_path(s:cache_dir, 'mru', 'history')
let g:mru_ignore_pattern = [
      \ '\.git\>',
      \ '^\V\%(' .. escape(expand('~'), '\') .. '\)\@!'
      \ ]
"
" gram, filore
function! s:gram_mapping() abort
  let map = [
        \ ['k', 'loop-cursor-up'],
        \ ['j', 'loop-cursor-down'],
        \ ['<CR>', 'select-item'],
        \ ['i', 'start-filtering'],
        \ ['q', 'exit'],
        \]
  call map(map, {key, val ->
        \ 'nmap <buffer> ' .. val[0] .. ' <Plug>(gram-' .. val[1] .. ')'})
  execute join(map, "\n")
endfunction
function! s:filore_mapping() abort
  let map = [
        \ ['q', 'exit'],
        \ ['o', 'toggle-directory-folding'],
        \ ['l', 'enter-directory'],
        \ ['h', 'leave-directory'],
        \ ['.', 'toggle-show-hidden-files'],
        \ ['k', 'loop-cursor-up'],
        \ ['j', 'loop-cursor-down'],
        \ ['<CR>', 'open-file'],
        \ ['H', 'start-history'],
        \]
  call map(map, {key, val ->
        \ 'nmap <buffer> ' .. val[0] .. ' <Plug>(filore-' .. val[1] .. ')'})
  execute join(map, "\n")
endfunction
augroup vimrc_additional_plugins
  autocmd User gramOpen call s:gram_mapping()
  autocmd FileType filore call s:filore_mapping()
augroup END
"
" git
def! s:git_diff_getcmd(arg_target: string): string
  let target: string = resolve(arg_target)
  let gitroot: string = s:find_gitroot(target)
  if gitroot ==# ''
    return ''
  endif
  return printf('git -C %s --no-pager diff --no-color %s',
        \ gitroot, shellescape(target))
enddef
def! s:git_diff(arg_target: string = bufname('%')): void
  let target: string = resolve(arg_target)
  if getftype(target) ==# ''
    s:echomsg_error('File or directory does not exists: ' .. target)
    return
  endif
  let cmd: string = s:git_diff_getcmd(target)
  if cmd ==# ''
    return
  endif
  let bufnr = term_start(cmd, {
        \ 'term_name': '[git diff] ' .. fnamemodify(target, ':~:.'),
        \ 'norestore': 1,
        \ })
  if bufnr
    setlocal nocursorline nocursorcolumn filetype=diff
    nnoremap <silent> <buffer> <nowait> q :<C-u>quit<CR>
    cursor(1, 0)
  endif
  return
enddef
command! -nargs=? -complete=file GitDiff call s:git_diff(<q-args>)
"
" compblock
let s:compblock_config_funcs = {'c': {}, 'vim': {}, 'sh': {}}
function! s:compblock_config_funcs.get_indent(line) abort
  return matchstr(a:line, '^\s*')
endfunction
function! s:compblock_config_funcs.c.brace(lines) abort
  let indent = s:compblock_config_funcs.get_indent(a:lines.prev)

  if a:lines.next =~# '\v^' .. indent .. '}.*;'
    return v:null
  endif

  if a:lines.prev =~# '\v<%(struct|class|enum|union)>'
    if a:lines.next =~# '\v<%(public|protected|private)>:'
      return v:null
    endif
    return '};'
  elseif a:lines.prev =~# '\v^\s*if>'
    if a:lines.next =~# '\v^' .. indent .. '%(}\s*)?<else>'
      return v:null
    endif
  elseif a:lines.prev =~# '\v^\s*switch>'
    if a:lines.next =~# '\v^\s*\S+:'
      return v:null
    endif
  endif

  return '}'
endfunction
function! s:compblock_config_funcs.vim.endif(lines) abort
  let indent = s:compblock_config_funcs.get_indent(a:lines.prev)
  if a:lines.next =~# '\v^' .. indent .. 'else%[if]'
    return v:null
  endif
  return 'endif'
endfunction
function! s:compblock_config_funcs.vim.endtry(lines) abort
  let indent = s:compblock_config_funcs.get_indent(a:lines.prev)
  if a:lines.next =~# '\v^' .. indent .. '%(catch|finally)'
    return v:null
  endif
  return 'endtry'
endfunction
function! s:compblock_config_funcs.sh.fi(lines) abort
  let indent = s:compblock_config_funcs.get_indent(a:lines.prev)
  if a:lines.next =~# '\v^' .. indent .. '%(elif|else)'
    return v:null
  endif
  return 'fi'
endfunction
" NOTE: Keys are evaluated under very magic.
" TODO: Add html tags completion?
let s:compblock_config = {
     \ '_': {
     \   '\{\s*$': '}',
     \ },
     \ 'c': {
     \   '\{\s*$': s:compblock_config_funcs.c.brace,
     \ },
     \ 'cpp': {},
     \ 'sh': {
     \   '%(^|;)\s*<do>': 'done',
     \   '^\s*if>': s:compblock_config_funcs.sh.fi,
     \ },
     \ 'zsh': {},
     \ 'vim': {
     \   '\{\s*$': v:null,
     \   '^\s*\{\s*$': '}',
     \   '^\s*%(export\s)?\s*def!?\s+\S+(.*).*$': 'enddef',
     \   '^\s*function!?\s+\S+(.*).*$': 'endfunction',
     \   '^\s*if>': s:compblock_config_funcs.vim.endif,
     \   '^\s*while>': 'endwhile',
     \   '^\s*for>': 'endfor',
     \   '^\s*try>': s:compblock_config_funcs.vim.endtry,
     \   '^\s*echohl\s+%(NONE)@!\S+$': 'echohl NONE',
     \   '^\s*augroup\s+%(END)@!\S+$': 'augroup END',
     \ },
     \ 'vimspec': {
     \   '^\s*%(Describe|Before|After|Context|It)': 'End',
     \ },
     \ }
call extend(s:compblock_config.cpp, s:compblock_config.c)
call extend(s:compblock_config.vimspec, s:compblock_config.vim)
call extend(s:compblock_config.zsh, s:compblock_config.sh)
def! s:compblock_init_for_buffer(): void
  if !exists('b:compblock_ctx')
    b:compblock_ctx = {
         \ 'line_count': line('$'),
         \ 'cur_line': line('.'),
         \ }
  endif
  if !exists('b:compblock_try_to_apply')
    b:compblock_try_to_apply = v:false
  endif
enddef
def! s:compblock_need_try(): bool
  return line('$') > b:compblock_ctx.line_count &&
       \ line('.') > b:compblock_ctx.cur_line
enddef
def! s:compblock_get_one_indent(): string
  if &l:expandtab
    return repeat(' ', shiftwidth())
  else
    return "\t"
  endif
  return ''  # Cannot reach here.
enddef
function! s:compblock_get_indent_depth(line) abort
  let indent = getline(a:line)->matchstr('^\s*')
        \->substitute('\t', repeat(' ', shiftwidth()),'g')->strlen()
  return indent / shiftwidth()
endfunction
def! s:compblock_get_indent_str(depth: number): string
  return repeat(s:compblock_get_one_indent(), depth)
enddef
function! s:compblock_get_config() abort
  let ft_configs = get(s:compblock_config, &filetype, {})
  let wide_configs = get(s:compblock_config, '_', {})->
        \filter({key, val -> !has_key(ft_configs, key)})

  return items(ft_configs) + items(wide_configs)
endfunction
function! s:compblock_try_to_apply() abort
  let b:compblock_try_to_apply = v:false
  let nextlinenr = nextnonblank(line('.') + 1)
  if s:compblock_get_indent_depth(nextlinenr) >
       \ s:compblock_get_indent_depth(line('.') - 1)
    return
  endif
  let prev_line = getline(line('.') - 1)
  let configs = s:compblock_get_config()
  for [pattern, Block_end] in configs
    if prev_line !~# '\v' .. pattern
      continue
    endif
    if type(Block_end) == v:t_func
      let Block_end = Block_end({'prev': prev_line, 'current': getline('.'),
            \ 'next': getline(nextlinenr)})
    endif
    if type(Block_end) == v:t_none
      " Cancel.
      continue
    endif
    let indent_depth = s:compblock_get_indent_depth(line('.') - 1)
    let indent =  s:compblock_get_indent_str(indent_depth)
    let newline = indent .. Block_end
    if getline(nextlinenr) ==# newline
      continue
    endif
    let after_cursor = s:strdivpos(getline('.'), col('.') - 1)[1]
    if mode() =~# '^i' && after_cursor !=# ''
      if after_cursor !=# Block_end
        continue
      else
        call setline('.', s:compblock_get_indent_str(indent_depth + 1))
        call cursor(line('.'), strlen(getline('.')) + 1)
      endif
    endif
    call append('.', newline)
  endfor
  call s:compblock_update_ctx()
endfunction
function! s:compblock_update_ctx() abort
  if s:is_cmdwin()
    return
  endif
  let b:compblock_ctx.line_count = line('$')
  let b:compblock_ctx.cur_line = line('.')
endfunction
def! s:compblock_on_CursorMoved(): void
  if s:is_cmdwin()
    return
  endif
  if s:compblock_need_try()
    b:compblock_try_to_apply = v:true
  endif
  s:compblock_update_ctx()
enddef
def! s:compblock_on_TextChanged(): void
  if s:is_cmdwin()
    return
  endif
  if b:compblock_try_to_apply
    s:compblock_try_to_apply()
  endif
enddef
def! s:compblock_on_InsertEnter(): void
  if s:is_cmdwin()
    return
  endif
  if s:compblock_need_try()
    s:compblock_try_to_apply()
  endif
enddef
def! s:compblock_on_InsertLeave(): void
  if s:is_cmdwin()
    return
  endif
  b:compblock_try_to_apply = v:false
enddef
augroup vimrc_compblock
  autocmd BufEnter * call s:compblock_init_for_buffer()
  autocmd CursorMoved,CursorMovedI * call s:compblock_on_CursorMoved()
  autocmd TextChanged,TextChangedI * call s:compblock_on_TextChanged()
  autocmd InsertEnter * call s:compblock_on_InsertEnter()
  autocmd InsertLeave * call s:compblock_on_InsertLeave()
augroup END

" zsh
" function! Tapi_edit_line(bufnr, args) abort
"   let buffer = a:args[0]
"   let curpos = a:args[1]
"   echom $KEYMAP
" endfunction

" lvimrc
let s:_lvimrc = s:rc('lvimrc')
if filereadable(s:join_path(expand('~'), s:_lvimrc))
  let s:_lvimrc = s:join_path('~', s:_lvimrc)
  execute 'command! -bar -nargs=* LVimrc ' ..
        \ 'execute ((<q-args> ==# "") ? "edit" : <q-args>)' string(s:_lvimrc)
  execute 'source' s:_lvimrc
endif | unlet s:_lvimrc

" gvimrc
if has('gui_running')
  if has('vim_starting')
    set lines=999
    set columns=9999
  endif
  set guioptions& guioptions-=e guioptions-=T
  set guioptions-=R guioptions-=r guioptions-=L guioptions-=l
  set mouse=a
  set nomousefocus
  set mousehide

  if has('win32')
    set guifont=MS_Gothic:h10:cSHIFTJIS
    set linespace=1

    set columns=120
  elseif has('mac')
    set guifont=Osaka-Mono:h14
    "set columns=120
  elseif has('xfontset')
    "for unix (use xfontset)
    set guifont=a14,r14,k14
  endif

  if has('multi_byte_ime') || has('xim')
    set iminsert=0 imsearch=0
    augroup vimrc_iminsert
      autocmd InsertLeave * set iminsert=0
    augroup END
  endif
endif
" Initialize when loading this file.
augroup vimrc_initialize_dummy
  " Do not provide an error. For more information, see `:h E217`
  autocmd User vimrc_initialize " Do nothing.
augroup END

if has('vim_starting')
  augroup vimrc_initialize
    autocmd VimEnter * doautocmd User vimrc_initialize
  augroup END
else
  doautocmd User vimrc_initialize
endif
